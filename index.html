<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sisyphus' Ruin — Docked</title>
<style>
  :root{
    --bg:#080014; --text:#fef8ff; --muted:#cdaeff;
    --accent:#ff9e2c; --accent-2:#ff00b8; --accent-3:#00b7ff; --accent-4:#ff4efc;
  }
  body{
    margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    min-height: 100vh; background-color:#050010;
    background-image:
      radial-gradient(900px 700px at 50% -200px, rgba(255,0,200,.15), transparent 70%),
      radial-gradient(900px 700px at 50% 120%, rgba(0,200,255,.12), transparent 70%),
      linear-gradient(180deg,#0b0014 0%, #050010 100%);
    background-repeat:no-repeat; background-size:cover;
  }
  .app{max-width:1100px;margin:0 auto;padding:12px}
  h1{
    text-align:center; font-size:clamp(22px,3vw,30px); margin:14px 0 12px; letter-spacing:.5px;
    background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));
    -webkit-background-clip:text; color:transparent;
  }
  .grid{display:grid;grid-template-columns:1fr 360px;gap:12px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .card{background:transparent;padding:14px;border:none}
  .btn{
    appearance:none; background:#1c0130; border:none; color:var(--text); border-radius:6px;
    padding:10px 14px; cursor:pointer; font-weight:600; letter-spacing:.3px;
    transition:background .15s ease,transform .1s ease; box-shadow:inset 0 0 0 1px rgba(255,255,255,.1);
  }
  .btn:hover{background:#2d0048}
  .btn:active{transform:scale(.97)}
  
  /* DOCKED ROLL BUTTON STYLES */
  .docked-control {
    position: sticky;
    top: 0;
    z-index: 1000;
    background: rgba(5, 0, 16, 0.85); /* Translucent dark bg */
    backdrop-filter: blur(8px); /* Glass effect */
    margin: -12px -12px 12px -12px; /* Pull out of parent padding */
    padding: 12px;
    border-bottom: 1px solid rgba(255, 166, 0, 0.15);
    display: flex;
    justify-content: center;
  }

  .btn.big{
    display:block; width:100%; font-size:20px; padding:16px;
    /* margin-bottom removed as padding handles spacing in docked view */
    margin-bottom:0; 
    background:#ff9e2c; color:#120026; font-weight:700;
    max-width: 600px; /* Prevent it from getting too wide on desktop */
  }
  .btn.big:hover{background:#ffb64d}
  
  label{width:120px;font-size:12px;color:var(--muted)}
  
  input[type="number"],select{
    background:#140026; color:var(--text); border:none; border-radius:4px;
    padding:6px 8px; 
    width: 54px;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.1);
  }
  select#speed { width: auto; }
  input#nRolls { width: 60px; }

  .desc{font-size:11px;opacity:.6;color:var(--muted);margin:-2px 0 8px; display:block; line-height:1.3;}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .bar{
    height:10px; background:rgba(255,255,255,.06); border-radius:8px;
    overflow:hidden; margin:3px 0; border:1px solid rgba(255,166,0,.12);
  }
  .bar>div{height:100%}
  .bar .win{background:linear-gradient(90deg,#ffd94d,var(--accent))}
  .bar .neu{background:linear-gradient(90deg,var(--accent-3),var(--accent-2))}
  .bar .loss{background:linear-gradient(90deg,var(--accent-4),#ff2400)}
  .kpos-track,.lpos-track{
    height:6px; background:rgba(255,255,255,.06); border:1px solid rgba(255,166,0,.12);
    border-radius:6px; overflow:hidden;
  }
  .kpos-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-4))}
  .lpos-fill{height:100%;background:linear-gradient(90deg,var(--accent-3),var(--accent-2))}
  #log{
    height:160px; overflow:auto; background:rgba(18,0,38,.35); border:1px solid rgba(255,166,0,.12);
    border-radius:10px; padding:8px; font-family:monospace; font-size:12px;
    white-space:pre-wrap; overflow-wrap:break-word; word-break:break-word;
  }
  svg#spark{width:100%;height:60px}
  .tiny{font-size:11px;opacity:.65;color:var(--muted)}
  .mono{font-family:monospace;}
  .small{font-size:12px;}

  .recent.win #recent-outcome{color:#ffd54a; text-shadow:0 0 6px rgba(255,213,74,.65),0 0 18px rgba(255,180,0,.4);}
  .recent.neu #recent-outcome{color:#a98dff}
  .recent.loss #recent-outcome{color:#ff4d4d; text-shadow:0 0 6px rgba(255,77,77,.65),0 0 18px rgba(255,40,40,.4);}
  
  .cycle-entry {
    font-family: monospace; font-size: 11px; border-radius: 4px; 
    border-left: 3px solid rgba(255,255,255,.12); padding: 4px 6px; 
    margin-bottom: 4px; background: rgba(12,0,32,0.6); 
    white-space: pre-wrap; word-break: break-word;
    display: flex; flex-direction: column; gap: 1px;
  }
  .cycle-entry.loss { border-color: rgba(255,90,90,.8); }
  .cycle-entry.top { border-color: rgba(255,210,90,.9); background: rgba(30,20,0,0.4); }
  .cycle-entry-top-row { display: flex; justify-content: space-between; align-items: baseline; font-weight: 600; opacity: 0.9; line-height: 1.2; }
  .cycle-id { color: var(--accent-3); margin-right: 6px; }
  .cycle-meta { font-weight: 400; opacity: 0.65; font-size: 10px; }
  .cycle-entry-path { opacity: 0.75; font-size: 10px; line-height: 1.1; letter-spacing: 1px; margin-top: 1px; }

  .stats-grid {
    display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-top: 6px;
    background: rgba(255,255,255,0.03); padding: 6px; border-radius: 6px;
  }
  .stat-box { display: flex; flex-direction: column; align-items: center; }
  .stat-label { font-size: 10px; opacity: 0.5; text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-val { font-family: monospace; font-size: 13px; font-weight: 600; color: var(--accent-3); }
</style>
</head>
<body>

<template id="tpl-cycle-entry">
  <div class="cycle-entry">
    <div class="cycle-entry-top-row">
      <span class="cycle-main-text"></span>
      <span class="cycle-meta"></span>
    </div>
    <div class="cycle-entry-path"></div>
  </div>
</template>

<div class="app">
  <h1>Sisyphus' Ruin</h1>

  <div class="docked-control">
    <button class="btn big" id="roll1_big">Roll</button>
  </div>

  <div class="grid">
    <div>
      <div class="card recent" id="recent-card">
        <div style="display:flex;flex-direction:column;gap:2px">
          <div id="recent-outcome" style="font-weight:900;letter-spacing:1px;font-size:clamp(20px,3.2vw,32px)">No rolls yet</div>
          <div class="tiny mono">(k,ℓ): <span id="recent-kl">(1,0)→(1,0)</span></div>
        </div>
        <div class="recent-bars" style="margin-top:8px;display:grid;gap:6px">
          <div class="row recent-bar"><span style="width:46px">win</span><div class="bar" style="flex:1"><div id="rbar-win" class="win" style="width:0%"></div></div><span id="rpct-win" class="small mono">0.0%</span></div>
          <div class="row recent-bar"><span style="width:46px">neutral</span><div class="bar" style="flex:1"><div id="rbar-neu" class="neu" style="width:0%"></div></div><span id="rpct-neu" class="small mono">0.0%</span></div>
          <div class="row recent-bar"><span style="width:46px">loss</span><div class="bar" style="flex:1"><div id="rbar-loss" class="loss" style="width:0%"></div></div><span id="rpct-loss" class="small mono">0.0%</span></div>
          <div class="kpos"><div class="kpos-track"><div id="kpos-fill" class="kpos-fill" style="width:0%"></div></div><div class="small">k-position: <span id="kpos-text">1 / 20</span></div></div>
          <div class="lpos" style="margin-top:4px"><div class="lpos-track"><div id="lpos-fill" class="lpos-fill" style="width:0%"></div></div><div class="small">ℓ-position: <span id="lpos-text">0 / 20</span></div></div>
          <div class="row tiny" style="margin-top:2px">p(win | !neutral): <span id="recent-p-cond" class="mono">—</span></div>
          <div class="row tiny" style="margin-top:0">p(top hit | current state): <span id="recent-p-top" class="mono">—</span></div>
        </div>
      </div>

      <div class="card"><h2 style="margin:0 0 8px">Sparkline</h2><svg id="spark" viewBox="0 0 300 60" preserveAspectRatio="none"></svg></div>

      <div class="card"><h2 style="margin:0 0 8px">Run Stats</h2>
        <div class="small" style="margin-bottom:6px">steps: <span class="mono" id="run-steps">0</span></div>
        <div class="bar"><div class="win" id="bar-win" style="width:0%"></div></div>
        <div class="bar"><div class="neu" id="bar-neu" style="width:0%"></div></div>
        <div class="bar"><div class="loss" id="bar-loss" style="width:0%"></div></div>
        <div class="row" style="justify-content:space-between">
          <div>win: <span class="mono" id="c-win">0</span> (<span class="mono" id="r-win">0.0%</span>)</div>
          <div>neutral: <span class="mono" id="c-neu">0</span> (<span class="mono" id="r-neu">0.0%</span>)</div>
          <div>loss: <span class="mono" id="c-loss">0</span> (<span class="mono" id="r-loss">0.0%</span>)</div>
        </div>
        <div class="row tiny" style="margin-top:6px;justify-content:space-between">
          <div>longest cycle: <span class="mono" id="longest-cycle">0</span></div>
          <div>max k: <span class="mono" id="max-k">1</span></div>
        </div>
      </div>

      <div class="card"><div id="log"></div></div>

      <div class="card"><h2 style="margin:0 0 8px">Cycle Summaries</h2><div id="cycle-box" class="tiny"></div></div>
    </div>

    <div>
      <div class="card"><h2 style="margin:0 0 8px">Play Controls</h2>
        <div class="row">
          <input id="nRolls" type="number" value="20">
          <button class="btn" id="rollN">Roll N</button>
          <button class="btn" id="auto">Auto</button>
          <select id="speed">
            <option value="1000">Slow</option>
            <option value="100" selected>Normal</option>
            <option value="10">Fast (Turbo)</option>
          </select>
        </div>
        <div class="row" style="margin-top:8px">
          <span class="tiny" style="min-width:110px">Set state (k, ℓ):</span>
          <input id="set-k" type="number" min="1" value="1">
          <input id="set-l" type="number" min="0" value="0">
          <button class="btn" id="setStateBtn">Set</button>
        </div>
      </div>

      <div class="card"><h2 style="margin:0 0 8px">System</h2>
        <div class="tiny" style="line-height:1.45">
          This process tracks a state <strong>(k, ℓ)</strong> where k is progress up a ladder (1 → M) and ℓ is momentum (0 → L).<br>
          On each roll you get a <strong>win</strong> (k increases, ℓ drops), <strong>neutral</strong> (k stays, ℓ rises), or <strong>loss</strong> (reset to k=1, ℓ=0).<br>
          At k = M, a win becomes a <strong>Top Hit</strong>.
        </div>
      </div>

      <div class="card" id="params-container">
        <h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Parameters</h3>
        <div class="row"><label>M (k levels)</label><input id="M" type="number" value="20"></div>
        <div class="desc">How many rungs in the ladder.</div>
        <div class="row"><label>L (ℓ max)</label><input id="L" type="number" value="20"></div>
        <div class="desc">Momentum scale; ℓ ∈ [0, L].</div>
        <div class="row"><label>w_min → w_max</label><input id="w_min" type="number" step="0.01" value="0.10"><input id="w_max" type="number" step="0.01" value="0.90"></div>
        <div class="desc">Win rises from w_min at k=1 to w_max at k=M.</div>
        <div class="row"><label>β (k ramp)</label><input id="beta" type="number" step="0.1" value="1.5"></div>
        <div class="desc">β > 1 makes late k much easier.</div>
        <div class="row"><label>ρ, γ (ℓ boost)</label><input id="rho" type="number" step="0.05" value="0.6"><input id="gamma" type="number" step="0.1" value="1.5"></div>
        <div class="desc">Higher ℓ → more win probability.</div>
        <div class="row"><label>c_min → c_max</label><input id="c_min" type="number" step="0.01" value="0.03"><input id="c_max" type="number" step="0.01" value="0.10"></div>
        <div class="desc">Loss floor/ceiling.</div>
        <div class="row"><label>α (loss decay)</label><input id="alpha" type="number" step="0.1" value="0.3"></div>
        <div class="desc">Higher ℓ reduces loss via exp decay.</div>
        <div class="row"><label>g_n, s_w</label><input id="g_n" type="number" value="1"><input id="s_w" type="number" value="20"></div>
        <div class="desc">Momentum gain (neutral) vs spend (win).</div>
        <div class="row"><button class="btn" id="apply">Apply & Reset</button><button class="btn" id="resetState">Reset State</button></div>
      </div>

      <div class="card"><h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Expectations</h3>
        <div class="row tiny" style="flex-direction:column;align-items:flex-start;gap:2px">
          <div>win rate (per roll): <span class="mono" id="exp-win-rate">—</span></div>
          <div>loss rate (per roll): <span class="mono" id="exp-loss-rate">—</span></div>
          <div>average cycle length: <span class="mono" id="exp-cycle-len">—</span> rolls</div>
          <div>E[first top hit]: <span class="mono" id="exp-time-top">—</span> rolls</div>
        </div>
      </div>

      <div class="card"><h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Distributions</h3>
        <div class="tiny" style="margin-top:6px">Time spent at k:</div>
        <div id="hist-k" class="tiny" style="margin-top:2px;min-height:24px"></div>
        <div class="tiny" style="margin-top:6px">Time spent at ℓ:</div>
        <div id="hist-l" class="tiny" style="margin-top:2px;min-height:24px"></div>
        <div class="tiny" style="margin-top:6px">Time spent at (k, ℓ) Heatmap:</div>
        <div id="hist-kl" class="tiny" style="margin-top:2px;min-height:32px"></div>
        
        <div class="tiny" style="margin-top:12px; font-weight:600; color:var(--muted)">Cycle Lengths (Global N=<span id="global-n">0</span>)</div>
        <div class="stats-grid" id="global-stats">
          <div class="stat-box"><div class="stat-label">Min</div><div class="stat-val" id="gs-min">—</div></div>
          <div class="stat-box"><div class="stat-label">25%</div><div class="stat-val" id="gs-25">—</div></div>
          <div class="stat-box"><div class="stat-label">Med</div><div class="stat-val" id="gs-50">—</div></div>
          <div class="stat-box"><div class="stat-label">75%</div><div class="stat-val" id="gs-75">—</div></div>
          <div class="stat-box"><div class="stat-label">Max</div><div class="stat-val" id="gs-max">—</div></div>
        </div>

        <div class="tiny" style="margin-top:8px">Cycle lengths (last 40):</div>
        <div id="hist-cycle-len" class="tiny" style="margin-top:2px"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* -------------------------------------------------------------------------- */
/* MODULE 1: SISYPHUS MATH                                                   */
/* -------------------------------------------------------------------------- */
class SisyphusMath {
  static computeProbs(k, l, p) {
    const clamp01 = x => Math.min(1, Math.max(0, x));
    const M = Math.max(1, p.M | 0);
    const L = Math.max(1, p.L | 0);
    const frac = M > 1 ? (k - 1) / (M - 1) : 1;
    const base = p.w_min + (p.w_max - p.w_min) * Math.pow(frac, p.beta);
    const ell = (1 - p.rho) + p.rho * Math.pow(l / L, p.gamma);
    
    let p_win = clamp01(base * ell);
    let p_loss = p.c_min + (p.c_max - p.c_min) * Math.exp(-p.alpha * l);
    
    if (p_win + p_loss > 1) {
      const s = p_win + p_loss;
      p_win /= s; p_loss /= s;
    }
    const p_neu = 1 - p_win - p_loss;
    return { p_win, p_neu, p_loss };
  }

  static solveExpectations(p) {
    const M = Math.max(1, p.M | 0);
    const L = Math.max(0, p.L | 0);
    
    const TopHit = Array.from({length: M + 1}, () => Array(L + 1).fill(0));
    const CycleLen = Array.from({length: M + 1}, () => Array(L + 1).fill(0));
    const WinCount = Array.from({length: M + 1}, () => Array(L + 1).fill(0));
    
    const maxIter = 400, tol = 1e-6;

    for (let it = 0; it < maxIter; it++) {
      let maxDiff = 0;
      for (let k = 1; k <= M; k++) {
        for (let l = 0; l <= L; l++) {
          const {p_win, p_neu} = SisyphusMath.computeProbs(k, l, p);
          
          const l_win = Math.max(0, l - p.s_w);
          const l_neu = Math.min(L, l + p.g_n);

          let valTop = 0;
          if (k === M) valTop = p_win * 1 + p_neu * TopHit[M][l_neu];
          else valTop = p_win * TopHit[k+1][l_win] + p_neu * TopHit[k][l_neu];
          
          let valCyc = 0;
          if (k === M) valCyc = 1 + p_neu * CycleLen[M][l_neu];
          else valCyc = 1 + p_win * CycleLen[k+1][l_win] + p_neu * CycleLen[k][l_neu];

          let valWin = 0;
          if (k === M) valWin = p_win * 1 + p_neu * WinCount[M][l_neu];
          else valWin = p_win * (1 + WinCount[k+1][l_win]) + p_neu * WinCount[k][l_neu];

          if(Math.abs(valTop - TopHit[k][l]) > maxDiff) maxDiff = Math.abs(valTop - TopHit[k][l]);
          TopHit[k][l] = valTop;
          CycleLen[k][l] = valCyc;
          WinCount[k][l] = valWin;
        }
      }
      if (maxDiff < tol) break;
    }
    return { TopHit, CycleLen, WinCount };
  }

  static getQuantiles(data) {
    if (!data || data.length === 0) return null;
    const sorted = [...data].sort((a, b) => a - b);
    const q = (p) => {
      const pos = (sorted.length - 1) * p;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base + 1] !== undefined) {
        return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
      } else {
        return sorted[base];
      }
    };
    return {
      min: sorted[0],
      q25: q(0.25),
      med: q(0.50),
      q75: q(0.75),
      max: sorted[sorted.length - 1]
    };
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 2: GAME MODEL                                                      */
/* -------------------------------------------------------------------------- */
class SisyphusModel {
  constructor() {
    this.params = {
      M:20, L:20, w_min:0.10, w_max:0.90, beta:1.5, rho:0.6, gamma:1.5,
      c_min:0.03, c_max:0.10, alpha:0.3, g_n:1, s_w:20
    };
    this.reset();
  }

  reset() {
    this.state = { k:1, l:0, step:0, topHit:false, cycleSteps:0 };
    this.stats = { wins:0, neus:0, loss:0, maxK:1, longestCycle:0 };
    this.historyK = [];
    this.cycleId = 1;
    this.currentCycle = this._newCycle();
    this.cycleSummaries = []; 
    this.allCycles = []; 

    const M = Math.max(1, this.params.M);
    const L = Math.max(0, this.params.L);
    this.distributions = { 
      k: Array(M+1).fill(0), 
      l: Array(L+1).fill(0), 
      kl: Array.from({length: M+1}, () => Array(L+1).fill(0)),
      cycles: []
    };
    
    this.lastRoll = null; 
  }

  _newCycle() {
    return { id: this.cycleId, length:0, wins:0, neus:0, maxK:this.state.k, path:'' };
  }

  step() {
    if (this.state.topHit) return null;

    const k0 = this.state.k, l0 = this.state.l;
    const probs = SisyphusMath.computeProbs(k0, l0, this.params);
    const r = Math.random();
    
    let outcome = 'loss';
    let k1 = 1, l1 = 0;

    if (r < probs.p_win) {
      if (k0 === this.params.M) {
        outcome = 'top';
        k1 = k0; l1 = l0;
        this.state.topHit = true;
      } else {
        outcome = 'win';
        k1 = Math.min(this.params.M, k0 + 1);
        l1 = Math.max(0, l0 - this.params.s_w);
      }
    } else if (r < probs.p_win + probs.p_neu) {
      outcome = 'neu';
      k1 = k0;
      l1 = Math.min(this.params.L, l0 + this.params.g_n);
    }

    this.state.k = k1; this.state.l = l1;
    this.state.step++;
    this.state.cycleSteps++;
    
    if (outcome !== 'top') this.stats[outcome+'s'] = (this.stats[outcome+'s'] || 0) + 1; 
    else this.stats.wins++; 

    if (outcome === 'win') this.stats.wins++;
    else if (outcome === 'neu') this.stats.neus++;
    else if (outcome === 'loss') this.stats.loss++;

    if (outcome === 'loss' || outcome === 'top') {
      if (this.state.cycleSteps > this.stats.longestCycle) this.stats.longestCycle = this.state.cycleSteps;
      if (outcome === 'loss') this.state.cycleSteps = 0;
    }

    this.stats.maxK = Math.max(this.stats.maxK, k1);
    this.historyK.push(k1);
    if (this.historyK.length > 200) this.historyK.shift();

    this._updateCycle(outcome, k1);
    this._updateDistributions(k1, l1);

    this.lastRoll = { outcome, k0, l0, k1, l1 };
    return outcome;
  }

  _updateDistributions(k, l) {
    const d = this.distributions;
    if (d.k[k] !== undefined) d.k[k]++;
    if (d.l[l] !== undefined) d.l[l]++;
    if (d.kl[k] && d.kl[k][l] !== undefined) d.kl[k][l]++;
  }

  _updateCycle(outcome, k1) {
    const sym = { win:'+', neu:'.', loss:'X', top:'★' }[outcome];
    if (sym) {
      this.currentCycle.length++;
      if (outcome === 'win') this.currentCycle.wins++;
      if (outcome === 'neu') this.currentCycle.neus++;
      this.currentCycle.maxK = Math.max(this.currentCycle.maxK, k1);
      this.currentCycle.path += sym;
    }

    if (outcome === 'loss' || outcome === 'top') {
      this.allCycles.push(this.currentCycle.length);
      
      this.distributions.cycles.push(this.currentCycle.length);
      if (this.distributions.cycles.length > 40) this.distributions.cycles.shift();

      const summary = { ...this.currentCycle, outcome };
      this.cycleSummaries.unshift(summary);
      if (this.cycleSummaries.length > 7) this.cycleSummaries.pop();

      this.cycleId++;
      this.currentCycle = this._newCycle();
    }
  }

  setState(k, l) {
    this.state.k = Math.max(1, Math.min(this.params.M, k));
    this.state.l = Math.max(0, Math.min(this.params.L, l));
    this.historyK.push(this.state.k);
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 3: UI MANAGER                                                      */
/* -------------------------------------------------------------------------- */
class SisyphusUI {
  constructor(model) {
    this.model = model;
    this.els = {};
    ['rbar-win','rbar-neu','rbar-loss','rpct-win','rpct-neu','rpct-loss',
     'kpos-fill','kpos-text','lpos-fill','lpos-text','recent-p-cond','recent-p-top',
     'recent-outcome','recent-kl','recent-card',
     'bar-win','bar-neu','bar-loss','c-win','c-neu','c-loss',
     'r-win','r-neu','r-loss','run-steps','longest-cycle','max-k',
     'spark','log','cycle-box','hist-k','hist-l','hist-kl','hist-cycle-len',
     'global-n','gs-min','gs-25','gs-50','gs-75','gs-max'
    ].forEach(id => this.els[id] = document.getElementById(id));
  }

  log(msg) {
    const div = document.createElement('div');
    div.textContent = msg;
    this.els.log.appendChild(div);
    this.els.log.scrollTop = this.els.log.scrollHeight;
  }

  render(grids, full = true) {
    const m = this.model;
    const s = m.state;
    const st = m.stats;
    const lr = m.lastRoll || { outcome:null, k0:1, l0:0, k1:s.k, l1:s.l };

    // 1. Recent Card
    const pct = x => (100 * Math.max(0, Math.min(1, x))).toFixed(1) + '%';
    const probs = SisyphusMath.computeProbs(lr.k1, lr.l1, m.params);
    
    this.els['recent-outcome'].textContent = lr.outcome ? 
      (lr.outcome === 'neu' ? 'NEUTRAL' : lr.outcome === 'top' ? 'TOP HIT' : lr.outcome.toUpperCase()) : '—';
    this.els['recent-kl'].textContent = `(${lr.k0},${lr.l0})→(${lr.k1},${lr.l1})`;
    this.els['recent-card'].className = 'card recent ' + (lr.outcome === 'top' ? 'win' : lr.outcome || '');

    this.els['rbar-win'].style.width = pct(probs.p_win);
    this.els['rbar-neu'].style.width = pct(probs.p_neu);
    this.els['rbar-loss'].style.width = pct(probs.p_loss);
    this.els['rpct-win'].textContent = pct(probs.p_win);
    this.els['rpct-neu'].textContent = pct(probs.p_neu);
    this.els['rpct-loss'].textContent = pct(probs.p_loss);

    const p_cond = (probs.p_win + probs.p_loss > 0) ? probs.p_win / (probs.p_win + probs.p_loss) : 0;
    this.els['recent-p-cond'].textContent = (probs.p_win+probs.p_loss < 1e-9) ? '—' : pct(p_cond);

    let pTopText = '—';
    if (grids && grids.TopHit && grids.TopHit[lr.k1] && typeof grids.TopHit[lr.k1][lr.l1] === 'number') {
      const p = grids.TopHit[lr.k1][lr.l1];
      const odds = Math.max(1, Math.round(1/Math.max(p, 1e-12)));
      pTopText = `1 in ${odds} (${(100*p).toFixed(2)}%)`;
    }
    this.els['recent-p-top'].textContent = pTopText;

    this.els['kpos-fill'].style.width = pct(lr.k1 / m.params.M);
    this.els['kpos-text'].textContent = `${lr.k1} / ${m.params.M}`;
    this.els['lpos-fill'].style.width = pct(lr.l1 / m.params.L);
    this.els['lpos-text'].textContent = `${lr.l1} / ${m.params.L}`;

    // 2. Stats
    const tot = st.wins + st.neus + st.loss;
    this.els['run-steps'].textContent = s.step;
    this.els['c-win'].textContent = st.wins;
    this.els['c-neu'].textContent = st.neus;
    this.els['c-loss'].textContent = st.loss;
    this.els['r-win'].textContent = tot ? (100*st.wins/tot).toFixed(1)+'%' : '0%';
    this.els['r-neu'].textContent = tot ? (100*st.neus/tot).toFixed(1)+'%' : '0%';
    this.els['r-loss'].textContent = tot ? (100*st.loss/tot).toFixed(1)+'%' : '0%';
    
    this.els['bar-win'].style.width = tot ? (100*st.wins/tot)+'%' : '0%';
    this.els['bar-neu'].style.width = tot ? (100*st.neus/tot)+'%' : '0%';
    this.els['bar-loss'].style.width = tot ? (100*st.loss/tot)+'%' : '0%';
    
    this.els['longest-cycle'].textContent = st.longestCycle;
    this.els['max-k'].textContent = st.maxK;

    this._drawSpark(m.historyK, m.params.M);
    this._renderCycles();

    if(full) {
      this._renderDistributions();
      this._renderGlobalStats();
    }
  }

  _drawSpark(data, M) {
    if (!data.length) return;
    const w = 300, h = 60;
    const y = k => h - 6 - (h - 12) * ((k - 1) / (M - 1 || 1));
    const stepX = data.length > 1 ? (w - 6) / (data.length - 1) : 0;
    let pts = '';
    for (let i = 0; i < data.length; i++) pts += `${3 + i * stepX},${y(data[i]).toFixed(1)} `;
    const stroke = '#ff9e2c';
    const overlay = `<rect x="0" y="0" width="${w}" height="${h}" fill="transparent" />`;
    this.els.spark.innerHTML = `<polyline fill="none" stroke="${stroke}" stroke-width="2" points="${pts.trim()}" />` + overlay;
  }

  _renderCycles() {
    const box = this.els['cycle-box'];
    box.innerHTML = '';
    const tpl = document.getElementById('tpl-cycle-entry');
    
    this.model.cycleSummaries.forEach(c => {
      const clone = tpl.content.cloneNode(true);
      const div = clone.querySelector('.cycle-entry');
      div.classList.add(c.outcome === 'top' ? 'top' : 'loss');
      
      const label = `C${c.id}: ${c.outcome === 'top' ? 'TOP' : 'LOSS'}`;
      clone.querySelector('.cycle-main-text').textContent = label;
      clone.querySelector('.cycle-meta').textContent = `L:${c.length} W:${c.wins}`;
      
      const chunk = 32;
      let wrapped = '';
      for(let i=0; i<(c.path||'').length; i+=chunk) {
        wrapped += c.path.slice(i, i+chunk) + '\n';
      }
      clone.querySelector('.cycle-entry-path').textContent = wrapped || '-';
      box.appendChild(clone);
    });
  }

  _renderGlobalStats() {
    const ac = this.model.allCycles;
    this.els['global-n'].textContent = ac.length;
    
    const stats = SisyphusMath.getQuantiles(ac);
    if (stats) {
      this.els['gs-min'].textContent = stats.min;
      this.els['gs-25'].textContent = stats.q25.toFixed(1).replace('.0','');
      this.els['gs-50'].textContent = stats.med.toFixed(1).replace('.0','');
      this.els['gs-75'].textContent = stats.q75.toFixed(1).replace('.0','');
      this.els['gs-max'].textContent = stats.max;
    } else {
      ['gs-min','gs-25','gs-50','gs-75','gs-max'].forEach(id => this.els[id].textContent = '—');
    }
  }

  _renderDistributions() {
    const dist = this.model.distributions;
    const renderBar = (hostId, data, M) => {
      const host = this.els[hostId];
      host.innerHTML = '';
      if(!data.length || !data.some(x=>x)) { host.textContent='—'; return; }
      const max = Math.max(...data.filter(n=>n));
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;align-items:flex-end;gap:2px';
      for(let i=(hostId==='hist-l'?0:1); i<data.length; i++){
        const v = data[i] || 0;
        const bar = document.createElement('div');
        bar.style.cssText = `width:3px;border-radius:2px;background:linear-gradient(180deg,var(--accent-3),var(--accent-2));`;
        bar.style.height = (6 + (max ? 24 * v / max : 0)) + 'px';
        wrap.appendChild(bar);
      }
      host.appendChild(wrap);
    };
    renderBar('hist-k', dist.k, this.model.params.M);
    renderBar('hist-l', dist.l, this.model.params.L);

    const clSamples = dist.cycles;
    const hostCl = this.els['hist-cycle-len'];
    hostCl.innerHTML = '';
    if(clSamples.length) {
      const maxCL = Math.max(...clSamples);
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;align-items:flex-end;gap:2px';
      clSamples.forEach(len => {
        const bar = document.createElement('div');
        bar.style.cssText = 'width:4px;border-radius:2px;background:linear-gradient(180deg,var(--accent-3),var(--accent-2));';
        bar.style.height = (8 + (maxCL ? 32 * len / maxCL : 0)) + 'px';
        wrap.appendChild(bar);
      });
      hostCl.appendChild(wrap);
    } else {
      hostCl.textContent = '—';
    }

    const hostHM = this.els['hist-kl'];
    hostHM.innerHTML = '';
    const klData = dist.kl;
    let maxC = 0;
    klData.forEach(row => row.forEach(c => { if(c > maxC) maxC = c; }));
    
    if(maxC > 0) {
      const M = this.model.params.M;
      const L = this.model.params.L;
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = `repeat(${M}, minmax(4px, 1fr))`;
      grid.style.gap = '1px';
      const logMax = Math.log(1+maxC);
      
      for(let l=L; l>=0; l--) {
        for(let k=1; k<=M; k++) {
          const c = (klData[k] && klData[k][l]) || 0;
          const cell = document.createElement('div');
          const alpha = c > 0 ? (0.15 + 0.85 * (Math.log(1+c)/logMax)) : 0.05;
          cell.style.background = `rgba(0,183,255,${alpha.toFixed(3)})`;
          cell.style.aspectRatio = '1/1';
          cell.title = `(${k},${l}): ${c}`;
          grid.appendChild(cell);
        }
      }
      hostHM.appendChild(grid);
    } else {
      hostHM.textContent = '—';
    }
  }

  updateExpectations(grids) {
    const { TopHit, CycleLen, WinCount } = grids;
    const pCycleTop = TopHit[1][0];
    const c = CycleLen[1][0];
    const w = WinCount[1][0];
    const fmt = x => (100*x).toFixed(3)+'%';
    const el = id => document.getElementById(id);
    
    if(c > 0) {
      el('exp-win-rate').textContent = fmt(w/c);
      el('exp-loss-rate').textContent = fmt((1-pCycleTop)/c);
      el('exp-cycle-len').textContent = c.toFixed(1);
      el('exp-time-top').textContent = pCycleTop > 1e-12 ? (c/pCycleTop).toFixed(1) : '∞';
    }
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 4: GAME CONTROLLER                                                 */
/* -------------------------------------------------------------------------- */
class GameController {
  constructor() {
    this.model = new SisyphusModel();
    this.ui = new SisyphusUI(this.model);
    this.timer = null;
    this.renderReq = null;
    this.isAuto = false;
    this.grids = null;
    
    this.bindEvents();
    this.load(); 
    this.recalcExpectations();
    this.ui.render(this.grids, true); 
  }

  bindEvents() {
    const $ = id => document.getElementById(id);
    $('roll1_big').onclick = () => this.stepManually();
    $('rollN').onclick = () => {
      const n = +$('nRolls').value || 20;
      for(let i=0; i<n; i++) this.model.step();
      this.ui.render(this.grids);
      this.save();
    };
    $('auto').onclick = () => this.toggleAuto();
    $('apply').onclick = () => this.applyParams();
    $('resetState').onclick = () => this.reset();
    $('setStateBtn').onclick = () => {
      const k = +$('set-k').value || 1;
      const l = +$('set-l').value || 0;
      this.model.setState(k, l);
      this.ui.render(this.grids);
    }
  }

  stepManually() {
    if(this.isAuto) this.toggleAuto();
    const res = this.model.step();
    if(res === 'top') alert("Top Hit Reached!");
    this.ui.render(this.grids);
    if(res && res !== 'top') this.ui.log(`step ${this.model.state.step}: ${this.model.lastRoll.outcome.toUpperCase()}`);
    this.save();
  }

  toggleAuto() {
    const btn = document.getElementById('auto');
    if (this.isAuto) {
      // STOPPING
      clearInterval(this.timer);
      cancelAnimationFrame(this.renderReq);
      this.isAuto = false;
      btn.textContent = 'Auto';
      this.ui.render(this.grids, true); // Force FULL render on stop
    } else {
      // STARTING
      this.isAuto = true;
      btn.textContent = 'Stop';
      const speed = +document.getElementById('speed').value || 100;
      
      this.timer = setInterval(() => {
        if(this.model.state.topHit) { this.toggleAuto(); return; }
        const batch = speed < 20 ? 10 : 1; 
        for(let i=0; i<batch; i++) {
           if(!this.model.state.topHit) this.model.step();
        }
      }, speed);

      let frameCount = 0;
      const loop = () => {
        if(!this.isAuto) return;
        frameCount++;
        const isFullRender = (frameCount % 60 === 0);
        this.ui.render(this.grids, isFullRender); 
        this.renderReq = requestAnimationFrame(loop);
      };
      loop();
    }
  }

  applyParams() {
    const p = this.model.params;
    ['M','L','w_min','w_max','beta','rho','gamma','c_min','c_max','alpha','g_n','s_w'].forEach(k => {
      const el = document.getElementById(k);
      if(el) p[k] = +el.value;
    });
    this.reset(); 
  }

  reset() {
    this.model.reset();
    this.recalcExpectations();
    this.ui.render(this.grids, true);
    this.ui.els.log.innerHTML = '';
    this.save();
  }

  recalcExpectations() {
    this.grids = SisyphusMath.solveExpectations(this.model.params);
    this.ui.updateExpectations(this.grids);
  }

  save() {
    const data = {
      params: this.model.params,
      state: this.model.state,
      stats: this.model.stats,
      historyK: this.model.historyK,
      cycleSummaries: this.model.cycleSummaries,
      distributions: this.model.distributions,
      allCycles: this.model.allCycles,
      lastRoll: this.model.lastRoll,
      cycleId: this.model.cycleId,
      currentCycle: this.model.currentCycle
    };
    localStorage.setItem('sisyphus_v7_persist', JSON.stringify(data));
  }

  load() {
    try {
      const raw = localStorage.getItem('sisyphus_v7_persist');
      if(raw) {
        const data = JSON.parse(raw);
        Object.assign(this.model.params, data.params);
        Object.assign(this.model.state, data.state);
        Object.assign(this.model.stats, data.stats);
        
        if(data.historyK) this.model.historyK = data.historyK;
        if(data.cycleSummaries) this.model.cycleSummaries = data.cycleSummaries;
        if(data.distributions) this.model.distributions = data.distributions;
        if(data.allCycles) this.model.allCycles = data.allCycles;
        if(data.lastRoll) this.model.lastRoll = data.lastRoll;
        if(data.cycleId) this.model.cycleId = data.cycleId;
        if(data.currentCycle) this.model.currentCycle = data.currentCycle;

        Object.keys(this.model.params).forEach(k => {
           const el = document.getElementById(k);
           if(el) el.value = this.model.params[k];
        });
      }
    } catch(e) {
      console.warn("Load failed", e);
    }
  }
}

document.addEventListener('DOMContentLoaded', () => {
  window.game = new GameController();
});

</script>
</body>
</html>
