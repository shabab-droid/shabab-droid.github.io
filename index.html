<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sisyphus' Ruin v2.11</title>
<style>
  :root{
    --bg:#080014; --text:#fef8ff; --muted:#cdaeff;
    --accent:#ff9e2c; --accent-2:#ff00b8; --accent-3:#00b7ff; --accent-4:#ff4efc;
  }
  body{
    margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    min-height: 100vh; background-color:#050010;
    /* Restored Background from v2.4 */
    background-image:
      radial-gradient(900px 700px at 50% -200px, rgba(255,0,200,.15), transparent 70%),
      radial-gradient(900px 700px at 50% 120%, rgba(0,200,255,.12), transparent 70%),
      linear-gradient(180deg,#0b0014 0%, #050010 100%);
    background-repeat:no-repeat; background-size:cover;
  }
  
  .app{max-width:1100px;margin:0 auto;padding:12px}
  h1{
    text-align:center; font-size:clamp(22px,3vw,30px); margin:14px 0 12px; letter-spacing:.5px;
    background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));
    -webkit-background-clip:text; background-clip:text; color:transparent;
  }
  .grid{display:grid;grid-template-columns:1fr 360px;gap:12px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .card{background:rgba(12, 0, 32, 0.6); backdrop-filter:blur(4px); padding:14px; border-radius:8px; border:1px solid rgba(255,255,255,0.05);}
  .btn{
    appearance:none; background:#1c0130; border:none; color:var(--text); border-radius:6px;
    padding:10px 14px; cursor:pointer; font-weight:600; letter-spacing:.3px;
    transition:background .15s ease,transform .1s ease; box-shadow:inset 0 0 0 1px rgba(255,255,255,.1);
  }
  .btn:hover{background:#2d0048}
  .btn:active{transform:scale(.97)}
  .btn:focus{outline:2px solid var(--accent);outline-offset:2px}
  
  /* Disabled State for Delay */
  .btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    background: #2a2a2a !important;
    color: #aaa !important;
    transform: none !important;
    box-shadow: none !important;
  }
  
  /* Checkbox Wrapper Styling */
  .checkbox-wrapper {
    display: flex; align-items: center; gap: 8px; 
    padding: 0 8px; 
    height: 38px; /* Match button height */
    width: auto; 
    cursor: pointer;
    user-select: none;
    opacity: 0.85;
    transition: opacity 0.2s;
  }
  .checkbox-wrapper:hover { opacity: 1; }
  .checkbox-wrapper input[type="checkbox"] {
    appearance: none;
    width: 16px; height: 16px;
    background: #140026;
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 3px;
    cursor: pointer;
    display: grid; place-content: center;
    margin: 0;
  }
  .checkbox-wrapper input[type="checkbox"]::before {
    content: ""; width: 8px; height: 8px;
    background: var(--accent);
    transform: scale(0);
    transition: 0.1s transform;
    border-radius: 1px;
  }
  .checkbox-wrapper input[type="checkbox"]:checked::before { transform: scale(1); }
  .checkbox-wrapper input[type="checkbox"]:checked { border-color: var(--accent); }
  .checkbox-wrapper label { cursor: pointer; color: var(--text); width: auto; font-size: 13px; font-weight: 500; }

  /* DOCKED ROLL BUTTON STYLES */
  .docked-control {
    position: sticky;
    top: 0;
    z-index: 1000;
    background: rgba(5, 0, 16, 0.85);
    backdrop-filter: blur(8px);
    margin: -12px -12px 12px -12px;
    padding: 12px;
    border-bottom: 1px solid rgba(255, 166, 0, 0.15);
    display: flex;
    justify-content: center;
  }

  .btn.big{
    display:block; width:100%; font-size:20px; padding:16px;
    margin-bottom:0; 
    background:#ff9e2c; color:#120026; font-weight:700;
    max-width: 600px;
  }
  .btn.big:hover{background:#ffb64d}
  
  label{width:120px;font-size:12px;color:var(--muted)}
  
  input[type="number"],select{
    background:#140026; color:var(--text); border:none; border-radius:4px;
    padding:6px 8px; 
    width: 54px;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.1);
  }
  select#speed { width: auto; }
  input#nRolls { width: 60px; }

  .desc{font-size:11px;opacity:.6;color:var(--muted);margin:-2px 0 8px; display:block; line-height:1.3;}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .bar{
    height:10px; background:rgba(255,255,255,.06); border-radius:8px;
    overflow:hidden; margin:3px 0; border:1px solid rgba(255,166,0,.12);
  }
  .bar>div{height:100%}
  .bar .win{background:linear-gradient(90deg,#ffd94d,var(--accent))}
  .bar .neu{background:linear-gradient(90deg,var(--accent-3),var(--accent-2))}
  .bar .loss{background:linear-gradient(90deg,var(--accent-4),#ff2400)}
  .kpos-track,.lpos-track{
    height:6px; background:rgba(255,255,255,.06); border:1px solid rgba(255,166,0,.12);
    border-radius:6px; overflow:hidden;
  }
  .kpos-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-4))}
  .lpos-fill{height:100%;background:linear-gradient(90deg,var(--accent-3),var(--accent-2))}
  #log{
    height:160px; overflow:auto; background:rgba(18,0,38,.35); border:1px solid rgba(255,166,0,.12);
    border-radius:10px; padding:8px; font-family:monospace; font-size:12px;
    white-space:pre-wrap; overflow-wrap:break-word; word-break:break-word;
  }
  .tiny{font-size:11px;opacity:.65;color:var(--muted)}
  .mono{font-family:monospace;}
  .small{font-size:12px;}

  .recent.win #recent-outcome{color:#ffd54a; text-shadow:0 0 6px rgba(255,213,74,.65),0 0 18px rgba(255,180,0,.4);}
  .recent.neu #recent-outcome{color:#a98dff}
  .recent.loss #recent-outcome{color:#ff4d4d; text-shadow:0 0 6px rgba(255,77,77,.65),0 0 18px rgba(255,40,40,.4);}
  
  .cycle-entry {
    font-family: monospace; font-size: 11px; border-radius: 4px; 
    border-left: 3px solid rgba(255,255,255,.12); padding: 4px 6px; 
    margin-bottom: 4px; background: rgba(12,0,32,0.6); 
    white-space: pre-wrap; word-break: break-word;
    display: flex; flex-direction: column; gap: 1px;
  }
  .cycle-entry.loss { border-color: rgba(255,90,90,.8); }
  .cycle-entry.top { border-color: rgba(255,210,90,.9); background: rgba(30,20,0,0.4); }
  .cycle-entry-top-row { display: flex; justify-content: space-between; align-items: baseline; font-weight: 600; opacity: 0.9; line-height: 1.2; }
  .cycle-id { color: var(--accent-3); margin-right: 6px; }
  .cycle-meta { font-weight: 400; opacity: 0.65; font-size: 10px; }
  .cycle-entry-path { opacity: 0.75; font-size: 10px; line-height: 1.1; letter-spacing: 1px; margin-top: 1px; }

  .stats-grid {
    display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-top: 6px;
    background: rgba(255,255,255,0.03); padding: 6px; border-radius: 6px;
  }
  .stat-box { display: flex; flex-direction: column; align-items: center; }
  .stat-label { font-size: 10px; opacity: 0.5; text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-val { font-family: monospace; font-size: 13px; font-weight: 600; color: var(--accent-3); }

  /* Accessibility improvements */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0,0,0,0);
    white-space: nowrap;
    border: 0;
  }

  /* Performance indicator */
  .perf-indicator {
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-family: monospace;
    opacity: 0.5;
    pointer-events: none;
  }

  /* Help modal */
  .help-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(20,0,38,0.95);
    border: 2px solid var(--accent);
    padding: 20px;
    border-radius: 10px;
    z-index: 2000;
    max-width: 400px;
  }
  .help-modal.show { display: block; }
  .help-modal h3 { margin-top: 0; color: var(--accent); }
  .help-modal kbd {
    background: rgba(255,255,255,0.1);
    padding: 2px 6px;
    border-radius: 3px;
    font-family: monospace;
    border: 1px solid rgba(255,255,255,0.2);
  }

  /* Weather Widget */
  .weather-status { font-weight: 800; letter-spacing: 0.5px; }
  .weather-good { color: var(--accent-3); text-shadow: 0 0 5px rgba(0,183,255,0.4); }
  .weather-bad { color: #ff3333; text-shadow: 0 0 5px rgba(255,51,51,0.4); }
  .weather-ok { color: var(--accent); }

  /* Weather Card & Canvas Integration */
  #weather-card {
    position: relative;
    overflow: hidden;
    min-height: 250px;
    /* CHANGED: Space-between to push header to top and content to bottom */
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }
  #weather-content {
    position: relative;
    z-index: 2; /* Sits above canvas */
  }
  #chaosCanvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 1;
    opacity: 0.4;
    pointer-events: none;
  }

</style>
</head>
<body>

<!-- Screen reader announcements -->
<div role="status" aria-live="polite" aria-atomic="true" class="sr-only" id="aria-announcer"></div>

<!-- Help Modal -->
<div class="help-modal" id="help-modal" role="dialog" aria-labelledby="help-title">
  <h3 id="help-title">Keyboard Shortcuts</h3>
  <dl>
    <dt><kbd>Space</kbd> or <kbd>Enter</kbd></dt>
    <dd>Roll once</dd>
    <dt><kbd>A</kbd></dt>
    <dd>Toggle auto-play</dd>
    <dt><kbd>R</kbd></dt>
    <dd>Reset game</dd>
    <dt><kbd>?</kbd></dt>
    <dd>Show/hide this help</dd>
    <dt><kbd>Esc</kbd></dt>
    <dd>Close this help</dd>
  </dl>
  <button class="btn" onclick="document.getElementById('help-modal').classList.remove('show')">Close</button>
</div>

<!-- Performance indicator -->
<div class="perf-indicator" id="perf-indicator"></div>

<template id="tpl-cycle-entry">
  <div class="cycle-entry">
    <div class="cycle-entry-top-row">
      <span class="cycle-main-text"></span>
      <span class="cycle-meta"></span>
    </div>
    <div class="cycle-entry-path"></div>
  </div>
</template>

<div class="app">
  <h1>Sisyphus' Ruin</h1>

  <div class="docked-control">
    <button class="btn big" id="roll1_big" 
            aria-label="Roll the dice once" 
            aria-keyshortcuts="Space Enter">Roll</button>
  </div>

  <div class="grid">
    <div>
      <div class="card recent" id="recent-card" role="region" aria-label="Recent roll result">
        <div style="display:flex;flex-direction:column;gap:2px">
          <div id="recent-outcome" style="font-weight:900;letter-spacing:1px;font-size:clamp(20px,3.2vw,32px)">No rolls yet</div>
          <div class="tiny mono">(k,ℓ): <span id="recent-kl">(1,0)→(1,0)</span></div>
        </div>
        <div class="recent-bars" style="margin-top:8px;display:grid;gap:6px">
          <div class="row recent-bar"><span style="width:46px">win</span><div class="bar" style="flex:1"><div id="rbar-win" class="win" style="width:0%"></div></div><span id="rpct-win" class="small mono">0.0%</span></div>
          <div class="row recent-bar"><span style="width:46px">neutral</span><div class="bar" style="flex:1"><div id="rbar-neu" class="neu" style="width:0%"></div></div><span id="rpct-neu" class="small mono">0.0%</span></div>
          <div class="row recent-bar"><span style="width:46px">loss</span><div class="bar" style="flex:1"><div id="rbar-loss" class="loss" style="width:0%"></div></div><span id="rpct-loss" class="small mono">0.0%</span></div>
          <div class="kpos"><div class="kpos-track"><div id="kpos-fill" class="kpos-fill" style="width:0%"></div></div><div class="small">k-position: <span id="kpos-text">1 / 20</span></div></div>
          <div class="lpos" style="margin-top:4px"><div class="lpos-track"><div id="lpos-fill" class="lpos-fill" style="width:0%"></div></div><div class="small">ℓ-position: <span id="lpos-text">0 / 20</span></div></div>
          <div class="row tiny" style="margin-top:2px">p(win | !neutral): <span id="recent-p-cond" class="mono">—</span></div>
          <div class="row tiny" style="margin-top:0">p(top hit | current state): <span id="recent-p-top" class="mono">—</span></div>
        </div>
      </div>

      <!-- WEATHER BOX WITH CANVAS INSIDE -->
      <div class="card" id="weather-card">
        <canvas id="chaosCanvas"></canvas>
        
        <!-- MOVED HEADER UP -->
        <h2 style="margin:0 0 8px; position: relative; z-index: 2;">Atmosphere</h2>
        
        <!-- KEPT CONTENT DOWN -->
        <div id="weather-content">
          <div style="display:flex; justify-content:space-between; align-items:center">
            <div>
              <div class="tiny" style="margin-bottom:2px">CONDITION</div>
              <div id="weather-status-main" style="font-size:18px; font-weight:800; letter-spacing:1px">CALIBRATING</div>
            </div>
            <div style="text-align:right">
              <div class="tiny" style="margin-bottom:2px">DELAY MODIFIER</div>
              <!-- REMOVED INLINE COLOR -->
              <div id="weather-mod-val" class="mono" style="font-size:18px;">1.0x</div>
            </div>
          </div>
          <div class="tiny" style="margin-top:8px; opacity:0.6">
            Chaos in the background influences the resistance.
          </div>
        </div>
      </div>

      <div class="card"><h2 style="margin:0 0 8px">Run Stats</h2>
        <div class="small" style="margin-bottom:6px">steps: <span class="mono" id="run-steps">0</span></div>
        <div class="bar" role="progressbar" aria-label="Win percentage"><div class="win" id="bar-win" style="width:0%"></div></div>
        <div class="bar" role="progressbar" aria-label="Neutral percentage"><div class="neu" id="bar-neu" style="width:0%"></div></div>
        <div class="bar" role="progressbar" aria-label="Loss percentage"><div class="loss" id="bar-loss" style="width:0%"></div></div>
        <div class="row" style="justify-content:space-between">
          <div>win: <span class="mono" id="c-win">0</span> (<span class="mono" id="r-win">0.0%</span>)</div>
          <div>neutral: <span class="mono" id="c-neu">0</span> (<span class="mono" id="r-neu">0.0%</span>)</div>
          <div>loss: <span class="mono" id="c-loss">0</span> (<span class="mono" id="r-loss">0.0%</span>)</div>
        </div>
        <div class="row tiny" style="margin-top:6px;justify-content:space-between">
          <div>run time: <span class="mono" id="run-time">0s</span></div>
          <div>max k: <span class="mono" id="max-k">1</span></div>
        </div>
      </div>

      <div class="card"><div id="log" role="log" aria-label="Game log"></div></div>

      <div class="card"><h2 style="margin:0 0 8px">Cycle Summaries</h2><div id="cycle-box" class="tiny"></div></div>
    </div>

    <div>
      <div class="card"><h2 style="margin:0 0 8px">Play Controls</h2>
        
        <div class="row" style="align-items: center; gap: 6px;">
          <button class="btn" id="auto" aria-keyshortcuts="A" style="flex:1">Auto Play</button>
          
          <label class="checkbox-wrapper" for="use-delay">
            <input type="checkbox" id="use-delay">
            <span>Delay</span>
          </label>

          <select id="speed" aria-label="Auto-play speed">
            <option value="1000">Slow</option>
            <option value="100" selected>Normal</option>
            <option value="10">Fast (Turbo)</option>
          </select>
        </div>

        <div class="row" style="margin-top:8px">
          <input id="nRolls" type="number" value="20" aria-label="Number of rolls or cycles" style="width:60px">
          <button class="btn" id="rollN" style="flex:1">Roll N Steps</button>
          <button class="btn" id="rollNCycles" style="flex:1">Roll N Cycles</button>
        </div>
        <div class="row" style="margin-top:8px">
          <span class="tiny" style="min-width:110px">Set state (k, ℓ):</span>
          <input id="set-k" type="number" min="1" value="1" aria-label="Set k value">
          <input id="set-l" type="number" min="0" value="0" aria-label="Set l value">
          <button class="btn" id="setStateBtn">Set</button>
        </div>
      </div>

      <div class="card"><h2 style="margin:0 0 8px">System</h2>
        <div class="tiny" style="line-height:1.45">
          This process tracks a state <strong>(k, ℓ)</strong> where k is progress up a ladder (1 → M) and ℓ is momentum (0 → L).<br>
          On each roll you get a <strong>win</strong> (k increases, ℓ drops), <strong>neutral</strong> (k stays, ℓ rises), or <strong>loss</strong> (reset to k=1, ℓ=0).<br>
          At k = M, a win becomes a <strong>Top Hit</strong>.
        </div>
      </div>

      <div class="card" id="params-container">
        <h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Parameters</h3>
        <div class="row"><label for="M">M (k levels)</label><input id="M" type="number" value="20"></div>
        <div class="desc">How many rungs in the ladder.</div>
        <div class="row"><label for="L">L (ℓ max)</label><input id="L" type="number" value="20"></div>
        <div class="desc">Momentum scale; ℓ ∈ [0, L].</div>
        <div class="row"><label>w_min → w_max</label><input id="w_min" type="number" step="0.01" value="0.10" aria-label="Minimum win probability"><input id="w_max" type="number" step="0.01" value="0.90" aria-label="Maximum win probability"></div>
        <div class="desc">Win rises from w_min at k=1 to w_max at k=M.</div>
        <div class="row"><label for="beta">β (k ramp)</label><input id="beta" type="number" step="0.1" value="1.5"></div>
        <div class="desc">β > 1 makes late k much easier.</div>
        <div class="row"><label>ρ, γ (ℓ boost)</label><input id="rho" type="number" step="0.05" value="0.6" aria-label="Rho parameter"><input id="gamma" type="number" step="0.1" value="1.5" aria-label="Gamma parameter"></div>
        <div class="desc">Higher ℓ → more win probability.</div>
        <div class="row"><label>c_min → c_max</label><input id="c_min" type="number" step="0.01" value="0.03" aria-label="Minimum catastrophe probability"><input id="c_max" type="number" step="0.01" value="0.10" aria-label="Maximum catastrophe probability"></div>
        <div class="desc">Loss floor/ceiling.</div>
        <div class="row"><label for="alpha">α (loss decay)</label><input id="alpha" type="number" step="0.1" value="0.3"></div>
        <div class="desc">Higher ℓ reduces loss via exp decay.</div>
        <div class="row"><label>g_n, s_w</label><input id="g_n" type="number" value="1" aria-label="Momentum gain"><input id="s_w" type="number" value="20" aria-label="Momentum spend"></div>
        <div class="desc">Momentum gain (neutral) vs spend (win).</div>
        
        <!-- MAX DELAY PARAM -->
        <div class="row"><label for="max_delay">Max Delay (s)</label><input id="max_delay" type="number" step="0.1" value="2.0"></div>
        <div class="desc">Cooldown time. Reduces as k and ℓ increase.</div>

        <div class="row"><button class="btn" id="apply">Apply & Reset</button><button class="btn" id="resetState" aria-keyshortcuts="R">Reset State</button></div>
      </div>

      <div class="card"><h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Expectations</h3>
        <div class="row tiny" style="flex-direction:column;align-items:flex-start;gap:2px">
          <div>win rate (per roll): <span class="mono" id="exp-win-rate">—</span></div>
          <div>loss rate (per roll): <span class="mono" id="exp-loss-rate">—</span></div>
          <div>average cycle length: <span class="mono" id="exp-cycle-len">—</span> rolls</div>
          <div>E[first top hit]: <span class="mono" id="exp-time-top">—</span> rolls</div>
          <div>Optimal Wins/Hour: <span class="mono" id="exp-wins-hour">—</span></div>
        </div>
      </div>

      <div class="card"><h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Distributions</h3>
        <div class="tiny" style="margin-top:6px">Time spent at k:</div>
        <div id="hist-k" class="tiny" style="margin-top:2px;min-height:24px"></div>
        <div class="tiny" style="margin-top:6px">Time spent at ℓ:</div>
        <div id="hist-l" class="tiny" style="margin-top:2px;min-height:24px"></div>
        <div class="tiny" style="margin-top:6px">Time spent at (k, ℓ) Heatmap:</div>
        <div id="hist-kl" class="tiny" style="margin-top:2px;min-height:32px"></div>
        
        <div class="tiny" style="margin-top:12px; font-weight:600; color:var(--muted)">Cycle Lengths (Global N=<span id="global-n">0</span>)</div>
        <div class="stats-grid" id="global-stats">
          <div class="stat-box"><div class="stat-label">Min</div><div class="stat-val" id="gs-min">—</div></div>
          <div class="stat-box"><div class="stat-label">25%</div><div class="stat-val" id="gs-25">—</div></div>
          <div class="stat-box"><div class="stat-label">Med</div><div class="stat-val" id="gs-50">—</div></div>
          <div class="stat-box"><div class="stat-label">75%</div><div class="stat-val" id="gs-75">—</div></div>
          <div class="stat-box"><div class="stat-label">Max</div><div class="stat-val" id="gs-max">—</div></div>
        </div>

        <div class="tiny" style="margin-top:8px">Cycle lengths (last 40):</div>
        <div id="hist-cycle-len" class="tiny" style="margin-top:2px"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* -------------------------------------------------------------------------- */
/* MODULE 0: UTILITIES & HELPERS                                             */
/* -------------------------------------------------------------------------- */

// Background Timer Worker to bypass browser throttling
class BackgroundTimer {
  constructor() {
    const blob = new Blob([`
      const timers = new Map();
      self.onmessage = function(e) {
        const { id, type, delay } = e.data;
        if (type === 'clear') {
          const t = timers.get(id);
          if (t) {
            clearTimeout(t);
            clearInterval(t);
            timers.delete(id);
          }
        } else if (type === 'setTimeout') {
          const t = setTimeout(() => {
            self.postMessage({ id, type: 'timeout' });
            timers.delete(id);
          }, delay);
          timers.set(id, t);
        } else if (type === 'setInterval') {
          const t = setInterval(() => {
            self.postMessage({ id, type: 'interval' });
          }, delay);
          timers.set(id, t);
        }
      };
    `], { type: 'application/javascript' });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.callbacks = new Map();
    this.nextId = 1;
    
    this.worker.onmessage = (e) => {
      const { id } = e.data;
      const cb = this.callbacks.get(id);
      if (cb) cb();
    };
  }

  setTimeout(callback, delay) {
    const id = this.nextId++;
    this.callbacks.set(id, callback);
    this.worker.postMessage({ id, type: 'setTimeout', delay });
    return id;
  }

  setInterval(callback, delay) {
    const id = this.nextId++;
    this.callbacks.set(id, callback);
    this.worker.postMessage({ id, type: 'setInterval', delay });
    return id;
  }

  clear(id) {
    if (!id) return;
    this.worker.postMessage({ id, type: 'clear' });
    this.callbacks.delete(id);
  }
}

// Probability Cache for memoization
class ProbabilityCache {
  constructor(maxSize = 400) {
    this.cache = new Map();
    this.maxSize = maxSize;
    this.hits = 0;
    this.misses = 0;
  }
  
  makeKey(k, l, params) {
    return `${k},${l},${params.w_min},${params.w_max},${params.beta},${params.rho},${params.gamma},${params.c_min},${params.c_max},${params.alpha},${params.M},${params.L}`;
  }
  
  get(k, l, params) {
    const key = this.makeKey(k, l, params);
    const result = this.cache.get(key);
    if (result) {
      this.hits++;
      return result;
    }
    this.misses++;
    return null;
  }
  
  set(k, l, params, probs) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    const key = this.makeKey(k, l, params);
    this.cache.set(key, probs);
    return probs;
  }
  
  clear() {
    this.cache.clear();
    this.hits = 0;
    this.misses = 0;
  }
  
  getStats() {
    return {
      size: this.cache.size,
      hits: this.hits,
      misses: this.misses,
      hitRate: this.hits / (this.hits + this.misses) || 0
    };
  }
}

// Aria Announcer for screen readers
class AriaAnnouncer {
  constructor() {
    this.element = document.getElementById('aria-announcer');
  }
  
  announce(message) {
    this.element.textContent = message;
    setTimeout(() => {
      this.element.textContent = '';
    }, 1000);
  }
}

// Performance Monitor
class PerformanceMonitor {
  constructor() {
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.fps = 0;
    this.element = document.getElementById('perf-indicator');
  }
  
  tick() {
    this.frameCount++;
    const now = performance.now();
    const delta = now - this.lastTime;
    
    if (delta >= 1000) {
      this.fps = Math.round(this.frameCount * 1000 / delta);
      this.frameCount = 0;
      this.lastTime = now;
      this.update();
    }
  }
  
  update() {
    const cacheStats = SisyphusMath.probCache.getStats();
    this.element.textContent = `FPS: ${this.fps} | Cache: ${(cacheStats.hitRate * 100).toFixed(0)}%`;
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 1: SISYPHUS MATH                                                   */
/* -------------------------------------------------------------------------- */
class SisyphusMath {
  static EPSILON = 1e-10;
  static probCache = new ProbabilityCache();
  
  static computeProbs(k, l, p) {
    // Check cache first
    const cached = this.probCache.get(k, l, p);
    if (cached) return cached;
    
    // Ensure integer bounds
    k = Math.round(k);
    l = Math.round(l);
    
    const clamp01 = x => Math.min(1, Math.max(0, x));
    const M = Math.max(1, p.M | 0);
    const L = Math.max(1, p.L | 0);
    
    const frac = M > 1 ? (k - 1) / (M - 1) : 1;
    const base = p.w_min + (p.w_max - p.w_min) * Math.pow(frac, p.beta);
    const ell = (1 - p.rho) + p.rho * Math.pow(l / L, p.gamma);
    
    let p_win = clamp01(base * ell);
    let p_loss = p.c_min + (p.c_max - p.c_min) * Math.exp(-p.alpha * l);
    
    // Handle normalization with epsilon
    const sum = p_win + p_loss;
    if (sum > 1 + this.EPSILON) {
      p_win /= sum;
      p_loss /= sum;
    } else if (sum > 1) {
      const scale = 1 / sum;
      p_win *= scale;
      p_loss *= scale;
    }
    
    // Ensure p_neu is non-negative
    let p_neu = Math.max(0, 1 - p_win - p_loss);
    
    // Final normalization
    const total = p_win + p_neu + p_loss;
    if (Math.abs(total - 1) > this.EPSILON) {
      p_win /= total;
      p_neu /= total;
      p_loss /= total;
    }
    
    const result = { 
      p_win: clamp01(p_win), 
      p_neu: clamp01(p_neu), 
      p_loss: clamp01(p_loss) 
    };
    
    // Cache the result
    this.probCache.set(k, l, p, result);
    
    return result;
  }

  static getDelay(k, l, p) {
    // If param is 0, disabled
    if (p.max_delay <= 0) return 0;

    const kRatio = Math.max(0, (k - 1) / (p.M - 1 || 1));
    const lRatio = Math.max(0, l / (p.L || 1));
    
    // Weighted progress (k is dominant)
    const reduction = (0.8 * kRatio) + (0.2 * lRatio);
    
    // Cubic decay: (1 - progress)^3
    // This makes the delay drop very quickly as you start making progress
    const ms = (p.max_delay * 1000) * Math.pow(1 - Math.min(1, reduction), 3);
    
    // If calculated delay is very small, return 0 to skip lock
    if (ms < 20) return 0;
    
    // Otherwise enforce a minimum that makes the UI readable
    return Math.max(100, ms); 
  }
  
  static clearCache() {
    this.probCache.clear();
  }

  static solveExpectations(p) {
    const M = Math.max(1, p.M | 0);
    const L = Math.max(0, p.L | 0);
    
    const TopHit = Array.from({length: M + 1}, () => Array(L + 1).fill(0));
    const CycleLen = Array.from({length: M + 1}, () => Array(L + 1).fill(0));
    const WinCount = Array.from({length: M + 1}, () => Array(L + 1).fill(0));
    const TimeLen = Array.from({length: M + 1}, () => Array(L + 1).fill(0)); // NEW
    
    const maxIter = 400, tol = 1e-6;
    const lossDelay = SisyphusMath.getDelay(1, 0, p) / 1000;

    for (let it = 0; it < maxIter; it++) {
      let maxDiff = 0;
      for (let k = 1; k <= M; k++) {
        for (let l = 0; l <= L; l++) {
          const {p_win, p_neu, p_loss} = SisyphusMath.computeProbs(k, l, p);
          
          const l_win = Math.max(0, l - p.s_w);
          const l_neu = Math.min(L, l + p.g_n);

          let valTop = 0;
          if (k === M) valTop = p_win * 1 + p_neu * TopHit[M][l_neu];
          else valTop = p_win * TopHit[k+1][l_win] + p_neu * TopHit[k][l_neu];
          
          let valCyc = 0;
          if (k === M) valCyc = 1 + p_neu * CycleLen[M][l_neu];
          else valCyc = 1 + p_win * CycleLen[k+1][l_win] + p_neu * CycleLen[k][l_neu];

          let valWin = 0;
          if (k === M) valWin = p_win * 1 + p_neu * WinCount[M][l_neu];
          else valWin = p_win * (1 + WinCount[k+1][l_win]) + p_neu * WinCount[k][l_neu];
          
          // --- Time Expectation Logic ---
          // Cost of this step (accumulated delay)
          // If result is Top Hit, delay is 0.
          // If result is Win(k<M), next state is (k+1, l_win), delay is D(k+1, l_win)
          // If result is Neu, next state is (k, l_neu), delay is D(k, l_neu)
          // If result is Loss, next state is (1, 0), delay is D(1, 0)
          
          const delayWin = (k === M) ? 0 : (SisyphusMath.getDelay(k+1, l_win, p) / 1000);
          const delayNeu = SisyphusMath.getDelay(k, l_neu, p) / 1000;
          // lossDelay is constant D(1,0)
          
          const stepCost = (p_win * delayWin) + (p_neu * delayNeu) + (p_loss * lossDelay);
          
          let valTime = 0;
          if (k === M) {
             // If Top, cycle ends (0 future time). If Neu, continue.
             valTime = stepCost + p_neu * TimeLen[M][l_neu];
          } else {
             // Recurse
             valTime = stepCost + p_win * TimeLen[k+1][l_win] + p_neu * TimeLen[k][l_neu];
          }

          if(Math.abs(valTop - TopHit[k][l]) > maxDiff) maxDiff = Math.abs(valTop - TopHit[k][l]);
          TopHit[k][l] = valTop;
          CycleLen[k][l] = valCyc;
          WinCount[k][l] = valWin;
          TimeLen[k][l] = valTime;
        }
      }
      if (maxDiff < tol) break;
    }
    return { TopHit, CycleLen, WinCount, TimeLen };
  }

  static getQuantiles(data) {
    if (!data || data.length === 0) return null;
    const sorted = [...data].sort((a, b) => a - b);
    const q = (p) => {
      const pos = (sorted.length - 1) * p;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base + 1] !== undefined) {
        return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
      } else {
        return sorted[base];
      }
    };
    return {
      min: sorted[0],
      q25: q(0.25),
      med: q(0.50),
      q75: q(0.75),
      max: sorted[sorted.length - 1]
    };
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 2: GAME MODEL                                                      */
/* -------------------------------------------------------------------------- */
class SisyphusModel {
  constructor() {
    this.params = {
      M:20, L:20, w_min:0.10, w_max:0.90, beta:1.5, rho:0.6, gamma:1.5,
      c_min:0.03, c_max:0.10, alpha:0.3, g_n:1, s_w:20,
      max_delay: 2.0 // Added Max Delay Parameter
    };
    this.reset();
  }

  reset() {
    this.state = { k:1, l:0, step:0, topHit:false, cycleSteps:0 };
    this.stats = { wins:0, neus:0, loss:0, maxK:1, longestCycle:0 };
    this.historyK = [];
    this.cycleId = 1;
    this.currentCycle = this._newCycle();
    this.cycleSummaries = []; 
    this.allCycles = []; 
    this.startTime = Date.now(); // NEW: Track when this run started

    const M = Math.max(1, this.params.M);
    const L = Math.max(0, this.params.L);
    this.distributions = { 
      k: Array(M+1).fill(0), 
      l: Array(L+1).fill(0), 
      kl: Array.from({length: M+1}, () => Array(L+1).fill(0)),
      cycles: []
    };
    
    this.lastRoll = null; 
  }

  _newCycle() {
    return { id: this.cycleId, length:0, wins:0, neus:0, maxK:this.state.k, path:'' };
  }

  step() {
    if (this.state.topHit) return null;

    const k0 = this.state.k, l0 = this.state.l;
    const probs = SisyphusMath.computeProbs(k0, l0, this.params);
    const r = Math.random();
    
    let outcome = 'loss';
    let k1 = 1, l1 = 0;

    if (r < probs.p_win) {
      if (k0 === this.params.M) {
        outcome = 'top';
        k1 = k0; l1 = l0;
        this.state.topHit = true;
      } else {
        outcome = 'win';
        k1 = Math.min(this.params.M, k0 + 1);
        l1 = Math.max(0, l0 - this.params.s_w);
      }
    } else if (r < probs.p_win + probs.p_neu) {
      outcome = 'neu';
      k1 = k0;
      l1 = Math.min(this.params.L, l0 + this.params.g_n);
    }

    this.state.k = k1; 
    this.state.l = l1;
    this.state.step++;
    this.state.cycleSteps++;
    
    // Update stats
    if (outcome === 'win' || outcome === 'top') this.stats.wins++;
    else if (outcome === 'neu') this.stats.neus++;
    else if (outcome === 'loss') this.stats.loss++;

    if (outcome === 'loss' || outcome === 'top') {
      if (this.state.cycleSteps > this.stats.longestCycle) {
        this.stats.longestCycle = this.state.cycleSteps;
      }
      if (outcome === 'loss') this.state.cycleSteps = 0;
    }

    this.stats.maxK = Math.max(this.stats.maxK, k1);
    this.historyK.push(k1);
    if (this.historyK.length > 200) this.historyK.shift();

    this._updateCycle(outcome, k1);
    this._updateDistributions(k1, l1);

    this.lastRoll = { outcome, k0, l0, k1, l1 };
    return outcome;
  }

  _updateDistributions(k, l) {
    const d = this.distributions;
    if (d.k[k] !== undefined) d.k[k]++;
    if (d.l[l] !== undefined) d.l[l]++;
    if (d.kl[k] && d.kl[k][l] !== undefined) d.kl[k][l]++;
  }

  _updateCycle(outcome, k1) {
    const sym = { win:'+', neu:'.', loss:'X', top:'★' }[outcome];
    if (sym) {
      this.currentCycle.length++;
      if (outcome === 'win') this.currentCycle.wins++;
      if (outcome === 'neu') this.currentCycle.neus++;
      this.currentCycle.maxK = Math.max(this.currentCycle.maxK, k1);
      this.currentCycle.path += sym;
    }

    if (outcome === 'loss' || outcome === 'top') {
      this.allCycles.push(this.currentCycle.length);
      
      this.distributions.cycles.push(this.currentCycle.length);
      if (this.distributions.cycles.length > 40) this.distributions.cycles.shift();

      const summary = { ...this.currentCycle, outcome };
      this.cycleSummaries.unshift(summary);
      if (this.cycleSummaries.length > 7) this.cycleSummaries.pop();

      this.cycleId++;
      this.currentCycle = this._newCycle();
    }
  }

  setState(k, l) {
    this.state.k = Math.max(1, Math.min(this.params.M, k));
    this.state.l = Math.max(0, Math.min(this.params.L, l));
    this.historyK.push(this.state.k);
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 3: UI MANAGER                                                      */
/* -------------------------------------------------------------------------- */
class SisyphusUI {
  constructor(model) {
    this.model = model;
    this.els = {};
    this.pendingUpdates = new Map();
    this.rafId = null;
    
    ['rbar-win','rbar-neu','rbar-loss','rpct-win','rpct-neu','rpct-loss',
     'kpos-fill','kpos-text','lpos-fill','lpos-text','recent-p-cond','recent-p-top',
     'recent-outcome','recent-kl','recent-card',
     'bar-win','bar-neu','bar-loss','c-win','c-neu','c-loss',
     'r-win','r-neu','r-loss','run-steps','run-time','max-k',
     'log','cycle-box','hist-k','hist-l','hist-kl','hist-cycle-len',
     'global-n','gs-min','gs-25','gs-50','gs-75','gs-max',
     'exp-win-rate', 'exp-loss-rate', 'exp-cycle-len', 'exp-time-top', 'exp-wins-hour'
    ].forEach(id => this.els[id] = document.getElementById(id));
  }
  
  // Batch update methods
  batchUpdate(elementId, property, value) {
    if (!this.pendingUpdates.has(elementId)) {
      this.pendingUpdates.set(elementId, {});
    }
    this.pendingUpdates.get(elementId)[property] = value;
    
    if (!this.rafId) {
      this.rafId = requestAnimationFrame(() => {
        this.flushUpdates();
      });
    }
  }
  
  flushUpdates() {
    this.pendingUpdates.forEach((updates, elementId) => {
      const el = this.els[elementId];
      if (!el) return;
      
      Object.entries(updates).forEach(([prop, value]) => {
        if (prop === 'textContent') {
          el.textContent = value;
        } else if (prop === 'className') {
          el.className = value;
        } else if (prop.startsWith('style.')) {
          const styleProp = prop.substring(6);
          el.style[styleProp] = value;
        }
      });
    });
    
    this.pendingUpdates.clear();
    this.rafId = null;
  }

  log(msg) {
    const div = document.createElement('div');
    div.textContent = msg;
    this.els.log.appendChild(div);
    this.els.log.scrollTop = this.els.log.scrollHeight;
  }

  // Helper to format elapsed time compactly
  _formatDuration(ms) {
    const s = Math.floor(ms / 1000);
    if(s < 60) return `${s}s`;
    const m = Math.floor(s / 60);
    if(m < 60) return `${m}m ${s%60}s`;
    const h = Math.floor(m / 60);
    if(h < 24) return `${h}h ${m%60}m`;
    const d = Math.floor(h / 24);
    return `${d}d ${h%24}h`;
  }

  render(grids, full = true) {
    const m = this.model;
    const s = m.state;
    const st = m.stats;
    const lr = m.lastRoll || { outcome:null, k0:1, l0:0, k1:s.k, l1:s.l };

    const pct = x => (100 * Math.max(0, Math.min(1, x))).toFixed(1) + '%';
    const probs = SisyphusMath.computeProbs(lr.k1, lr.l1, m.params);
    
    // Use batch updates for better performance
    this.batchUpdate('recent-outcome', 'textContent', 
      lr.outcome ? (lr.outcome === 'neu' ? 'NEUTRAL' : lr.outcome === 'top' ? 'TOP HIT' : lr.outcome.toUpperCase()) : '—');
    this.batchUpdate('recent-kl', 'textContent', `(${lr.k0},${lr.l0})→(${lr.k1},${lr.l1})`);
    this.batchUpdate('recent-card', 'className', 'card recent ' + (lr.outcome === 'top' ? 'win' : lr.outcome || ''));

    this.batchUpdate('rbar-win', 'style.width', pct(probs.p_win));
    this.batchUpdate('rbar-neu', 'style.width', pct(probs.p_neu));
    this.batchUpdate('rbar-loss', 'style.width', pct(probs.p_loss));
    this.batchUpdate('rpct-win', 'textContent', pct(probs.p_win));
    this.batchUpdate('rpct-neu', 'textContent', pct(probs.p_neu));
    this.batchUpdate('rpct-loss', 'textContent', pct(probs.p_loss));

    const p_cond = (probs.p_win + probs.p_loss > 0) ? probs.p_win / (probs.p_win + probs.p_loss) : 0;
    this.batchUpdate('recent-p-cond', 'textContent', (probs.p_win+probs.p_loss < 1e-9) ? '—' : pct(p_cond));

    // p(top hit | current state) Display Logic
    let pTopText = '—';
    if (grids && grids.TopHit && grids.TopHit[lr.k1] && typeof grids.TopHit[lr.k1][lr.l1] === 'number') {
      const p = grids.TopHit[lr.k1][lr.l1];
      const odds = p > 0 ? 1/p : Infinity;
      
      if (p < 0.0001) { // < 0.01%
        const oddsStr = odds > 1e6 ? odds.toExponential(2) : Math.round(odds).toLocaleString();
        pTopText = `1 in ${oddsStr}`;
      } else if (p <= 0.5) { // 0.01% to 50%
        const oddsStr = Math.round(odds).toLocaleString();
        pTopText = `1 in ${oddsStr} (${(p*100).toFixed(2)}%)`;
      } else { // > 50%
        pTopText = `${(p*100).toFixed(1)}%`;
      }
    }
    this.batchUpdate('recent-p-top', 'textContent', pTopText);

    this.batchUpdate('kpos-fill', 'style.width', pct(lr.k1 / m.params.M));
    this.batchUpdate('kpos-text', 'textContent', `${lr.k1} / ${m.params.M}`);
    this.batchUpdate('lpos-fill', 'style.width', pct(lr.l1 / m.params.L));
    this.batchUpdate('lpos-text', 'textContent', `${lr.l1} / ${m.params.L}`);

    // Stats
    const tot = st.wins + st.neus + st.loss;
    this.batchUpdate('run-steps', 'textContent', s.step);
    this.batchUpdate('c-win', 'textContent', st.wins);
    this.batchUpdate('c-neu', 'textContent', st.neus);
    this.batchUpdate('c-loss', 'textContent', st.loss);
    this.batchUpdate('r-win', 'textContent', tot ? (100*st.wins/tot).toFixed(1)+'%' : '0%');
    this.batchUpdate('r-neu', 'textContent', tot ? (100*st.neus/tot).toFixed(1)+'%' : '0%');
    this.batchUpdate('r-loss', 'textContent', tot ? (100*st.loss/tot).toFixed(1)+'%' : '0%');
    
    this.batchUpdate('bar-win', 'style.width', tot ? (100*st.wins/tot)+'%' : '0%');
    this.batchUpdate('bar-neu', 'style.width', tot ? (100*st.neus/tot)+'%' : '0%');
    this.batchUpdate('bar-loss', 'style.width', tot ? (100*st.loss/tot)+'%' : '0%');
    
    // UPDATE TIME IN RUN
    const elapsed = Math.max(0, Date.now() - m.startTime);
    this.batchUpdate('run-time', 'textContent', this._formatDuration(elapsed));
    this.batchUpdate('max-k', 'textContent', st.maxK);
    
    // REMOVED SPARKLINE DRAW CALL
    this._renderCycles();

    if(full) {
      this._renderDistributions();
      this._renderGlobalStats();
    }
  }

  _renderCycles() {
    const box = this.els['cycle-box'];
    const tpl = document.getElementById('tpl-cycle-entry');
    const fragment = document.createDocumentFragment();
    
    this.model.cycleSummaries.forEach(c => {
      const clone = tpl.content.cloneNode(true);
      const div = clone.querySelector('.cycle-entry');
      div.classList.add(c.outcome === 'top' ? 'top' : 'loss');
      
      const label = `C${c.id}: ${c.outcome === 'top' ? 'TOP' : 'LOSS'}`;
      clone.querySelector('.cycle-main-text').textContent = label;
      clone.querySelector('.cycle-meta').textContent = `L:${c.length} W:${c.wins}`;
      
      const chunk = 32;
      let wrapped = '';
      for(let i=0; i<(c.path||'').length; i+=chunk) {
        wrapped += c.path.slice(i, i+chunk) + '\n';
      }
      clone.querySelector('.cycle-entry-path').textContent = wrapped || '-';
      fragment.appendChild(clone);
    });
    
    box.innerHTML = '';
    box.appendChild(fragment);
  }

  _renderGlobalStats() {
    const ac = this.model.allCycles;
    this.els['global-n'].textContent = ac.length;
    
    const stats = SisyphusMath.getQuantiles(ac);
    if (stats) {
      this.els['gs-min'].textContent = stats.min;
      this.els['gs-25'].textContent = stats.q25.toFixed(1).replace('.0','');
      this.els['gs-50'].textContent = stats.med.toFixed(1).replace('.0','');
      this.els['gs-75'].textContent = stats.q75.toFixed(1).replace('.0','');
      this.els['gs-max'].textContent = stats.max;
    } else {
      ['gs-min','gs-25','gs-50','gs-75','gs-max'].forEach(id => this.els[id].textContent = '—');
    }
  }

  _renderDistributions() {
    const dist = this.model.distributions;
    const renderBar = (hostId, data, M) => {
      const host = this.els[hostId];
      host.innerHTML = '';
      if(!data.length || !data.some(x=>x)) { host.textContent='—'; return; }
      const max = Math.max(...data.filter(n=>n));
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;align-items:flex-end;gap:2px';
      for(let i=(hostId==='hist-l'?0:1); i<data.length; i++){
        const v = data[i] || 0;
        const bar = document.createElement('div');
        bar.style.cssText = `width:3px;border-radius:2px;background:linear-gradient(180deg,var(--accent-3),var(--accent-2));`;
        bar.style.height = (6 + (max ? 24 * v / max : 0)) + 'px';
        wrap.appendChild(bar);
      }
      host.appendChild(wrap);
    };
    renderBar('hist-k', dist.k, this.model.params.M);
    renderBar('hist-l', dist.l, this.model.params.L);

    const clSamples = dist.cycles;
    const hostCl = this.els['hist-cycle-len'];
    hostCl.innerHTML = '';
    if(clSamples.length) {
      const maxCL = Math.max(...clSamples);
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;align-items:flex-end;gap:2px';
      clSamples.forEach(len => {
        const bar = document.createElement('div');
        bar.style.cssText = 'width:4px;border-radius:2px;background:linear-gradient(180deg,var(--accent-3),var(--accent-2));';
        bar.style.height = (8 + (maxCL ? 32 * len / maxCL : 0)) + 'px';
        wrap.appendChild(bar);
      });
      hostCl.appendChild(wrap);
    } else {
      hostCl.textContent = '—';
    }

    const hostHM = this.els['hist-kl'];
    hostHM.innerHTML = '';
    const klData = dist.kl;
    let maxC = 0;
    klData.forEach(row => row.forEach(c => { if(c > maxC) maxC = c; }));
    
    if(maxC > 0) {
      const M = this.model.params.M;
      const L = this.model.params.L;
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = `repeat(${M}, minmax(4px, 1fr))`;
      grid.style.gap = '1px';
      const logMax = Math.log(1+maxC);
      
      for(let l=L; l>=0; l--) {
        for(let k=1; k<=M; k++) {
          const c = (klData[k] && klData[k][l]) || 0;
          const cell = document.createElement('div');
          const alpha = c > 0 ? (0.15 + 0.85 * (Math.log(1+c)/logMax)) : 0.05;
          cell.style.background = `rgba(0,183,255,${alpha.toFixed(3)})`;
          cell.style.aspectRatio = '1/1';
          cell.title = `(${k},${l}): ${c}`;
          grid.appendChild(cell);
        }
      }
      hostHM.appendChild(grid);
    } else {
      hostHM.textContent = '—';
    }
  }

  updateExpectations(grids) {
    const { TopHit, CycleLen, WinCount, TimeLen } = grids;
    const pCycleTop = TopHit[1][0];
    const c = CycleLen[1][0];
    const w = WinCount[1][0];
    const timePerCycle = TimeLen[1][0];
    
    const fmt = x => (100*x).toFixed(3)+'%';
    const el = id => document.getElementById(id);
    
    if(c > 0) {
      el('exp-win-rate').textContent = fmt(w/c);
      el('exp-loss-rate').textContent = fmt((1-pCycleTop)/c);
      el('exp-cycle-len').textContent = c.toFixed(1);
      
      if (pCycleTop > 1e-15) { 
        const expected = c / pCycleTop;
        if (expected > 1e9) {
           el('exp-time-top').textContent = expected.toExponential(2);
        } else {
           el('exp-time-top').textContent = expected.toFixed(1);
        }
        
        // Calculate Wins/Hour (Any Win Transition)
        if (this.model.params.max_delay <= 0) {
          el('exp-wins-hour').textContent = "--";
        } else {
          // Rate = Expected Wins / Expected Time
          // Expected Wins = w (WinCount[1][0])
          // Expected Time = timePerCycle (TimeLen[1][0])
          
          if (timePerCycle > 0.0001) {
             const winsPerHour = (w / timePerCycle) * 3600;
             el('exp-wins-hour').textContent = winsPerHour.toFixed(2);
          } else {
             el('exp-wins-hour').textContent = "--";
          }
        }
      } else {
        if (pCycleTop === 0) {
           el('exp-time-top').textContent = '∞ (prob ≈ 0)';
           el('exp-wins-hour').textContent = '0.00';
        } else {
           el('exp-time-top').textContent = (c/pCycleTop).toExponential(2);
           if (timePerCycle > 0.0001) {
             const winsPerHour = (w / timePerCycle) * 3600;
             el('exp-wins-hour').textContent = winsPerHour.toFixed(2);
           } else {
             el('exp-wins-hour').textContent = "--";
           }
        }
      }
    }
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 4: CHAOS ENGINE                                                    */
/* -------------------------------------------------------------------------- */
class ChaosEngine {
  constructor() {
    this.canvas = document.getElementById('chaosCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.statusEl = document.getElementById('weather-status-main');
    this.modEl = document.getElementById('weather-mod-val');
    
    // Lorenz Parameters
    this.SIGMA = 10;
    this.RHO = 28;
    this.BETA = 8/3;
    this.DT = 0.002; // Slowed down from 0.008

    // State - Randomized start to ensure different pattern every reload
    this.x = 0.1 + (Math.random() - 0.5) * 0.1;
    this.y = 0 + (Math.random() - 0.5) * 0.1;
    this.z = 0 + (Math.random() - 0.5) * 0.1;
    
    this.points = [];
    this.MAX_POINTS = 4800;
    
    // Multiplier for Delay
    this.multiplier = 1.0; 

    // Resize handling - using parent element width since it's now contained
    this.resize();
    window.addEventListener('resize', () => this.resize());
    
    // Start Loop
    this.animate();
  }
  
  resize() {
    if (this.canvas.parentElement) {
       this.canvas.width = this.canvas.parentElement.clientWidth;
       this.canvas.height = this.canvas.parentElement.clientHeight;
    } else {
       this.canvas.width = window.innerWidth;
       this.canvas.height = window.innerHeight;
    }
  }
  
  step() {
    const dx = (this.SIGMA * (this.y - this.x)) * this.DT;
    const dy = (this.x * (this.RHO - this.z) - this.y) * this.DT;
    const dz = (this.x * this.y - this.BETA * this.z) * this.DT;
    
    this.x += dx;
    this.y += dy;
    this.z += dz;
    
    return { dx, dy, dz };
  }
  
  updateWeather(velocity) {
    // Normalizing velocity:
    // With DT=0.002, the displacement is smaller per frame.
    // Velocity is displacement per frame.
    // A multiplier of 40x brings the intensity back to a useful 0-1ish range.
    let intensity = (velocity * 40) / 30; 
    
    if(intensity > 1) intensity = 1;
    
    // Calculate Multiplier
    // Range: 0.5x (Fast) to 2.5x (Slow)
    this.multiplier = 0.5 + (intensity * 2.0);
    
    if (this.modEl) {
       this.modEl.textContent = this.multiplier.toFixed(2) + "x";
    }

    // Update UI
    let statusText = "";
    let statusClass = "";

    if(intensity < 0.25) {
      statusText = "CALM";
      statusClass = "weather-good";
    } else if (intensity < 0.6) {
      statusText = "WINDY";
      statusClass = "weather-ok";
    } else {
      statusText = "STORM";
      statusClass = "weather-bad";
    }

    if (this.statusEl) {
      this.statusEl.textContent = statusText;
      this.statusEl.className = "weather-status " + statusClass;
    }

    if (this.modEl) {
      this.modEl.className = "mono " + statusClass;
    }
  }
  
  animate() {
    // 1. Calculate
    const deltas = this.step();
    // Velocity here is just magnitude of displacement vector per frame
    const velocity = Math.sqrt(deltas.dx**2 + deltas.dy**2 + deltas.dz**2);
    
    // 2. Logic Update
    this.updateWeather(velocity); 
    
    // 3. Draw
    // Ensure we handle case where canvas might be 0 size
    if (this.canvas.width === 0) return requestAnimationFrame(() => this.animate());

    const scale = 12;
    const cx = this.canvas.width / 2;
    const cy = this.canvas.height / 2; // Center based on current container
    
    // We project X/Z plane mostly to look cool
    this.points.push({
      x: cx + (this.x * scale),
      y: cy + (this.y * scale) 
    });
    
    if(this.points.length > this.MAX_POINTS) this.points.shift();
    
    // Clear canvas - transparent background
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    this.ctx.beginPath();
    if(this.points.length > 0) {
      this.ctx.moveTo(this.points[0].x, this.points[0].y);
      for(let i=1; i<this.points.length; i++) {
        this.ctx.lineTo(this.points[i].x, this.points[i].y);
      }
    }
    
    // Dynamic Color
    const hue = 180 + (velocity * 40 * 20); // Scaled for color too
    this.ctx.strokeStyle = `hsl(${hue}, 80%, 60%)`;
    this.ctx.lineWidth = 2;
    this.ctx.stroke();
    
    requestAnimationFrame(() => this.animate());
  }
  
  getModifier() {
    return this.multiplier;
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 5: GAME CONTROLLER                                                 */
/* -------------------------------------------------------------------------- */
class GameController {
  constructor() {
    this.model = new SisyphusModel();
    this.ui = new SisyphusUI(this.model);
    
    // Init Chaos
    this.chaos = new ChaosEngine();
    
    this.autoTimerId = null;
    this.bgTimer = new BackgroundTimer(); // Worker-based timer
    this.renderReq = null;
    this.isAuto = false;
    this.controlsLocked = false;
    this.grids = null;
    this.announcer = new AriaAnnouncer();
    this.perfMonitor = new PerformanceMonitor();
    
    // Start a heartbeat timer to update the "Time in Run" stats every second
    setInterval(() => {
      if (this.ui) {
        const elapsed = Math.max(0, Date.now() - this.model.startTime);
        const el = document.getElementById('run-time');
        if (el) el.textContent = this.ui._formatDuration(elapsed);
      }
    }, 1000);
    
    this.bindEvents();
    this.bindKeyboard();
    this.load(); 
    this.recalcExpectations();
    this.ui.render(this.grids, true); 
  }

  bindEvents() {
    const $ = id => document.getElementById(id);
    $('roll1_big').onclick = () => this.stepManually();
    $('rollN').onclick = () => {
      const n = +$('nRolls').value || 20;
      for(let i=0; i<n; i++) {
         const res = this.model.step();
         if (!res) break; 
         if (res === 'top') break; 
      }
      this.ui.render(this.grids);
      this.save();
    };
    
    $('rollNCycles').onclick = () => {
      const n = +$('nRolls').value || 1;
      const targetCycle = this.model.cycleId + n;
      const maxSteps = 2000000; 
      let steps = 0;

      while(this.model.cycleId < targetCycle && steps < maxSteps) {
        const res = this.model.step();
        if (!res) break; 
        if (res === 'top') break; 
        steps++;
      }
      if (steps >= maxSteps) console.warn("Roll N Cycles: Safety limit reached");
      this.ui.render(this.grids);
      this.save();
    };

    $('auto').onclick = () => this.toggleAuto();
    $('apply').onclick = () => this.applyParams();
    $('resetState').onclick = () => this.reset();
    $('setStateBtn').onclick = () => {
      const k = +$('set-k').value || 1;
      const l = +$('set-l').value || 0;
      this.model.setState(k, l);
      this.ui.render(this.grids);
    }
  }
  
  bindKeyboard() {
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
        return;
      }
      const helpModal = document.getElementById('help-modal');
      switch(e.key) {
        case ' ':  
        case 'Enter':
          e.preventDefault();
          if (!helpModal.classList.contains('show')) {
            this.stepManually();
          }
          break;
        case 'r':  
        case 'R':
          if (e.ctrlKey || e.metaKey) return; 
          e.preventDefault();
          this.reset();
          break;
        case 'a':  
        case 'A':
          e.preventDefault();
          this.toggleAuto();
          break;
        case '?':  
          e.preventDefault();
          helpModal.classList.toggle('show');
          break;
        case 'Escape':
          if (helpModal.classList.contains('show')) {
            e.preventDefault();
            helpModal.classList.remove('show');
          }
          break;
      }
    });
  }

  getDynamicDelay() {
    // 1. Get Base Delay from Game Params
    const base = SisyphusMath.getDelay(this.model.state.k, this.model.state.l, this.model.params);
    if(base === 0) return 0;

    // 2. Get Modifier from Weather (0.5x to 2.5x)
    const mod = this.chaos.getModifier();
    
    return base * mod;
  }

  stepManually() {
    if (this.controlsLocked) return;
    if(this.isAuto) this.toggleAuto();
    
    const res = this.model.step();
    this.handleStepResult(res); 
    this.ui.render(this.grids);
    this.save();

    // Always attempt delay for manual play, based on parameter
    if (res !== 'top') {
      const delay = this.getDynamicDelay();
      if (delay > 0) {
        this.lockControls(delay);
      }
    }
  }

  lockControls(duration) {
    this.controlsLocked = true;
    const btn = document.getElementById('roll1_big');
    const originalText = "Roll";
    btn.disabled = true;
    
    const endTime = Date.now() + duration;
    
    // Use BackgroundTimer to ensure the unlock event fires even if tab is backgrounded.
    // We use a 50ms tick to update the UI text if visible.
    const timerId = this.bgTimer.setInterval(() => {
      const remaining = endTime - Date.now();
      
      if (remaining <= 0) {
        this.bgTimer.clear(timerId);
        this.controlsLocked = false;
        btn.disabled = false;
        btn.textContent = originalText;
      } else {
        // Ensure we don't display negative numbers briefly
        const displayTime = Math.max(0, remaining);
        btn.textContent = `Wait ${(displayTime/1000).toFixed(1)}s`;
      }
    }, 50);
  }

  toggleAuto() {
    const btn = document.getElementById('auto');
    
    if (this.isAuto) {
      // STOPPING
      if (this.autoTimerId) {
        this.bgTimer.clear(this.autoTimerId);
        this.autoTimerId = null;
      }
      if (this.renderReq) {
        cancelAnimationFrame(this.renderReq);
        this.renderReq = null;
      }
      this.isAuto = false;
      btn.textContent = 'Auto Play';
      this.ui.render(this.grids, true);
    } else {
      // STARTING
      this.isAuto = true;
      btn.textContent = 'Stop';
      
      // Separate render loop
      let frameCount = 0;
      const renderLoop = () => {
        if(!this.isAuto) return;
        frameCount++;
        this.ui.render(this.grids, frameCount % 60 === 0);
        this.perfMonitor.tick();
        this.renderReq = requestAnimationFrame(renderLoop);
      };
      renderLoop();

      // Game Logic Loop
      const logicLoop = () => {
        if (!this.isAuto) return;
        if (this.model.state.topHit) {
          this.toggleAuto();
          return;
        }

        const res = this.model.step();
        this.handleStepResult(res);

        if (res === 'top') {
          this.toggleAuto();
          this.ui.render(this.grids, true);
          return;
        }

        const useDelay = document.getElementById('use-delay').checked;
        let delay = 0;

        if (useDelay) {
          delay = this.getDynamicDelay();
          if (delay === 0) delay = 50;
        } else {
          delay = +document.getElementById('speed').value || 100;
          if (delay < 20) {
            for(let i=0; i<9; i++) { 
              if(!this.model.state.topHit) this.model.step(); 
            }
          }
        }

        // Use background timer for next step to prevent throttling
        this.autoTimerId = this.bgTimer.setTimeout(logicLoop, delay);
      };

      logicLoop();
    }
  }

  handleStepResult(res) {
    if (res === 'top') {
      this.announcer.announce("Congratulations! Top hit reached!");
      alert("Top Hit Reached!");
    } else if (res === 'win') {
      this.announcer.announce(`Win! Now at level ${this.model.state.k}`);
    } else if (res === 'loss') {
      this.announcer.announce("Loss. Reset to level 1");
    } else if (res === 'neu') {
      this.announcer.announce("Neutral. Momentum increased");
    }
    if(res && res !== 'top') this.ui.log(`step ${this.model.state.step}: ${this.model.lastRoll.outcome.toUpperCase()}`);
  }

  applyParams() {
    const p = this.model.params;
    ['M','L','w_min','w_max','beta','rho','gamma','c_min','c_max','alpha','g_n','s_w','max_delay'].forEach(k => {
      const el = document.getElementById(k);
      if(el) p[k] = +el.value;
    });
    SisyphusMath.clearCache();
    this.reset(); 
  }

  reset() {
    this.model.reset();
    this.recalcExpectations();
    this.ui.render(this.grids, true);
    this.ui.els.log.innerHTML = '';
    this.save();
    this.announcer.announce("Game reset");
  }

  recalcExpectations() {
    this.grids = SisyphusMath.solveExpectations(this.model.params);
    this.ui.updateExpectations(this.grids);
  }

  save() {
    const data = {
      params: this.model.params,
      state: this.model.state,
      stats: this.model.stats,
      historyK: this.model.historyK,
      cycleSummaries: this.model.cycleSummaries,
      distributions: this.model.distributions,
      allCycles: this.model.allCycles,
      lastRoll: this.model.lastRoll,
      cycleId: this.model.cycleId,
      currentCycle: this.model.currentCycle,
      startTime: this.model.startTime // Save start time
    };
    localStorage.setItem('sisyphus_v9_delay', JSON.stringify(data));
  }

  load() {
    try {
      const raw = localStorage.getItem('sisyphus_v9_delay') || 
                  localStorage.getItem('sisyphus_v8_optimized'); 
      if(raw) {
        const data = JSON.parse(raw);
        Object.assign(this.model.params, data.params);
        Object.assign(this.model.state, data.state);
        Object.assign(this.model.stats, data.stats);
        
        if(data.historyK) this.model.historyK = data.historyK;
        if(data.cycleSummaries) this.model.cycleSummaries = data.cycleSummaries;
        if(data.distributions) this.model.distributions = data.distributions;
        if(data.allCycles) this.model.allCycles = data.allCycles;
        if(data.lastRoll) this.model.lastRoll = data.lastRoll;
        if(data.cycleId) this.model.cycleId = data.cycleId;
        if(data.currentCycle) this.model.currentCycle = data.currentCycle;
        if(data.startTime) this.model.startTime = data.startTime;
        else this.model.startTime = Date.now(); // Backwards compat

        Object.keys(this.model.params).forEach(k => {
           const el = document.getElementById(k);
           if(el) el.value = this.model.params[k];
        });
      }
    } catch(e) {
      console.warn("Load failed", e);
    }
  }
}

document.addEventListener('DOMContentLoaded', () => {
  window.game = new GameController();
});

</script>
</body>
</html>
