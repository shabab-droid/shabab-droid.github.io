<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sisyphus' Ruin</title>
<style>
  :root {
    /* Default Colors (Cosmic) - These are overridden by JS themes */
    --bg: #080014;
    --text: #fef8ff;
    
    /* Semantic Color Names */
    --ascent: #ff9e2c;   /* Gold/Orange */
    --summit: #ffea00;   /* Yellow */
    --steady: #00b7ff;   /* Blue */
    --poise: #ff00b8;    /* Pink */
    --ruin: #ff3333;     /* Red */
    
    --muted: #d8d8d4;   
    
    --card-bg: rgba(12, 0, 32, 0.6);
    --card-border: rgba(255,255,255,0.05);

    --bg-image: 
      radial-gradient(900px 700px at 50% -200px, rgba(255,0,200,.15), transparent 70%),
      radial-gradient(900px 700px at 50% 120%, rgba(0,200,255,.12), transparent 70%),
      linear-gradient(180deg,#0b0014 0%, #050010 100%);
  }

  body {
    margin: 0; font-family: Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; 
    color: var(--text);
    min-height: 100vh; 
    background-color: var(--bg);
    background-image: var(--bg-image);
    background-repeat: no-repeat; 
    background-size: cover;
    background-attachment: fixed;
    transition: background-color 0.5s ease, color 0.5s ease, background-image 0.5s ease;
  }
  
  .app{max-width:1100px;margin:0 auto;padding:6px}
  
  h1{
    text-align:center; font-size:clamp(18px,3vw,26px); margin:6px 0 6px; letter-spacing:.5px;
    background:linear-gradient(9deg,var(--ascent),var(--poise),var(--steady));
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow: 0 2px 10px rgba(0,0,0,0.2);
  }
  
  /* Reduced grid gap */
  .grid{display:grid;grid-template-columns:1fr 360px;gap:6px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  
  /* Compact Card Styling */
  .card {
    background: var(--card-bg); 
    backdrop-filter: blur(4px); 
    padding: 8px; 
    border-radius: 8px; 
    border: 1px solid var(--card-border);
    transition: background 0.5s ease, border-color 0.5s ease;
    margin-bottom: 6px; /* Reduced margin between cards */
  }
  
  .card h2 { font-size: 15px; margin: 0 0 4px; opacity: 0.9; }

  .btn{
    appearance:none; background:#1c0130; border:none; color:var(--text); border-radius:6px;
    padding:6px 10px; cursor:pointer; font-weight:600; letter-spacing:.3px;
    transition:background .15s ease,transform .1s ease; box-shadow:inset 0 0 0 1px rgba(255,255,255,.1);
    background: rgba(0,0,0,0.3); /* Adaptive button bg */
    font-size: 11px;
  }
  .btn:hover{background:rgba(255,255,255,0.1)}
  .btn:active{transform:scale(.97)}
  .btn:focus{outline:2px solid var(--ascent);outline-offset:2px}
  
  .btn:disabled {
    opacity: 0.9; cursor: not-allowed; background: #2a2a2a !important;
    color: #aaa !important; transform: none !important; box-shadow: none !important;
  }
  
  .checkbox-wrapper {
    display: flex; align-items: center; gap: 6px; padding: 0 6px; width: auto; 
    height: 28px; cursor: pointer; user-select: none; opacity: 0.85; transition: opacity 0.2s;
  }
  .checkbox-wrapper:hover { opacity: 1; }
  .checkbox-wrapper input[type="checkbox"] {
    appearance: none; width: 14px; height: 14px; background: rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.3); border-radius: 3px; cursor: pointer;
    display: grid; place-content: center; margin: 0;
  }
  .checkbox-wrapper input[type="checkbox"]::before {
    content: ""; width: 8px; height: 8px; background: var(--ascent);
    transform: scale(0); transition: 0.1s transform; border-radius: 1px;
  }
  .checkbox-wrapper input[type="checkbox"]:checked::before { transform: scale(1); }
  .checkbox-wrapper input[type="checkbox"]:checked { border-color: var(--ascent); }
  .checkbox-wrapper label { cursor: pointer; color: var(--text); width: auto; font-size: 11px; font-weight: 500; }

  .docked-control {
    position: sticky; top: 0; z-index: 1000;
    background: var(--card-bg); backdrop-filter: blur(8px);
    margin: -6px -6px 6px -6px; padding: 6px;
    border-bottom: 1px solid var(--ascent);
    display: flex; justify-content: center;
  }

  .btn.big{
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    width:100%; padding:8px; margin-bottom:0; 
    /* UPDATED: Gradient reversed to match Ruin (Left) -> Ascent (Right) */
    background: linear-gradient(90deg, var(--ruin), var(--steady), var(--ascent)); 
    color: var(--bg); font-weight:800; max-width: 600px; min-height: 48px; 
    line-height: 1.2; transition: background 0.3s ease; border: none;
    text-shadow: 0 0 10px rgba(255,255,255,0.2);
  }
  .btn.big:hover{opacity: 0.9;}
  
  .btn.big.outcome-win:disabled { background: var(--ascent) !important; color: var(--bg) !important; opacity: 1 !important; }
  .btn.big.outcome-neu:disabled { background: var(--steady) !important; color: var(--bg) !important; opacity: 1 !important; }
  .btn.big.outcome-loss:disabled { background: var(--ruin) !important; color: #ffffff !important; opacity: 1 !important; }
  
  .btn-main-text { font-size: 16px; text-transform: uppercase; }

  label{width:100px;font-size:10px;color:var(--muted); line-height: 1.1;}
  
  input[type="number"],select, input[type="text"]{
    background:rgba(0,0,0,0.3); color:var(--text); border:none; border-radius:4px;
    padding:3px 5px; width: 45px; box-shadow:inset 0 0 0 1px rgba(255,255,255,.1); font-size: 10px;
  }
  input[type="text"] { width: 100%; }

  input[type="color"] {
    -webkit-appearance: none; border: none; width: 100%; height: 24px; padding: 0; overflow: hidden; border-radius: 3px; background: none; cursor: pointer;
  }
  input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
  input[type="color"]::-webkit-color-swatch { border: none; border-radius: 3px; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.2); }
  
  select#speed { width: auto; }
  input#nRolls { width: 45px; }

  .desc{font-size:9px;opacity:.6;color:var(--muted);margin:-2px 0 3px; display:block; line-height:1.2;}
  .row{display:flex;gap:4px;align-items:center;flex-wrap:wrap; margin-bottom: 3px;}
  .bar{
    height:8px; background:rgba(255,255,255,.06); border-radius:6px;
    overflow:hidden; margin:2px 0; border:1px solid rgba(255,255,255,.1);
  }
  .bar>div{height:100%}
  .bar .win{background:var(--ascent)}
  .bar .neu{background:var(--steady)}
  .bar .loss{background:var(--ruin)}

  .recent-bars { position: relative; margin-top: 14px !important; }
  
/* UPDATED RNG MARKER */
  .rng-marker {
    position: absolute;
    top: -9px; 
    transform: translateX(-50%);
    width: 12px; height: 12px;
    border-radius: 50%;
    
    /* Start White by default */
    background-color: #ffffff; 
    border: 2px solid var(--bg);
    box-shadow: 0 0 6px rgba(0,0,0,0.8);
    z-index: 10;
    pointer-events: none;
    left: 0%;
    opacity: 0;
    
    /* Add background-color to transitions */
    transition: left 0.5s, opacity 0.2s, background-color 0.5s ease;
    will-change: left, background-color;
  }
  .rng-marker.visible { opacity: 1; }

  /* New Outcome States for the Marker */
  .rng-marker.mark-win { background-color: var(--ascent) !important; border-color: #fff; transform: translateX(-50%) scale(1.2); }
  .rng-marker.mark-neu { background-color: var(--steady) !important; border-color: #fff; transform: translateX(-50%) scale(1.2); }
  .rng-marker.mark-loss { background-color: var(--ruin) !important; border-color: #fff; transform: translateX(-50%) scale(1.2); }
  .rng-marker.mark-top { background-color: var(--summit) !important; border-color: #fff; transform: translateX(-50%) scale(1.5); box-shadow: 0 0 15px var(--summit); }
  .kpos-track,.lpos-track{
    height:5px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1);
    border-radius:4px; overflow:hidden;
  }
  
  .kpos-fill, .lpos-fill {
    height: 100%; width: 0%; transition: width 0s linear; will-change: width, background-position;
  }
  
  /* UPDATED GRADIENTS */
  /* Ascent -> Summit */
  .kpos-fill { background: linear-gradient(90deg, var(--ascent), var(--summit)); }
  /* Poise -> Steady */
  .lpos-fill { background: linear-gradient(90deg, var(--poise), var(--steady)); }

  @keyframes barberpole {
    0% { background-position: 0 0, 0 0; }
    100% { background-position: 40px 0, 0 0; }
  }

  .kpos-fill.active-motion, .lpos-fill.active-motion {
    animation: barberpole 0.5s linear infinite;
    filter: brightness(1.2) contrast(1.1);
    box-shadow: 0 0 8px rgba(255,255,255,0.2);
    border-right: 2px solid rgba(255,255,255,0.8);
    background-size: 20px 20px, 100% 100%;
  }

  .kpos-fill.active-motion {
    background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.2) 75%, transparent 75%, transparent), linear-gradient(90deg, var(--ascent), var(--summit));
  }

  .lpos-fill.active-motion {
    background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.2) 75%, transparent 75%, transparent), linear-gradient(90deg, var(--poise), var(--steady));
  }

  .kpos-fill.reverse-motion, .lpos-fill.reverse-motion {
    animation-direction: reverse; 
    border-right: 2px solid var(--ruin);
    background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.2) 75%, transparent 75%, transparent), linear-gradient(90deg, var(--ruin), var(--ruin)) !important;
  }
  
  .tiny{font-size:10px;opacity:.65;color:var(--muted)}
  .mono{font-family:monospace;}
  .small{font-size:11px;}

#recent-outcome {
  color: var(--muted);
  transition: color 0.2s ease;
}

  .recent.win #recent-outcome{color:var(--ascent); text-shadow:0 0 12px var(--ascent);}
  .recent.neu #recent-outcome{color:var(--steady); text-shadow:0 0 12px var(--steady);}
  .recent.loss #recent-outcome{color:var(--ruin); text-shadow:0 0 12px var(--ruin);}
  
  .cycle-entry {
    font-family: monospace; font-size: 10px; border-radius: 4px; 
    border-left: 2px solid rgba(255,255,255,.12); padding: 3px 5px; 
    margin-bottom: 2px; background: rgba(0,0,0,0.3); 
    white-space: pre-wrap; word-break: break-word;
    display: flex; flex-direction: column; gap: 1px;
  }
  .cycle-entry.loss { border-color: var(--ruin); }
  .cycle-entry.top { border-color: var(--summit); background: rgba(255,255,255,0.1); }
  .cycle-entry.active { border-color: var(--text); background: rgba(255,255,255,0.05); }

  .cycle-entry-top-row { display: flex; justify-content: space-between; align-items: baseline; font-weight: 600; opacity: 0.9; line-height: 1.2; }
  .cycle-id { color: var(--steady); margin-right: 6px; }
  .cycle-meta { font-weight: 400; opacity: 0.65; font-size: 9px; }
  .cycle-entry-path { opacity: 0.75; font-size: 9px; line-height: 1.1; letter-spacing: 1px; margin-top: 1px; }

  .stats-grid {
    display: grid; grid-template-columns: repeat(5, 1fr); gap: 2px; margin-top: 4px;
    background: rgba(255,255,255,0.03); padding: 4px; border-radius: 4px;
  }
  .stat-box { display: flex; flex-direction: column; align-items: center; }
  .stat-label { font-size: 8px; opacity: 0.5; text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-val { font-family: monospace; font-size: 10px; font-weight: 600; color: var(--steady); }

  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  .perf-indicator { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.8); padding: 4px 8px; border-radius: 4px; font-size: 10px; font-family: monospace; opacity: 0.5; pointer-events: none; }

  /* Modals */
  .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); backdrop-filter: blur(2px); z-index: 2000; align-items: center; justify-content: center; }
  .modal.show { display: flex; }
  .modal-content { background: var(--bg); border: 2px solid var(--ascent); padding: 24px; border-radius: 10px; max-width: 450px; width: 90%; box-shadow: 0 0 40px rgba(0,0,0,0.8); position: relative; }
  .modal h3 { margin-top: 0; color: var(--ascent); font-size: 20px; letter-spacing: 0.5px; }
  .modal kbd { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px; font-family: monospace; border: 1px solid rgba(255,255,255,0.2); }
  
  .welcome-list { margin: 12px 0; padding-left: 0; list-style: none; }
  .welcome-list li { margin-bottom: 12px; line-height: 1.5; font-size: 14px; opacity: 0.9; }
  .welcome-list strong { color: var(--steady); }

  .weather-status { font-weight: 800; letter-spacing: 0.5px; }
  .weather-good { color: var(--ascent); text-shadow: 0 0 5px var(--ascent); }
  .weather-ok { color: var(--steady); text-shadow: 0 0 5px var(--steady); }
  .weather-bad { color: var(--ruin); text-shadow: 0 0 5px var(--ruin); }

  #weather-card { position: relative; overflow: hidden; min-height: 240px; display: flex; flex-direction: column; justify-content: space-between; }
  #weather-content { position: relative; z-index: 2; }
  #chaosCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.5; pointer-events: none; }

  .save-slots-container { margin: 6px 0; padding: 4px; background: rgba(0,0,0,0.2); border-radius: 6px; border: 1px solid rgba(255,255,255,0.05); }
  .slot-mode-switch { display: flex; gap: 4px; margin-bottom: 4px; }
  .slot-mode-btn { flex: 1; font-size: 9px; text-transform: uppercase; letter-spacing: 0.5px; padding: 2px; border: 1px solid transparent; opacity: 0.5; transition: all 0.2s ease; }
  .slot-mode-btn.active { opacity: 1; font-weight: 800; }
  .mode-save .slot-mode-btn[data-mode="save"] { background: var(--ascent); color: var(--bg); box-shadow: 0 0 8px var(--ascent); }
  .mode-load .slot-mode-btn[data-mode="load"] { background: var(--steady); color: var(--bg); box-shadow: 0 0 8px var(--steady); }

  .slot-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 3px; }
  .slot-btn { background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; padding: 2px; font-family: monospace; font-size: 8px; color: var(--muted); cursor: pointer; transition: all 0.2s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 32px; text-align: center; }
  .slot-btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.3); }
  .slot-btn.has-data { border-color: rgba(255,255,255,0.3); color: var(--text); background: rgba(255,255,255,0.05); }
  .slot-btn.empty { opacity: 0.6; font-style: italic; }
  .mode-save .slot-btn:hover { border-color: var(--ascent); color: var(--ascent); }
  .mode-load .slot-btn:hover { border-color: var(--steady); color: var(--steady); }
  .slot-label { font-weight: 800; font-size: 9px; margin-bottom: 0px; }
  .slot-info { font-size: 7px; line-height: 1.1; opacity: 0.8; }

  /* Accordion Styling */
  details { margin-bottom: 2px; background: rgba(255,255,255,0.02); border-radius: 4px; overflow: hidden; }
  details summary { cursor: pointer; padding: 3px 6px; user-select: none; outline: none; background: rgba(255,255,255,0.03); font-weight: 600; font-size: 11px; color: var(--muted); }
  details summary:hover { color: var(--ascent); background: rgba(255,255,255,0.06); }
  details > summary { list-style: none; }
  details > summary::-webkit-details-marker { display: none; }
  details > summary::before { content: '▶'; display: inline-block; margin-right: 6px; font-size: 9px; color: var(--ascent); transition: transform 0.2s; }
  details[open] > summary::before { transform: rotate(90deg); }
  
  details .details-content { padding: 4px 6px; border-top: 1px solid rgba(255,255,255,0.05); }
  .card details { margin-bottom: 2px; }

  .palette-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; margin-top: 8px;}
  .palette-item { display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .palette-label { font-size: 8px; opacity: 0.7; }
</style>
<link rel="icon" type="image/svg+xml" href="/sisyphus-icon.svg">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">

</head>
<body>

<div role="status" aria-live="polite" aria-atomic="true" class="sr-only" id="aria-announcer"></div>

<div class="modal" id="help-modal" role="dialog" aria-labelledby="help-title">
  <div class="modal-content">
    <h3 id="help-title">Keyboard Shortcuts</h3>
    <dl>
      <dt><kbd>Space</kbd> or <kbd>Enter</kbd></dt>
      <dd>Roll once</dd>
      <dt><kbd>A</kbd></dt>
      <dd>Toggle auto-play</dd>
      <dt><kbd>R</kbd></dt>
      <dd>Reset game</dd>
      <dt><kbd>?</kbd></dt>
      <dd>Show/hide this help</dd>
      <dt><kbd>Esc</kbd></dt>
      <dd>Close this help</dd>
    </dl>
    <button class="btn" onclick="document.getElementById('help-modal').classList.remove('show')">Close</button>
  </div>
</div>

<div class="modal" id="welcome-modal" role="dialog" aria-labelledby="welcome-title">
  <div class="modal-content">
    <h3 id="welcome-title">Welcome to Sisyphus' Ruin</h3>
    <div class="tiny" style="margin-bottom:16px; opacity:0.7; font-style:italic">The struggle itself towards the heights is enough to fill a man's heart.</div>
    <ul class="welcome-list">
      <li><strong>1. Roll</strong> to push the stone.</li>
      <li><strong>2. Watch</strong> the outcome: <strong>Ascent</strong> gains height and <strong>Ruin</strong> returns you to the bottom. <strong>Steady</strong> builds your poise, raising the chance of ascent and reducing the chance of ruin.</li>
      <li><strong>3. Endure:</strong> The atmosphere will distort, delaying or speeding your next move.</li>
    </ul>
    <button class="btn" style="width:100%" onclick="document.getElementById('welcome-modal').classList.remove('show'); localStorage.setItem('sisyphus_welcome_seen', 'true');">Begin</button>
  </div>
</div>

<div class="modal" id="summit-modal" role="dialog" aria-labelledby="summit-title">
  <div class="modal-content" style="border-color: var(--summit); box-shadow: 0 0 50px var(--summit);">
    <h3 id="summit-title" style="color:var(--summit); text-align:center; font-size:24px; margin-bottom:8px">The Summit</h3>
    <div class="tiny" style="text-align:center; margin-bottom:20px; font-style:italic; opacity:0.8">
      The stone rests. The air is still. For a moment, the struggle ceases.
    </div>
    
    <div style="background:rgba(255,255,255,0.05); padding:16px; border-radius:6px; margin-bottom:20px;">
      <div class="row" style="justify-content:space-between; margin-bottom:8px">
        <span style="opacity:0.7">Duration</span>
        <span class="mono" id="summit-duration" style="font-weight:bold">0s</span>
      </div>
      <div class="row" style="justify-content:space-between; margin-bottom:8px">
        <span style="opacity:0.7">Total Steps</span>
        <span class="mono" id="summit-steps" style="font-weight:bold">0</span>
      </div>
      <div class="row" style="justify-content:space-between">
        <span style="opacity:0.7">Attempts</span>
        <span class="mono" id="summit-cycles" style="font-weight:bold">0</span>
      </div>
    </div>

    <div style="display:flex; gap:12px; flex-direction:column">
      <button class="btn big outcome-win" id="btn-summit-reset">
        BEGIN AGAIN
      </button>
      <button class="btn" id="btn-summit-close" style="background:transparent; border:1px solid rgba(255,255,255,0.2); opacity:0.8">
        Survey the mountain
      </button>
    </div>
  </div>
</div>

<div class="perf-indicator" id="perf-indicator"></div>

<template id="tpl-cycle-entry">
  <div class="cycle-entry">
    <div class="cycle-entry-top-row">
      <span class="cycle-main-text"></span>
      <span class="cycle-meta"></span>
    </div>
    <div class="cycle-entry-path"></div>
  </div>
</template>

<div class="app">
  <h1>Sisyphus' Ruin</h1>

  <div class="docked-control">
    <button class="btn big" id="roll1_big" aria-label="Roll the dice once" aria-keyshortcuts="Space Enter">
      <span class="btn-main-text" id="btn-roll-main">ROLL</span>
    </button>
  </div>

  <div class="grid">
    <div>
      <div class="card recent" id="recent-card" role="region" aria-label="Recent roll result">
        <div style="display:flex;flex-direction:column;gap:2px">
          <div id="recent-outcome" style="font-weight:900;letter-spacing:1px;font-size:clamp(20px,3.2vw,32px)">No rolls yet</div>
        </div>
        
        <div class="recent-bars" style="margin-top:8px;">
          <div id="rng-marker" class="rng-marker"></div>
          <div class="bar" style="display:flex; height:12px; overflow:hidden; margin-bottom:4px" role="progressbar">
            <div id="rbar-loss" class="loss" style="width:0%"></div>
            <div id="rbar-neu" class="neu" style="width:0%"></div>
            <div id="rbar-win" class="win" style="width:0%"></div>
          </div>
          <div class="row" style="justify-content:space-between; font-size:11px; opacity:0.8">
            <div>Ruin: <span class="mono" id="rpct-loss">0.0%</span></div>
            <div>Steady: <span class="mono" id="rpct-neu">0.0%</span></div>
            <div>Ascent: <span class="mono" id="rpct-win">0.0%</span></div>
          </div>
        </div>

        <div class="kpos" style="margin-top:8px">
          <div class="kpos-track"><div id="kpos-fill" class="kpos-fill" style="width:0%"></div></div>
          <div class="small" style="display:flex; justify-content:space-between">
            <span>Height</span>
            <span id="kpos-text" class="mono">1 / 20</span>
          </div>
        </div>
        <div class="lpos" style="margin-top:4px">
          <div class="lpos-track"><div id="lpos-fill" class="lpos-fill" style="width:0%"></div></div>
          <div class="small" style="display:flex; justify-content:space-between">
            <span>Poise</span>
            <span id="lpos-text" class="mono">0 / 20</span>
          </div>
        </div>
      </div>

      <div class="card" id="weather-card">
        <canvas id="chaosCanvas"></canvas>
        <h2 style="position: relative; z-index: 2;">Atmosphere</h2>
        <div id="weather-content">
          <div style="display:flex; justify-content:space-between; align-items:center">
            <div>
              <div class="tiny" style="margin-bottom:2px">CONDITION</div>
              <div id="weather-status-main" style="font-size:16px; font-weight:800; letter-spacing:1px">CALIBRATING</div>
            </div>
            <div style="text-align:right">
              <div class="tiny" style="margin-bottom:2px">TIME DILATION</div>
              <div id="weather-mod-val" class="mono" style="font-size:16px;">1.0x</div>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:baseline">
          <h2>Climb History</h2>
        </div>
        <div id="cycle-box" class="tiny" style="max-height:160px; overflow-y:auto;"></div>
      </div>

      <div class="card"><h2>Run Stats</h2>
        <div style="margin-bottom:4px; font-size:10px; opacity:0.8">steps: <span class="mono" id="run-steps">0</span></div>
        <div class="bar" style="display:flex; height:5px; overflow:hidden; border-radius:4px" role="progressbar" aria-label="Run Distribution">
          <div class="loss" id="bar-loss" style="width:0%"></div>
          <div class="neu" id="bar-neu" style="width:0%"></div>
          <div class="win" id="bar-win" style="width:0%"></div>
        </div>
        <div class="row" style="justify-content:space-between; font-size:10px; opacity:0.8">
          <div>Ruin: <span class="mono" id="c-loss">0</span> (<span class="mono" id="r-loss">0.0%</span>)</div>
          <div>Steady: <span class="mono" id="c-neu">0</span> (<span class="mono" id="r-neu">0.0%</span>)</div>
          <div>Ascent: <span class="mono" id="c-win">0</span> (<span class="mono" id="r-win">0.0%</span>)</div>
        </div>
        
        <div style="margin-top:8px; font-size:10px; opacity:0.8">weather on press:</div>
        <div class="bar" style="display:flex; height:5px; overflow:hidden; margin-top:2px; border-radius:4px" role="progressbar" aria-label="Weather Distribution">
          <div id="bar-storm" style="width:0%; background:var(--ruin)"></div>
          <div id="bar-windy" style="width:0%; background:var(--steady)"></div>
          <div id="bar-calm" style="width:0%; background:var(--ascent)"></div>
        </div>
        <div class="row" style="justify-content:space-between; font-size:10px; opacity:0.8">
          <div>Storm: <span class="mono" id="c-storm">0</span> (<span class="mono" id="r-storm">0.0%</span>)</div>
          <div>Windy: <span class="mono" id="c-windy">0</span> (<span class="mono" id="r-windy">0.0%</span>)</div>
          <div>Calm: <span class="mono" id="c-calm">0</span> (<span class="mono" id="r-calm">0.0%</span>)</div>
        </div>
        
        <div class="row tiny" style="margin-top:4px;justify-content:space-between">
          <div>run time: <span class="mono" id="run-time">0s</span></div>
          <div>Max Height: <span class="mono" id="max-k">1</span></div>
        </div>
      </div>
    </div>

    <div>
      
      <div class="card">
        <h2 style="margin:0 0 6px">The Burden</h2>
        <div class="tiny" style="line-height:1.5; opacity:0.9; margin-bottom:8px">
          The stone is bound for the summit (Height <span id="lbl-M-goal" style="font-weight:bold; color:var(--summit)">20</span>).
          <br><br>
          In the myth, Sisyphus was condemned to roll a boulder up a mountain for eternity, only to watch it roll back down each time he neared the top. Camus saw in this an image of the human condition: we search for meaning in a universe that offers none. Yet the struggle itself can become a source of purpose. One must imagine Sisyphus happy.
          <br><br>
          Here, you push the stone. The mountain resists. Time stretches and contracts around you. There is no winning—only the climb, and the climbing again.
        </div>
        
        <details style="margin-top:6px">
          <summary>Roll</summary>
          <div class="details-content tiny" style="line-height:1.4">
            Each roll resolves to one of three outcomes based on your current Height and Poise:
            <ul style="padding-left: 14px; margin: 4px 0;">
              <li><strong style="color:var(--ascent)">Ascent:</strong> The stone rises one step. Your Poise shatters from the effort.</li>
              <li><strong style="color:var(--steady)">Steady:</strong> The stone holds. Poise accumulates, improving future odds.</li>
              <li><strong style="color:var(--ruin)">Ruin:</strong> Gravity wins. You return to the bottom.</li>
            </ul>
            At the final Height, Ascent becomes <strong style="color:var(--summit)">Summit</strong>—a momentary victory before the cycle begins anew.
          </div>
        </details>
        
        <details>
          <summary>Poise</summary>
          <div class="details-content tiny" style="line-height:1.4">
            Poise represents stability and readiness. As Poise increases:
            <ul style="padding-left: 14px; margin: 4px 0;">
              <li>The probability of <strong style="color:var(--ascent)">Ascent</strong> rises</li>
              <li>The probability of <strong style="color:var(--ruin)">Ruin</strong> falls</li>
            </ul>
            However, every Ascent consumes a significant amount of Poise, making subsequent rolls more perilous. The wise climber builds Poise through Steady outcomes before attempting to rise.
          </div>
        </details>
        
        <details>
          <summary>Weather</summary>
          <div class="details-content tiny" style="line-height:1.4">
            The chaotic atmosphere affects the passage of time between moves. A Lorenz attractor drives the weather system, creating unpredictable but deterministic patterns:
            <ul style="padding-left: 14px; margin: 4px 0;">
              <li><strong style="color:var(--ascent)">Calm:</strong> Time flows quickly. Rapid progression is possible.</li>
              <li><strong style="color:var(--steady)">Windy:</strong> Moderate delay between actions.</li>
              <li><strong style="color:var(--ruin)">Stormy:</strong> Time dilates significantly. Patience is required.</li>
            </ul>
            The weather does not affect roll outcomes—only the time between them. Higher positions on the mountain experience shorter delays.
          </div>
        </details>
        
        <details>
          <summary>Climb History Legend</summary>
          <div class="details-content tiny" style="line-height:1.4">
            An <strong>Attempt</strong> is a complete journey from Height 1 until <strong style="color:var(--ruin)">Ruin</strong> or <strong style="color:var(--summit)">Summit</strong>.
            <br><br>
            <span class="mono" style="opacity:0.9; letter-spacing:1px">(▼) Ruin&nbsp;&nbsp;(◆) Steady&nbsp;&nbsp;(▲) Ascent&nbsp;&nbsp;(★) Summit</span>
            <br><br>
            The path shows each roll's outcome in sequence. Longer attempts indicate sustained progress before fate intervenes.
          </div>
        </details>
        
        <details>
          <summary>Expectations</summary>
          <div class="details-content tiny" style="line-height:1.4">
            These values are computed from the current parameters using Markov chain analysis. They represent the theoretical long-run behavior of the system:
            <div style="margin-top:6px; padding:4px; background:rgba(0,0,0,0.2); border-radius:4px">
              <div style="margin-bottom:2px">Ascent rate (per roll): <span class="mono" id="exp-win-rate">—</span></div>
              <div style="margin-bottom:2px">Ruin rate (per roll): <span class="mono" id="exp-loss-rate">—</span></div>
              <div style="margin-bottom:2px">p(Ascent | !Steady): <span id="recent-p-cond" class="mono">—</span></div>
              <div style="margin-bottom:2px">p(Summit | current): <span id="recent-p-top" class="mono">—</span></div>
              <div style="margin-top:6px; margin-bottom:2px">Avg steps/attempt: <span class="mono" id="exp-cycle-len">—</span></div>
              <div style="margin-bottom:2px">E[first Summit]: <span class="mono" id="exp-time-top">—</span> rolls</div>
              <div>Optimal Ascents/Hour: <span class="mono" id="exp-wins-hour">—</span></div>
            </div>
          </div>
        </details>
      </div>

      <div class="card"><h3 style="margin:0 0 4px; font-size:14px; opacity:0.8">Distributions</h3>
        <div class="tiny" style="margin-top:4px">Time spent at Height:</div>
        <div id="hist-k" class="tiny" style="margin-top:2px;min-height:20px"></div>
        <div class="tiny" style="margin-top:4px">Time spent at Poise:</div>
        <div id="hist-l" class="tiny" style="margin-top:2px;min-height:20px"></div>
        <div class="tiny" style="margin-top:4px">Height / Poise Heatmap:</div>
        <div id="hist-kl" class="tiny" style="margin-top:2px;min-height:28px"></div>
        
        <div class="tiny" style="margin-top:8px; font-weight:600; color:var(--muted)">Attempt Durations (Global N=<span id="global-n">0</span>)</div>
        <div class="stats-grid" id="global-stats">
          <div class="stat-box"><div class="stat-label">Min</div><div class="stat-val" id="gs-min">—</div></div>
          <div class="stat-box"><div class="stat-label">25%</div><div class="stat-val" id="gs-25">—</div></div>
          <div class="stat-box"><div class="stat-label">Med</div><div class="stat-val" id="gs-50">—</div></div>
          <div class="stat-box"><div class="stat-label">75%</div><div class="stat-val" id="gs-75">—</div></div>
          <div class="stat-box"><div class="stat-label">Max</div><div class="stat-val" id="gs-max">—</div></div>
        </div>

        <div class="tiny" style="margin-top:8px; font-weight:600; color:var(--muted)">Time Dilation on Press (N=<span id="dilation-n">0</span>)</div>
        <div class="stats-grid" id="dilation-stats">
          <div class="stat-box"><div class="stat-label">Min</div><div class="stat-val" id="ds-min">—</div></div>
          <div class="stat-box"><div class="stat-label">25%</div><div class="stat-val" id="ds-25">—</div></div>
          <div class="stat-box"><div class="stat-label">Med</div><div class="stat-val" id="ds-50">—</div></div>
          <div class="stat-box"><div class="stat-label">75%</div><div class="stat-val" id="ds-75">—</div></div>
          <div class="stat-box"><div class="stat-label">Max</div><div class="stat-val" id="ds-max">—</div></div>
        </div>
      </div>

      <div class="card" id="settings-saves-card">
        <details>
          <summary><h2 style="display:inline; font-size:16px; margin:0">Settings &amp; Saves</h2></summary>
          <div class="details-content">
            
            <details id="submenu-theme">
              <summary>Visual Theme</summary>
              <div class="details-content">
                
                <div class="row" style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;">
                  <div style="flex:1">
                    <label class="tiny" style="display:block; margin-bottom:2px;">Preset</label>
                    <select id="theme-select" style="width:100%">
                      <option value="default">Cosmic (Default)</option>
                      <option value="magma">Sisyphus (Magma)</option>
                      <option value="terminal">Terminal (Matrix)</option>
                      <option value="paper">Academic (Light)</option>
                      <option value="ocean">Abyss (Deep Blue)</option>
                      <option value="custom">Custom / Unsaved</option>
                    </select>
                  </div>
                </div>
                
                <div style="background:rgba(255,255,255,0.03); padding:6px; border-radius:4px; margin-bottom:8px">
                    <div class="tiny" style="opacity:0.7; margin-bottom:4px">Saved Palettes</div>
                    <div class="row">
                        <select id="saved-palettes-list" style="flex:1;">
                            <option value="">-- Load Saved --</option>
                        </select>
                        <button id="btn-delete-palette" class="btn" style="color:var(--ruin)">Del</button>
                    </div>
                    <div class="row" style="margin-top:4px">
                         <input type="text" id="save-palette-name" placeholder="Name current..." style="flex:1">
                         <button id="btn-save-palette" class="btn" style="background:var(--steady); color:var(--bg)">Save</button>
                    </div>
                </div>

                <div class="row" style="align-items:flex-end; gap:4px; margin-bottom:8px;">
                  <div style="flex:1">
                    <label class="tiny" style="display:block; margin-bottom:2px;">Harmony Mode</label>
                    <select id="gen-mode" style="width:100%">
                      <option value="tetradic">Tetradic (4-Tone)</option>
                      <option value="triadic">Triadic (3-Tone)</option>
                      <option value="complementary">Complementary</option>
                      <option value="analogous">Analogous</option>
                      <option value="monochromatic">Monochromatic</option>
                    </select>
                  </div>
                  <button class="btn" id="btn-random-oklch" style="flex:1; background:var(--ascent); color:var(--bg);">
                    Randomize (OKLCH)
                  </button>
                </div>

                <div class="tiny" style="opacity:0.7; margin-bottom:4px">Palette Configuration</div>
                <div class="palette-grid">
                  <div class="palette-item">
                    <input type="color" id="p-ascent" data-var="--ascent">
                    <span class="palette-label">Ascent</span>
                  </div>
                  <div class="palette-item">
                    <input type="color" id="p-summit" data-var="--summit">
                    <span class="palette-label">Summit</span>
                  </div>
                  <div class="palette-item">
                    <input type="color" id="p-steady" data-var="--steady">
                    <span class="palette-label">Steady</span>
                  </div>
                  <div class="palette-item">
                    <input type="color" id="p-poise" data-var="--poise">
                    <span class="palette-label">Poise</span>
                  </div>
                  <div class="palette-item">
                    <input type="color" id="p-ruin" data-var="--ruin">
                    <span class="palette-label">Ruin</span>
                  </div>
                  
                  <div class="palette-item">
                    <input type="color" id="p-bg" data-var="--bg">
                    <span class="palette-label">Main BG</span>
                  </div>
                  <div class="palette-item">
                    <input type="color" id="p-card-bg" data-var="--card-bg">
                    <span class="palette-label">Card BG</span>
                  </div>
                  <div class="palette-item">
                    <input type="color" id="p-card-border" data-var="--card-border">
                    <span class="palette-label">Border</span>
                  </div>
                  <div class="palette-item">
                    <input type="color" id="p-text" data-var="--text">
                    <span class="palette-label">Text</span>
                  </div>
                  <div class="palette-item">
                    <input type="color" id="p-muted" data-var="--muted">
                    <span class="palette-label">Muted</span>
                  </div>
                </div>

                <div class="row" style="margin-top:12px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 8px;">
                  <button class="btn" id="btn-theme-export" style="flex:1; font-size:10px;">Export JSON</button>
                  <button class="btn" id="btn-theme-import" style="flex:1; font-size:10px;">Import JSON</button>
                  <input type="file" id="file-theme-import" style="display:none" accept=".json">
                </div>
              </div>
            </details>

            <details id="submenu-saves">
              <summary>Save / Load</summary>
              <div class="details-content">
                <div class="save-slots-container mode-load" id="slot-container">
                   <div class="slot-mode-switch">
                     <button class="btn slot-mode-btn" data-mode="save">Save Mode</button>
                     <button class="btn slot-mode-btn active" data-mode="load">Load Mode</button>
                   </div>
                   <div class="slot-grid">
                     <button class="slot-btn empty" data-slot="1"><div class="slot-label">1</div><div class="slot-info">Empty</div></button>
                     <button class="slot-btn empty" data-slot="2"><div class="slot-label">2</div><div class="slot-info">Empty</div></button>
                     <button class="slot-btn empty" data-slot="3"><div class="slot-label">3</div><div class="slot-info">Empty</div></button>
                     <button class="slot-btn empty" data-slot="4"><div class="slot-label">4</div><div class="slot-info">Empty</div></button>
                     <button class="slot-btn empty" data-slot="5"><div class="slot-label">5</div><div class="slot-info">Empty</div></button>
                   </div>
                   <div class="desc" style="margin-top:3px; text-align:center;">
                     <span id="slot-mode-desc">Click to LOAD a saved game.</span>
                   </div>
                </div>

                <div class="row" style="margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1)">
                    <button class="btn" id="btn-export" style="flex:1; font-size:10px; padding:4px">Export Slot</button>
                    <button class="btn" id="btn-import" style="flex:1; font-size:10px; padding:4px">Import Slot</button>
                    <input type="file" id="file-import" style="display:none" accept=".json">
                </div>
              </div>
            </details>
            
          </div>
        </details>
      </div>

      <div class="card" id="advanced-card">
        <details>
          <summary><h2 style="display:inline; font-size:16px; margin:0">Advanced</h2></summary>
          <div class="details-content">
            
            <div style="background:rgba(255,100,100,0.1); border:1px solid rgba(255,100,100,0.3); border-radius:4px; padding:6px; margin-bottom:8px;" id="sim-mode-container">
              <label class="checkbox-wrapper" style="height:auto; padding:0; margin-bottom:4px">
                <input type="checkbox" id="chk-sim-mode">
                <span style="font-weight:600; color:var(--ruin)">Simulation Mode</span>
              </label>
              <div class="desc" style="margin:0; opacity:0.8">Enabling simulation mode will mark this run.</div>
              <div id="sim-mode-badge" style="display:none; margin-top:4px; padding:2px 6px; background:var(--ruin); color:var(--bg); border-radius:3px; font-size:9px; font-weight:800; text-align:center; letter-spacing:0.5px">
                ⚠ SIMULATION RUN
              </div>
            </div>
            
            <details id="submenu-auto-controls">
              <summary>Auto Controls</summary>
              <div class="details-content">
                <div class="row" style="align-items: center; gap: 4px;">
                  <button class="btn" id="auto" aria-keyshortcuts="A" style="flex:1; font-size:11px; padding:6px" disabled>Auto Play</button>
                  <label class="checkbox-wrapper" for="use-delay">
                    <input type="checkbox" id="use-delay">
                    <span>Delay</span>
                  </label>
                  <select id="speed" aria-label="Auto-play speed">
                    <option value="1000">Slow</option>
                    <option value="100" selected>Normal</option>
                    <option value="10">Fast</option>
                  </select>
                </div>
                <div class="row" style="margin-top:4px">
                  <input id="nRolls" type="number" value="20" aria-label="Number of rolls or cycles" style="width:40px">
                  <button class="btn" id="rollN" style="flex:1; font-size:10px; padding:6px" disabled>Roll N Steps</button>
                  <button class="btn" id="rollNCycles" style="flex:1; font-size:10px; padding:6px" disabled>Roll N Attempts</button>
                </div>
              </div>
            </details>
            
            <details id="submenu-set-state">
              <summary>Set Height / Poise</summary>
              <div class="details-content">
                <div class="row">
                  <span class="tiny" style="min-width:70px">Set H/P:</span>
                  <input id="set-k" type="number" min="1" value="1" aria-label="Set k value" style="width:40px" disabled>
                  <input id="set-l" type="number" min="0" value="0" aria-label="Set l value" style="width:40px" disabled>
                  <button class="btn" id="setStateBtn" style="padding:4px 8px; font-size:10px; flex:1" disabled>Set</button>
                </div>
              </div>
            </details>

            <details id="submenu-system">
              <summary>Main System Parameters</summary>
              <div class="details-content">
                <div class="row"><label for="M">M (Max Height)</label><input id="M" type="number" value="20"></div>
                <div class="desc">Max steps to win (k).</div>
                <div class="row"><label for="L">L (Max Poise)</label><input id="L" type="number" value="20"></div>
                <div class="desc">Poise scale (ℓ).</div>
                <div class="row"><label>w_min → w_max</label><input id="w_min" type="number" step="0.01" value="0.10"><input id="w_max" type="number" step="0.01" value="0.90"></div>
                <div class="desc">Win probability scaling.</div>
                <div class="row"><label for="beta">β (Height ramp)</label><input id="beta" type="number" step="0.1" value="1.5"></div>
                <div class="desc">β > 1 makes late ascent easier.</div>
                <div class="row"><label>ρ, γ (Poise boost)</label><input id="rho" type="number" step="0.05" value="0.6"><input id="gamma" type="number" step="0.1" value="1.5"></div>
                <div class="desc">Effect of Poise on win rate.</div>
                <div class="row"><label>c_min → c_max</label><input id="c_min" type="number" step="0.01" value="0.03"><input id="c_max" type="number" step="0.01" value="0.10"></div>
                <div class="desc">Loss probability range.</div>
                <div class="row"><label for="alpha">α (Loss decay)</label><input id="alpha" type="number" step="0.1" value="0.3"></div>
                <div class="desc">How fast Poise reduces loss chance.</div>
                <div class="row"><label>g_n, s_w</label><input id="g_n" type="number" value="1"><input id="s_w" type="number" value="20"></div>
                <div class="desc">Poise gain (Steady) vs spend (Ascent).</div>
              </div>
            </details>

            <details id="submenu-weather">
                <summary>Weather System</summary>
                <div class="details-content">
                    <div class="row"><label for="chaos_dt">Dt (Chaos Step)</label><input id="chaos_dt" type="number" step="0.001" value="0.0025"></div>
                    <div class="desc">Simulation speed (Time Step).</div>
                    <div class="row"><label for="chaos_intensity">Intensity</label><input id="chaos_intensity" type="number" step="0.1" value="1.0"></div>
                    <div class="desc">Magnitude of time dilation.</div>
                    <div class="row"><label for="max_delay">Max Delay (s)</label><input id="max_delay" type="number" step="0.1" value="45.0"></div>
                    <div class="desc">Base cooldown time.</div>
                </div>
            </details>
            
            <div class="row" style="margin-top:6px; padding-top:6px; border-top:1px solid rgba(255,255,255,0.1); justify-content: flex-end;">
                <label class="checkbox-wrapper" style="margin-right:auto;">
                    <input type="checkbox" id="chk-reset-on-apply" checked>
                    <span>Reset on Apply</span>
                </label>
                <button class="btn" id="apply" style="flex:1; font-size:11px; padding:6px" disabled>Apply Params</button>
                <button class="btn" id="resetState" aria-keyshortcuts="R" style="flex:1; opacity:0.8; font-size:11px; padding:6px; background:#440000; color:#ffcccc">Reset Run</button>
            </div>

          </div>
        </details>
      </div>

    </div>
  </div>
</div>

<script>

const THEMES = {
  default: {
    '--bg': '#080014', '--text': '#fef8ff', '--muted': '#d8d8d4',
    '--ascent': '#ff9e2c', '--poise': '#ff00b8', '--steady': '#00b7ff',
    '--ruin': '#ff3333', '--summit': '#ffea00',
    '--card-bg': 'rgba(12, 0, 32, 0.6)', '--card-border': 'rgba(255,255,255,0.05)',
    '--bg-image': 'radial-gradient(900px 700px at 50% -200px, rgba(255,0,200,.15), transparent 70%), radial-gradient(900px 700px at 50% 120%, rgba(0,200,255,.12), transparent 70%), linear-gradient(180deg,#0b0014 0%, #050010 100%)'
  },
  magma: {
    '--bg': '#1a0500', '--text': '#ffe0d0', '--muted': '#ffcc00', 
    '--ascent': '#ffcc00', '--poise': '#ff4400', '--steady': '#ff8800',
    '--ruin': '#ff0000', '--summit': '#ffcc00',
    '--card-bg': 'rgba(40, 5, 0, 0.7)', '--card-border': 'rgba(255, 100, 0, 0.2)',
    '--bg-image': 'radial-gradient(circle at 50% 0%, rgba(255,200,0,0.2), transparent 60%), linear-gradient(0deg, #1a0500 0%, #3d0c02 100%)'
  },
terminal: {
    '--bg': '#050505', 
    '--text': '#00ff41',       /* Classic Phosphor Green */
    '--muted': '#5c9e60',      /* BRIGHTER muted green for readability */
    '--ascent': '#00ff41',     /* Green */
    '--poise': '#008f11',      /* Dim Green */
    '--steady': '#00e5ff',     /* Cyan (Distinct from Ascent) */
    '--ruin': '#ff3333',       /* Alert Red */
    '--summit': '#ffff00',     /* Amber/Gold */
    '--card-bg': 'rgba(10, 25, 10, 0.9)', 
    '--card-border': '#1f5c22',
    /* Scanline effect */
    '--bg-image': 'linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06))'
  },
  paper: {
    '--bg': '#ffffff', 
    '--text': '#212529',       /* Dark Slate/Almost Black */
    '--muted': '#6c757d',      /* Mid-Gray (High Contrast) */
    '--ascent': '#0d6efd',     /* Ballpoint Blue */
    '--poise': '#6610f2',      /* Indigo Ink */
    '--steady': '#17a2b8',     /* Teal/Cyan Ink */
    '--ruin': '#dc3545',       /* Grading Red */
    '--summit': '#198754',     /* Success Green */
    '--card-bg': 'rgba(255, 255, 255, 0.95)', 
    '--card-border': '#dee2e6', /* Light Gray border */
    /* Graph paper grid */
    '--bg-image': 'linear-gradient(#e5e5e5 1px, transparent 1px), linear-gradient(90deg, #e5e5e5 1px, transparent 1px)',
    'background-size': '20px 20px' /* Ensures the grid looks like graph paper */
  },
  ocean: {
    '--bg': '#000814', '--text': '#e0f7ff', '--muted': '#00ffcc',
    '--ascent': '#00d9ff', '--poise': '#0055ff', '--steady': '#0088ff',
    '--ruin': '#ff3333', '--summit': '#00ffcc',
    '--card-bg': 'rgba(0, 10, 30, 0.6)', '--card-border': 'rgba(0,180,255,0.1)',
    '--bg-image': 'radial-gradient(circle at 50% 100%, rgba(0,255,180,0.15), transparent 70%), linear-gradient(180deg, #000814 0%, #001a33 100%)'
  }
};

/* -------------------------------------------------------------------------- */
/* MODULE 0: UTILITIES & COLOR MATH                                           */
/* -------------------------------------------------------------------------- */

class ColorMath {
  static lerp(min, max, t) { return min + (max - min) * t; }

  static oklab_to_linear_srgb(L, a, b) {
    let l_ = L + 0.3963377774 * a + 0.2158037573 * b;
    let m_ = L - 0.1055613458 * a - 0.0638541728 * b;
    let s_ = L - 0.0894841775 * a - 1.2914855480 * b;

    let l = l_ * l_ * l_;
    let m = m_ * m_ * m_;
    let s = s_ * s_ * s_;

    return [
      (+4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s),
      (-1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s),
      (-0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s),
    ];
  }

  static oklch_to_oklab(L, c, h) {
    return [(L), (c * Math.cos(h)), (c * Math.sin(h))];
  }

  static rgbToHex(r, g, b) {
    const toHex = (n) => {
      const hex = Math.max(0, Math.min(255, Math.round(n))).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    };
    return '#' + toHex(r) + toHex(g) + toHex(b);
  }

  static generateColor(L, C, H) {
    let lab = this.oklch_to_oklab(L, C, H);
    let rgb = this.oklab_to_linear_srgb(lab[0], lab[1], lab[2]);
    const gamma = (v) => Math.pow(Math.max(0, Math.min(1, v)), 1/2.2) * 255;
    return this.rgbToHex(gamma(rgb[0]), gamma(rgb[1]), gamma(rgb[2]));
  }

  static generatePalette(mode) {
    const settings = {
      hueBase: Math.random() * 2 * Math.PI, 
      hueContrast: this.lerp(0.33, 1.0, Math.random()),
      chromaBase: this.lerp(0.01, 0.1, Math.random()),
      chromaContrast: this.lerp(0.075, 0.125, Math.random()),
      lightnessBase: this.lerp(0.3, 0.6, Math.random()),
      fixed: Math.random()
    };

    const colors = [];
    const count = 5; 

    for (let i = 0; i < count; ++i) {
      let linearIterator = i / (count - 1);
      let hueOffset = linearIterator * settings.hueContrast * 2 * Math.PI + (Math.PI / 4);
      
      if (mode === "monochromatic") hueOffset *= 0.0;
      if (mode === "analogous") hueOffset *= 0.25;
      if (mode === "complementary") hueOffset *= 0.33;
      if (mode === "triadic") hueOffset *= 0.66;
      if (mode === "tetradic") hueOffset *= 0.75;

      if (mode !== "monochromatic") hueOffset += (Math.random() * 2 - 1) * 0.01;

      let chroma = settings.chromaBase + linearIterator * settings.chromaContrast + 0.05;
      let lightness = Math.max(0.6, settings.lightnessBase + (Math.random() * 0.2)); 

      colors.push({
        hex: this.generateColor(lightness, chroma, settings.hueBase + hueOffset),
        hue: settings.hueBase + hueOffset
      });
    }

    const bg = this.generateColor(0.05, 0.02, settings.hueBase);
    const cardBg = this.generateColor(0.12, 0.02, settings.hueBase); 
    const cardBorder = this.generateColor(0.2, 0.0, settings.hueBase);
    const text = this.generateColor(0.95, 0.02, settings.hueBase);
    
    // Order: Ascent, Summit, Steady, Poise, Ruin
    // Muted derived from Summit (colors[1])
    const summitHue = colors[1].hue;
    const muted = this.generateColor(0.65, 0.05, summitHue);

    return {
      '--bg': bg,
      '--card-bg': cardBg, 
      '--card-border': cardBorder,
      '--text': text,
      '--muted': muted,
      '--ascent': colors[0].hex,
      '--summit': colors[1].hex,
      '--steady': colors[2].hex,
      '--poise': colors[3].hex,
      '--ruin': colors[4].hex,
      '--bg-image': `radial-gradient(circle at 50% 0%, ${colors[2].hex}22, transparent 60%), linear-gradient(0deg, ${bg} 0%, ${bg} 100%)`
    };
  }
}

class BackgroundTimer {
  constructor() {
    const blob = new Blob([`
      const timers = new Map();
      self.onmessage = function(e) {
        const { id, type, delay } = e.data;
        if (type === 'clear') {
          const t = timers.get(id);
          if (t) { clearTimeout(t); clearInterval(t); timers.delete(id); }
        } else if (type === 'setTimeout') {
          const t = setTimeout(() => { self.postMessage({ id, type: 'timeout' }); timers.delete(id); }, delay);
          timers.set(id, t);
        } else if (type === 'setInterval') {
          const t = setInterval(() => { self.postMessage({ id, type: 'interval' }); }, delay);
          timers.set(id, t);
        }
      };
    `], { type: 'application/javascript' });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.callbacks = new Map();
    this.nextId = 1;
    this.worker.onmessage = (e) => {
      const cb = this.callbacks.get(e.data.id);
      if (cb) cb();
    };
  }
  setTimeout(cb, d) {
    const id = this.nextId++; this.callbacks.set(id, cb);
    this.worker.postMessage({ id, type: 'setTimeout', delay: d });
    return id;
  }
  setInterval(cb, d) {
    const id = this.nextId++; this.callbacks.set(id, cb);
    this.worker.postMessage({ id, type: 'setInterval', delay: d });
    return id;
  }
  clear(id) {
    if (!id) return;
    this.worker.postMessage({ id, type: 'clear' });
    this.callbacks.delete(id);
  }
}

class ProbabilityCache {
  constructor(maxSize = 400) {
    this.cache = new Map();
    this.maxSize = maxSize;
    this.hits = 0; this.misses = 0;
  }
  makeKey(k, l, p) {
    return `${k},${l},${p.w_min},${p.w_max},${p.beta},${p.rho},${p.gamma},${p.c_min},${p.c_max},${p.alpha},${p.M},${p.L}`;
  }
  get(k, l, p) {
    const key = this.makeKey(k, l, p);
    const result = this.cache.get(key);
    if (result) { this.hits++; return result; }
    this.misses++; return null;
  }
  set(k, l, p, probs) {
    if (this.cache.size >= this.maxSize) this.cache.delete(this.cache.keys().next().value);
    this.cache.set(this.makeKey(k, l, p), probs);
    return probs;
  }
  clear() { this.cache.clear(); this.hits=0; this.misses=0; }
  getStats() { return { hitRate: this.hits / (this.hits + this.misses) || 0 }; }
}

class AriaAnnouncer {
  constructor() { 
      this.element = document.getElementById('aria-announcer'); 
      this.timeout = null; // Track the timer
  }
  
  announce(msg) {
    // Clear pending clear-text timer
    if (this.timeout) clearTimeout(this.timeout);
    
    this.element.textContent = msg;
    
    // Set new timer
    this.timeout = setTimeout(() => { 
        this.element.textContent = ''; 
        this.timeout = null;
    }, 1000);
  }
}

class PerformanceMonitor {
  constructor() {
    this.frameCount = 0; this.lastTime = performance.now(); this.fps = 0;
    this.element = document.getElementById('perf-indicator');
  }
  tick() {
    this.frameCount++;
    const now = performance.now();
    const delta = now - this.lastTime;
    if (delta >= 1000) {
      this.fps = Math.round(this.frameCount * 1000 / delta);
      this.frameCount = 0; this.lastTime = now;
      this.update();
    }
  }
  update() {
    const cs = SisyphusMath.probCache.getStats();
    this.element.textContent = `FPS: ${this.fps} | Cache: ${(cs.hitRate * 100).toFixed(0)}%`;
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 1: SISYPHUS MATH                                                   */
/* -------------------------------------------------------------------------- */
class SisyphusMath {
  static EPSILON = 1e-10;
  static probCache = new ProbabilityCache();
  
  static computeProbs(k, l, p) {
    const cached = this.probCache.get(k, l, p);
    if (cached) return cached;
    
    k = Math.round(k); l = Math.round(l);
    const M = Math.max(1, p.M | 0);
    const L = Math.max(1, p.L | 0);
    const frac = M > 1 ? (k - 1) / (M - 1) : 1;
    
    const base = p.w_min + (p.w_max - p.w_min) * Math.pow(frac, p.beta);
    const ell = (1 - p.rho) + p.rho * Math.pow(l / L, p.gamma);
    
    let p_win = Math.min(1, Math.max(0, base * ell));
    let p_loss = p.c_min + (p.c_max - p.c_min) * Math.exp(-p.alpha * l);
    
    const sum = p_win + p_loss;
    if (sum > 1 + this.EPSILON) { p_win /= sum; p_loss /= sum; }
    else if (sum > 1) { const scale = 1/sum; p_win *= scale; p_loss *= scale; }
    
    let p_neu = Math.max(0, 1 - p_win - p_loss);
    const total = p_win + p_neu + p_loss;
    if (Math.abs(total - 1) > this.EPSILON) { p_win/=total; p_neu/=total; p_loss/=total; }
    
    const result = { p_win, p_neu, p_loss };
    this.probCache.set(k, l, p, result);
    return result;
  }

  static getDelay(k, l, p) {
    if (p.max_delay <= 0) return 0;
    const kRatio = Math.max(0, (k - 1) / (p.M - 1 || 1));
    const lRatio = Math.max(0, l / (p.L || 1));
    const reduction = (0.8 * kRatio) + (0.2 * lRatio);
    const ms = (p.max_delay * 1000) * Math.pow(1 - Math.min(1, reduction), 3);
    if (ms < 20) return 0;
    return Math.max(100, ms); 
  }
  
  static clearCache() { this.probCache.clear(); }

  static solveExpectations(p) {
    const M = Math.max(1, p.M | 0);
    const L = Math.max(0, p.L | 0);
    
    const createGrid = () => Array.from({length: M + 1}, () => new Float64Array(L + 1));
    const TopHit = createGrid();
    const CycleLen = createGrid();
    const WinCount = createGrid();
    const TimeLen = createGrid();
    
    const maxIter = 400, tol = 1e-6;
    const lossDelay = SisyphusMath.getDelay(1, 0, p) / 1000;
    const s_w = p.s_w;
    const g_n = p.g_n;

    for (let it = 0; it < maxIter; it++) {
      let maxDiff = 0;
      for (let k = 1; k <= M; k++) {
        for (let l = 0; l <= L; l++) {
          const {p_win, p_neu, p_loss} = SisyphusMath.computeProbs(k, l, p);
          
          const l_win = (l - s_w) < 0 ? 0 : (l - s_w);
          const l_neu = (l + g_n) > L ? L : (l + g_n);

          let valTop = 0, valCyc = 0, valWin = 0, valTime = 0;
          
          if (k === M) {
             valTop = p_win + p_neu * TopHit[M][l_neu];
             valCyc = 1 + p_neu * CycleLen[M][l_neu];
             valWin = p_win + p_neu * WinCount[M][l_neu];
             const delayNeu = SisyphusMath.getDelay(k, l_neu, p) / 1000;
             const stepCost = (p_neu * delayNeu) + (p_loss * lossDelay); 
             valTime = stepCost + p_neu * TimeLen[M][l_neu];
          } else {
             valTop = p_win * TopHit[k+1][l_win] + p_neu * TopHit[k][l_neu];
             valCyc = 1 + p_win * CycleLen[k+1][l_win] + p_neu * CycleLen[k][l_neu];
             valWin = p_win * (1 + WinCount[k+1][l_win]) + p_neu * WinCount[k][l_neu];
             const delayWin = SisyphusMath.getDelay(k+1, l_win, p) / 1000;
             const delayNeu = SisyphusMath.getDelay(k, l_neu, p) / 1000;
             const stepCost = (p_win * delayWin) + (p_neu * delayNeu) + (p_loss * lossDelay);
             valTime = stepCost + p_win * TimeLen[k+1][l_win] + p_neu * TimeLen[k][l_neu];
          }

          const diff = Math.abs(valTop - TopHit[k][l]);
          if(diff > maxDiff) maxDiff = diff;
          
          TopHit[k][l] = valTop;
          CycleLen[k][l] = valCyc;
          WinCount[k][l] = valWin;
          TimeLen[k][l] = valTime;
        }
      }
      if (maxDiff < tol) break;
    }
    return { TopHit, CycleLen, WinCount, TimeLen };
  }

  static getQuantiles(data) {
    if (!data || data.length === 0) return null;
    const sorted = [...data].sort((a, b) => a - b);
    const q = (p) => {
      const pos = (sorted.length - 1) * p;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base + 1] !== undefined) return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
      return sorted[base];
    };
    return { min: sorted[0], q25: q(0.25), med: q(0.50), q75: q(0.75), max: sorted[sorted.length - 1] };
  }
	static getQuantilesFromHistogram(hist) {
  if (!hist || !hist.freq) return null;

  // Convert freq object → sorted [{value, count}, ...]
  const entries = Object.entries(hist.freq)
    .map(([k, v]) => ({ value: parseFloat(k), count: v | 0 }))
    .filter(e => !Number.isNaN(e.value) && e.count > 0)
    .sort((a, b) => a.value - b.value);

  if (!entries.length) return null;

  let total = hist.total || 0;
  if (!total) {
    total = entries.reduce((sum, e) => sum + e.count, 0);
    if (!total) return null;
  }

  const min = entries[0].value;
  const max = entries[entries.length - 1].value;

  const valueAt = (p) => {
    const target = p * total;
    let cum = 0;
    for (const e of entries) {
      cum += e.count;
      if (cum >= target) return e.value;
    }
    return max;
  };

  return {
    min,
    q25: valueAt(0.25),
    med: valueAt(0.5),
    q75: valueAt(0.75),
    max
  };
}

}

/* -------------------------------------------------------------------------- */
/* MODULE 2: GAME MODEL                                                      */
/* -------------------------------------------------------------------------- */
class SisyphusModel {
  constructor() {
    this.params = {
      M:20, L:20, w_min:0.10, w_max:0.90, beta:1.5, rho:0.6, gamma:1.5,
      c_min:0.03, c_max:0.10, alpha:0.3, g_n:1, s_w:20, 
      max_delay: 45.0, chaos_dt: 0.0025, chaos_intensity: 1.0
    };
    this.reset();
  }

reset() {
  this.state = { k:1, l:0, step:0, topHit:false, cycleSteps:0, isSimulation:false };
  this.stats = { wins:0, neus:0, loss:0, maxK:1, longestCycle:0 };
  this.historyK = [];
  this.cycleId = 1;
  this.currentCycle = this._newCycle();
  this.cycleSummaries = []; 

  // Attempt durations as histogram: length -> count
  this.allCycles = {
    freq: {},   // { length: count }
    total: 0    // total number of completed cycles
  };

  this.startTime = Date.now();
  const M = Math.max(1, this.params.M);
  const L = Math.max(0, this.params.L);
  this.distributions = { 
    k: Array(M+1).fill(0), 
    l: Array(L+1).fill(0), 
    kl: Array.from({length: M+1}, () => Array(L+1).fill(0)),
    cycles: [], // still keep the last ~40 raw lengths for the sparkline / hist UI
    weatherOnPress: { calm: 0, windy: 0, storm: 0 },

    // Time dilation on press as histogram, bucketed to nearest 0.01% (0.0001 in factor)
    // freq keys are strings like "0.9999", "1.0000", "1.0001"
    dilationOnPress: {
      freq: {},
      total: 0
    }
  };
  this.lastRoll = null; 
}


  _newCycle() { return { id: this.cycleId, length:0, wins:0, neus:0, maxK:this.state.k, path:'' }; }

  step() {
    if (this.state.topHit) return null;
    const k0 = this.state.k, l0 = this.state.l;
    const probs = SisyphusMath.computeProbs(k0, l0, this.params);
    const r = Math.random();
    
    let outcome = 'loss';
    let k1 = 1, l1 = 0;

    if (r < probs.p_win) {
      if (k0 === this.params.M) { outcome = 'top'; k1 = k0; l1 = l0; this.state.topHit = true; } 
      else { outcome = 'win'; k1 = Math.min(this.params.M, k0 + 1); l1 = Math.max(0, l0 - this.params.s_w); }
    } else if (r < probs.p_win + probs.p_neu) {
      outcome = 'neu'; k1 = k0; l1 = Math.min(this.params.L, l0 + this.params.g_n);
    }

    this.state.k = k1; this.state.l = l1; this.state.step++; this.state.cycleSteps++;
    
    if (outcome === 'win' || outcome === 'top') this.stats.wins++;
    else if (outcome === 'neu') this.stats.neus++;
    else if (outcome === 'loss') this.stats.loss++;

    if (outcome === 'loss' || outcome === 'top') {
      if (this.state.cycleSteps > this.stats.longestCycle) this.stats.longestCycle = this.state.cycleSteps;
      if (outcome === 'loss') this.state.cycleSteps = 0;
    }

    this.stats.maxK = Math.max(this.stats.maxK, k1);
    this.historyK.push(k1);
    if (this.historyK.length > 200) this.historyK.shift();

    this._updateCycle(outcome, k1);
    this._updateDistributions(k1, l1);

    this.lastRoll = { outcome, k0, l0, k1, l1, rng: r };
    return outcome;
  }

  _updateDistributions(k, l) {
    const d = this.distributions;
    if (d.k[k] !== undefined) d.k[k]++;
    if (d.l[l] !== undefined) d.l[l]++;
    if (d.kl[k] && d.kl[k][l] !== undefined) d.kl[k][l]++;
  }

  recordWeatherOnPress(condition, dilation) {
  const d = this.distributions;

  // Count condition
  if (d.weatherOnPress[condition] !== undefined) {
    d.weatherOnPress[condition]++;
  }

  // Bucket dilation to nearest 0.01% ≈ 0.0001 in multiplicative factor
  // Example: 1.000037 → 1.0000, 1.00006 → 1.0001, etc.
  const bucketVal = Math.round(dilation * 10000) / 10000;
  const key = bucketVal.toFixed(4); // store as string key

  if (!d.dilationOnPress.freq[key]) d.dilationOnPress.freq[key] = 0;
  d.dilationOnPress.freq[key]++;
  d.dilationOnPress.total++;
}


_updateCycle(outcome, k1) {
  const sym = { win:'▲', neu:'◆', loss:'▼', top:'★' }[outcome];
  if (sym) {
    this.currentCycle.length++;
    if (outcome === 'win') this.currentCycle.wins++;
    if (outcome === 'neu') this.currentCycle.neus++;
    this.currentCycle.maxK = Math.max(this.currentCycle.maxK, k1);
    this.currentCycle.path += sym;
  }

  if (outcome === 'loss' || outcome === 'top') {
    const len = this.currentCycle.length;

    // Update global attempt-duration histogram
    if (!this.allCycles.freq[len]) this.allCycles.freq[len] = 0;
    this.allCycles.freq[len]++;
    this.allCycles.total++;

    // Keep last ~40 raw lengths for the per-run cycles distribution UI
    this.distributions.cycles.push(len);
    if (this.distributions.cycles.length > 40) this.distributions.cycles.shift();

    // Store summary
    const summary = { ...this.currentCycle, outcome };
    this.cycleSummaries.unshift(summary);
    if (this.cycleSummaries.length > 100) this.cycleSummaries.pop();

    this.cycleId++;
    this.currentCycle = this._newCycle();
  }
}


  setState(k, l) {
    this.state.k = Math.max(1, Math.min(this.params.M, k));
    this.state.l = Math.max(0, Math.min(this.params.L, l));
    this.historyK.push(this.state.k);
    this.lastRoll = {
      outcome: null,
      k0: this.state.k,
      l0: this.state.l,
      k1: this.state.k, 
      l1: this.state.l,
      rng: 0
    };
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 3: UI MANAGER                                                       */
/* -------------------------------------------------------------------------- */
class SisyphusUI {
  constructor(model) {
    this.model = model;
    this.els = {};
    this.pendingUpdates = new Map();
    this.rafId = null;
    
    ['rbar-win','rbar-neu','rbar-loss','rpct-win','rpct-neu','rpct-loss',
     'kpos-fill','kpos-text','lpos-fill','lpos-text','recent-p-cond','recent-p-top',
     'recent-outcome','recent-kl','recent-card',
     'bar-win','bar-neu','bar-loss','c-win','c-neu','c-loss',
     'r-win','r-neu','r-loss','run-steps','run-time','max-k',
     'bar-calm','bar-windy','bar-storm','c-calm','c-windy','c-storm',
     'r-calm','r-windy','r-storm',
     'cycle-box','hist-k','hist-l','hist-kl',
     'global-n','gs-min','gs-25','gs-50','gs-75','gs-max',
     'dilation-n','ds-min','ds-25','ds-50','ds-75','ds-max',
     'exp-win-rate', 'exp-loss-rate', 'exp-cycle-len', 'exp-time-top', 'exp-wins-hour',
     'btn-roll-main', 'rng-marker'
    ].forEach(id => this.els[id] = document.getElementById(id));
  }
  
resetMarker() {
    const m = this.els['rng-marker'];
    if (!m) return;
    
    // Strip all animation and status classes
    m.classList.remove('visible', 'tension', 'mark-win', 'mark-neu', 'mark-loss', 'mark-top');
    
    // Reset position instantly without transition
    m.style.transition = 'none';
    m.style.left = '0%';
    
    // Force reflow to ensure the visual update happens immediately
    void m.offsetWidth;
  }
  batchUpdate(elementId, property, value) {
    if (!this.pendingUpdates.has(elementId)) this.pendingUpdates.set(elementId, {});
    this.pendingUpdates.get(elementId)[property] = value;
    if (!this.rafId) this.rafId = requestAnimationFrame(() => this.flushUpdates());
  }
  
  flushUpdates() {
    this.pendingUpdates.forEach((updates, elementId) => {
      const el = this.els[elementId];
      if (!el) return;
      for (const [prop, value] of Object.entries(updates)) {
        if (prop === 'textContent') el.textContent = value;
        else if (prop === 'className') el.className = value;
        else if (prop.startsWith('style.')) el.style[prop.substring(6)] = value;
      }
    });
    this.pendingUpdates.clear();
    this.rafId = null;
  }

  log(msg) {} 

  _formatDuration(ms) {
    const s = Math.floor(ms / 1000);
    if(s < 60) return `${s}s`;
    const m = Math.floor(s / 60);
    if(m < 60) return `${m}m ${s%60}s`;
    const h = Math.floor(m / 60);
    if(h < 24) return `${h}h ${m%60}m`;
    const d = Math.floor(h / 24);
    return `${d}d ${h%24}h`;
  }


  render(grids, full = true, skipBars = false, updateProbs = true) {
    const m = this.model, s = m.state, st = m.stats;
    const lr = m.lastRoll || { outcome:null, k0:1, l0:0, k1:s.k, l1:s.l };
    const pct = x => (100 * Math.max(0, Math.min(1, x))).toFixed(1) + '%';
        const probs = SisyphusMath.computeProbs(lr.k1, lr.l1, m.params);
    

    this.batchUpdate('recent-outcome', 'textContent', lr.outcome ? (lr.outcome === 'neu' ? 'STEADY' : lr.outcome === 'loss' ? 'RUIN' : lr.outcome === 'top' ? 'SUMMIT' : 'ASCENT') : '—');
    this.batchUpdate('recent-card', 'className', 'card recent ' + (lr.outcome === 'top' ? 'win' : lr.outcome || ''));


    if (updateProbs) {
        this.batchUpdate('rbar-win', 'style.width', pct(probs.p_win));
        this.batchUpdate('rbar-neu', 'style.width', pct(probs.p_neu));
        this.batchUpdate('rbar-loss', 'style.width', pct(probs.p_loss));
        this.batchUpdate('rpct-win', 'textContent', pct(probs.p_win));
        this.batchUpdate('rpct-neu', 'textContent', pct(probs.p_neu));
        this.batchUpdate('rpct-loss', 'textContent', pct(probs.p_loss));

        const p_cond = (probs.p_win + probs.p_loss > 0) ? probs.p_win / (probs.p_win + probs.p_loss) : 0;
        this.batchUpdate('recent-p-cond', 'textContent', (probs.p_win+probs.p_loss < 1e-9) ? '—' : pct(p_cond));

        let pTopText = '—';
        if (grids && grids.TopHit && grids.TopHit[lr.k1] && typeof grids.TopHit[lr.k1][lr.l1] === 'number') {
            const p = grids.TopHit[lr.k1][lr.l1];
            const odds = p > 0 ? 1/p : Infinity;
            if (p < 0.0001) pTopText = `1 in ${odds > 1e6 ? odds.toExponential(2) : Math.round(odds).toLocaleString()}`;
            else if (p <= 0.5) pTopText = `1 in ${Math.round(odds).toLocaleString()} (${(p*100).toFixed(2)}%)`;
            else pTopText = `${(p*100).toFixed(1)}%`;
        }
        this.batchUpdate('recent-p-top', 'textContent', pTopText);
    }

    if (!skipBars) {
      this.batchUpdate('kpos-fill', 'style.width', pct(lr.k1 / m.params.M));
      this.batchUpdate('kpos-text', 'textContent', `${lr.k1} / ${m.params.M}`);
      this.batchUpdate('lpos-fill', 'style.width', pct(lr.l1 / m.params.L));
      this.batchUpdate('lpos-text', 'textContent', `${lr.l1} / ${m.params.L}`);
      this.batchUpdate('kpos-fill', 'style.transition', 'none');
      this.batchUpdate('lpos-fill', 'style.transition', 'none');
    }

    const tot = st.wins + st.neus + st.loss;
    this.batchUpdate('run-steps', 'textContent', s.step);
    this.batchUpdate('c-win', 'textContent', st.wins);
    this.batchUpdate('c-neu', 'textContent', st.neus);
    this.batchUpdate('c-loss', 'textContent', st.loss);
    this.batchUpdate('r-win', 'textContent', tot ? (100*st.wins/tot).toFixed(1)+'%' : '0%');
    this.batchUpdate('r-neu', 'textContent', tot ? (100*st.neus/tot).toFixed(1)+'%' : '0%');
    this.batchUpdate('r-loss', 'textContent', tot ? (100*st.loss/tot).toFixed(1)+'%' : '0%');
    
    this.batchUpdate('bar-win', 'style.width', tot ? (100*st.wins/tot)+'%' : '0%');
    this.batchUpdate('bar-neu', 'style.width', tot ? (100*st.neus/tot)+'%' : '0%');
    this.batchUpdate('bar-loss', 'style.width', tot ? (100*st.loss/tot)+'%' : '0%');
    
    const wop = m.distributions.weatherOnPress;
    const wtot = wop.calm + wop.windy + wop.storm;
    this.batchUpdate('c-calm', 'textContent', wop.calm);
    this.batchUpdate('c-windy', 'textContent', wop.windy);
    this.batchUpdate('c-storm', 'textContent', wop.storm);
    this.batchUpdate('r-calm', 'textContent', wtot ? (100*wop.calm/wtot).toFixed(1)+'%' : '0.0%');
    this.batchUpdate('r-windy', 'textContent', wtot ? (100*wop.windy/wtot).toFixed(1)+'%' : '0.0%');
    this.batchUpdate('r-storm', 'textContent', wtot ? (100*wop.storm/wtot).toFixed(1)+'%' : '0.0%');
    this.batchUpdate('bar-calm', 'style.width', wtot ? (100*wop.calm/wtot)+'%' : '0%');
    this.batchUpdate('bar-windy', 'style.width', wtot ? (100*wop.windy/wtot)+'%' : '0%');
    this.batchUpdate('bar-storm', 'style.width', wtot ? (100*wop.storm/wtot)+'%' : '0%');
    
    this.batchUpdate('run-time', 'textContent', this._formatDuration(Math.max(0, Date.now() - m.startTime)));
    this.batchUpdate('max-k', 'textContent', st.maxK);
    
    this._renderCycles();
    if(full) { this._renderDistributions(); this._renderGlobalStats(); }
  }

  animateChange(k0, l0, k1, l1, duration, params) {
    const kFill = this.els['kpos-fill'];
    const lFill = this.els['lpos-fill'];
    const kText = this.els['kpos-text'];
    const lText = this.els['lpos-text'];
    
    const pK0 = (100 * Math.max(0, Math.min(1, k0 / params.M))).toFixed(2) + '%';
    const pL0 = (100 * Math.max(0, Math.min(1, l0 / params.L))).toFixed(2) + '%';
    const pK1 = (100 * Math.max(0, Math.min(1, k1 / params.M))).toFixed(2) + '%';
    const pL1 = (100 * Math.max(0, Math.min(1, l1 / params.L))).toFixed(2) + '%';

    kFill.classList.remove('active-motion', 'reverse-motion');
    lFill.classList.remove('active-motion', 'reverse-motion');
    
    kFill.style.transition = 'none';
    lFill.style.transition = 'none';
    kFill.style.width = pK0;
    lFill.style.width = pL0;
    
    if (k0 !== k1) kText.textContent = `${k0} → ${k1} / ${params.M}`;
    if (l0 !== l1) lText.textContent = `${l0} → ${l1} / ${params.L}`;

    void kFill.offsetWidth; 

    if (duration > 100) {
        if (k0 !== k1) {
            kFill.classList.add('active-motion');
            if (k1 < k0) kFill.classList.add('reverse-motion'); 
        }
        if (l0 !== l1) {
            lFill.classList.add('active-motion');
            if (l1 < l0) lFill.classList.add('reverse-motion'); 
        }
    }

    const transitionStr = `width ${duration}ms linear`;
    kFill.style.transition = transitionStr;
    lFill.style.transition = transitionStr;
    kFill.style.width = pK1;
    lFill.style.width = pL1;
    
    setTimeout(() => {
        kFill.classList.remove('active-motion', 'reverse-motion');
        lFill.classList.remove('active-motion', 'reverse-motion');
    }, duration);


  }
  
visualizeRoll(rng, duration, outcome) {
    return new Promise(resolve => {
      // 1. Reset Outcome Text to Null State
      if (this.els['recent-outcome']) {
          this.els['recent-outcome'].textContent = 'Awaiting Fate...';
      }

      // 2. Reset Card Styling
      if (this.els['recent-card']) {
          this.els['recent-card'].className = 'card recent';
      }

      const m = this.els['rng-marker'];
      if(!m) { resolve(); return; }

      // 3. Reset Marker State (White, hidden, no transition)
      m.classList.remove('visible', 'tension', 'mark-win', 'mark-neu', 'mark-loss', 'mark-top');
      m.style.transition = 'none';
      m.style.left = '0%';
      
      void m.offsetWidth; // Force reflow

      // 4. Start Animation (White circle moves)
      m.classList.add('visible', 'tension');
      
      // DRAMATIC EASE-IN-OUT
      m.style.transition = `left ${duration}ms cubic-bezier(0.85, 0, 0.15, 1), background-color 0.3s ease, transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)`; 
      
      // Position based on RNG (Left=100%, Right=0% visually due to logic, or vice versa depending on your math)
      // Based on previous code: Low RNG (Win) -> High % (Right). High RNG (Loss) -> Low % (Left).
      m.style.left = ((1 - rng) * 100).toFixed(2) + '%';
      
      setTimeout(() => {
          m.classList.remove('tension');
          
          // 5. Apply Final Color based on outcome
          if (outcome === 'win') m.classList.add('mark-win');
          else if (outcome === 'neu') m.classList.add('mark-neu');
          else if (outcome === 'loss') m.classList.add('mark-loss');
          else if (outcome === 'top') m.classList.add('mark-top');
          
          resolve();
      }, duration);
    });
  }
  
  _renderCycles() {
    const box = this.els['cycle-box'];
    const tpl = document.getElementById('tpl-cycle-entry');
    const fragment = document.createDocumentFragment();
    const current = this.model.currentCycle;
    if (current) {
        const clone = tpl.content.cloneNode(true);
        const div = clone.querySelector('.cycle-entry');
        div.classList.add('active'); 
        clone.querySelector('.cycle-main-text').textContent = `#${current.id}: ACTIVE`;
        clone.querySelector('.cycle-meta').textContent = `L:${current.length} A:${current.wins}`;
        let wrapped = '';
        for(let i=0; i<(current.path||'').length; i+=32) wrapped += current.path.slice(i, i+32) + '\n';
        clone.querySelector('.cycle-entry-path').textContent = wrapped || '-';
        fragment.appendChild(clone);
    }
    this.model.cycleSummaries.forEach(c => {
      const clone = tpl.content.cloneNode(true);
      const div = clone.querySelector('.cycle-entry');
      div.classList.add(c.outcome === 'top' ? 'top' : 'loss');
      const outText = c.outcome === 'top' ? 'SUMMIT' : 'RUIN';
      clone.querySelector('.cycle-main-text').textContent = `#${c.id}: ${outText}`;
      clone.querySelector('.cycle-meta').textContent = `L:${c.length} A:${c.wins}`;
      let wrapped = '';
      for(let i=0; i<(c.path||'').length; i+=32) wrapped += c.path.slice(i, i+32) + '\n';
      clone.querySelector('.cycle-entry-path').textContent = wrapped || '-';
      fragment.appendChild(clone);
    });
    box.innerHTML = ''; box.appendChild(fragment);
  }

_renderGlobalStats() {
  // Attempt durations (global) – histogram of cycle lengths
  const ac = this.model.allCycles;
  const attemptStats = SisyphusMath.getQuantilesFromHistogram(ac);
  this.els['global-n'].textContent = ac && typeof ac.total === 'number' ? ac.total : 0;

  if (attemptStats) {
    this.els['gs-min'].textContent = attemptStats.min;
    this.els['gs-25'].textContent = attemptStats.q25;
    this.els['gs-50'].textContent = attemptStats.med;
    this.els['gs-75'].textContent = attemptStats.q75;
    this.els['gs-max'].textContent = attemptStats.max;
  } else {
    ['gs-min','gs-25','gs-50','gs-75','gs-max'].forEach(id => this.els[id].textContent = '—');
  }

  // Time dilation on press – histogram of dilation factors (bucketed to 0.0001)
  const dop = this.model.distributions.dilationOnPress;
  const dilationStats = SisyphusMath.getQuantilesFromHistogram(dop);
  this.els['dilation-n'].textContent = dop && typeof dop.total === 'number' ? dop.total : 0;

  if (dilationStats) {
    this.els['ds-min'].textContent = dilationStats.min.toFixed(2) + 'x';
    this.els['ds-25'].textContent = dilationStats.q25.toFixed(2) + 'x';
    this.els['ds-50'].textContent = dilationStats.med.toFixed(2) + 'x';
    this.els['ds-75'].textContent = dilationStats.q75.toFixed(2) + 'x';
    this.els['ds-max'].textContent = dilationStats.max.toFixed(2) + 'x';
  } else {
    ['ds-min','ds-25','ds-50','ds-75','ds-max'].forEach(id => this.els[id].textContent = '—');
  }
}


  _renderDistributions() {
    const dist = this.model.distributions;
    const renderBar = (hostId, data) => {
      const host = this.els[hostId]; host.innerHTML = '';
      if(!data.length || !data.some(x=>x)) { host.textContent='—'; return; }
      const max = Math.max(...data.filter(n=>n));
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;align-items:flex-end;gap:2px';
      for(let i=(hostId==='hist-l'?0:1); i<data.length; i++){
        const bar = document.createElement('div');
        bar.style.cssText = `width:3px;border-radius:2px;background:linear-gradient(180deg,var(--steady),var(--ascent));`;
        bar.style.height = (6 + (max ? 24 * (data[i]||0) / max : 0)) + 'px';
        wrap.appendChild(bar);
      }
      host.appendChild(wrap);
    };
    renderBar('hist-k', dist.k); renderBar('hist-l', dist.l);

    const hostHM = this.els['hist-kl']; hostHM.innerHTML = '';
    const klData = dist.kl;
    let maxC = 0; klData.forEach(row => row.forEach(c => { if(c > maxC) maxC = c; }));
    
    if(maxC > 0) {
      const M = this.model.params.M;
      const L = this.model.params.L;
      const grid = document.createElement('div');
      grid.style.display = 'grid'; grid.style.gridTemplateColumns = `repeat(${M}, minmax(4px, 1fr))`; grid.style.gap = '1px';
      const logMax = Math.log(1+maxC);
      for(let l=L; l>=0; l--) {
        for(let k=1; k<=M; k++) {
          const c = (klData[k] && klData[k][l]) || 0;
          const cell = document.createElement('div');
          const alpha = c > 0 ? (0.2 + 0.8 * (Math.log(1+c)/logMax)) : 0.05;
          cell.style.background = `var(--ascent)`;
          cell.style.opacity = alpha.toFixed(3);
          cell.style.aspectRatio = '1/1'; cell.title = `(${k},${l}): ${c}`;
          grid.appendChild(cell);
        }
      }
      hostHM.appendChild(grid);

      const legend = document.createElement('div');
      legend.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-top:4px; font-size:9px; color:var(--muted); opacity:0.8';
      legend.innerHTML = `
        <span>Rare</span>
        <div style="flex:1; height:4px; margin:0 8px; border-radius:2px; background:linear-gradient(90deg, rgba(255,255,255,0.05), var(--ascent));"></div>
        <span>Frequent</span>
      `;
      hostHM.appendChild(legend);

    } else hostHM.textContent = '—';
  }

  updateExpectations(grids) {
    const { TopHit, CycleLen, WinCount, TimeLen } = grids;
    const pCycleTop = TopHit[1][0];
    const c = CycleLen[1][0];
    const w = WinCount[1][0];
    const timePerCycle = TimeLen[1][0];
    const fmt = x => (100*x).toFixed(3)+'%';
    const el = id => document.getElementById(id);
    
    if(c > 0) {
      el('exp-win-rate').textContent = fmt(w/c);
      el('exp-loss-rate').textContent = fmt((1-pCycleTop)/c);
      el('exp-cycle-len').textContent = c.toFixed(1);
      
      if (pCycleTop > 1e-15) { 
        const expected = c / pCycleTop;
        el('exp-time-top').textContent = expected > 1e9 ? expected.toExponential(2) : expected.toFixed(1);
        if (this.model.params.max_delay <= 0) el('exp-wins-hour').textContent = "--";
        else el('exp-wins-hour').textContent = timePerCycle > 0.0001 ? ((w / timePerCycle) * 3600).toFixed(2) : "--";
      } else {
        if (pCycleTop === 0) { el('exp-time-top').textContent = '∞ (prob ≈ 0)'; el('exp-wins-hour').textContent = '0.00'; }
        else {
           el('exp-time-top').textContent = (c/pCycleTop).toExponential(2);
           el('exp-wins-hour').textContent = timePerCycle > 0.0001 ? ((w / timePerCycle) * 3600).toFixed(2) : "--";
        }
      }
    }
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 4: CHAOS ENGINE                                                    */
/* -------------------------------------------------------------------------- */
class ChaosEngine {
  constructor() {
    this.canvas = document.getElementById('chaosCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.statusEl = document.getElementById('weather-status-main');
    this.modEl = document.getElementById('weather-mod-val');
    
    this.SIGMA = 10; this.RHO = 28; this.BETA = 8/3; 
    
    this.x = 10 + (Math.random() - 0.5) * 2; 
    this.y = 10 + (Math.random() - 0.5) * 2; 
    this.z = 25 + (Math.random() - 0.5) * 2;

    this.MAX_POINTS = 10000;
    this.points = new Array(this.MAX_POINTS).fill(null);
    this.head = 0; 
    this.count = 0; 
    
    this.angle = 0; this.rotSpeed = 0.005; 
    this.scale = 9; this.fov = 300; this.yOffset = 20;     
    this.multiplier = 1.0; 
    
    this.colors = { calm: '#ff9e2c', windy: '#00b7ff', storm: '#ff3333' };

    this.dt = 0.0025;
    this.intensity = 1.0;
    this.frozen = false;

    this.resize();
    window.addEventListener('resize', () => this.resize());
    this.animate();
  }

  setParams(dt, intensity) {
      this.dt = dt || 0.0025;
      this.intensity = intensity || 1.0;
  }

  setFrozen(isFrozen) {
      this.frozen = isFrozen;
  }
  
  resize() {
    if (this.canvas.parentElement) {
       this.canvas.width = this.canvas.parentElement.clientWidth;
       this.canvas.height = this.canvas.parentElement.clientHeight;
    }
  }
  
  step() {
    const dx = (this.SIGMA * (this.y - this.x)) * this.dt;
    const dy = (this.x * (this.RHO - this.z) - this.y) * this.dt;
    const dz = (this.x * this.y - this.BETA * this.z) * this.dt;
    this.x += dx; this.y += dy; this.z += dz;
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
  }
  
  setPalette(theme) {
     this.colors = {
         calm: theme['--ascent'],
         windy: theme['--steady'],
         storm: theme['--ruin']
     };
  }
  
  clearTrail() {
    this.points.fill(null);
    this.head = 0;
    this.count = 0;
  }

  updateWeather(velocity) {
    let rawInput = velocity * 1.333; 
    let scaledIntensity = rawInput * this.intensity;

    
    // Only update DOM if NOT frozen
    if (!this.frozen) {
	this.multiplier = 0.5 + (scaledIntensity * 2.0);

        if (this.modEl) this.modEl.textContent = this.multiplier.toFixed(2) + "x";

        let statusText = "", statusClass = "", color = "";
        
        if(scaledIntensity < 0.17) { 
            statusText = "CALM"; statusClass = "weather-good"; color = this.colors.calm;
        } else if (scaledIntensity < 0.37) { 
            statusText = "WINDY"; statusClass = "weather-ok"; color = this.colors.windy;
        } else { 
            statusText = "STORM"; statusClass = "weather-bad"; color = this.colors.storm;
        }

        if (this.statusEl) {
          this.statusEl.textContent = statusText;
          this.statusEl.className = "weather-status " + statusClass;
        }
        if (this.modEl) this.modEl.className = "mono " + statusClass;
        return color;
    }
    
    // If frozen, we still need to return a color for the canvas to keep drawing
    // We calculate the color based on current intensity but don't touch the DOM
    if(scaledIntensity < 0.17) return this.colors.calm;
    if(scaledIntensity < 0.37) return this.colors.windy;
    return this.colors.storm;
  }
  
  project(x, y, z, cx, cy) {
    const cosA = Math.cos(this.angle);
    const sinA = Math.sin(this.angle);
    const rx = x * cosA - y * sinA; 
    const ry = x * sinA + y * cosA; 
    const depth = this.fov / (this.fov + ry + 60); 
    return { x: cx + rx * this.scale * depth, y: (cy + this.yOffset) + (-(z - 25)) * this.scale * depth };
  }
  
  reset() {
    this.points.fill(null);
    this.count = 0;
    this.head = 0;
    this.x = 10 + (Math.random() - 0.5) * 2; 
    this.y = 10 + (Math.random() - 0.5) * 2; 
    this.z = 25 + (Math.random() - 0.5) * 2;
  }


  animate() {
    if (this.canvas.width === 0) return requestAnimationFrame(() => this.animate());

    const velocity = this.step();
    const color = this.updateWeather(velocity);
    
    this.points[this.head] = { x: this.x, y: this.y, z: this.z, color: color };
    this.head = (this.head + 1) % this.MAX_POINTS;
    if (this.count < this.MAX_POINTS) this.count++;
    
    this.angle += this.rotSpeed;

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    const cx = this.canvas.width / 2;
    const cy = this.canvas.height / 2;
    
  if (this.count > 1) {
    this.ctx.lineWidth = 1.5;
    
    let idx = (this.count < this.MAX_POINTS) ? 0 : this.head;
    
    let p = this.points[idx];
    let prevProj = this.project(p.x, p.y, p.z, cx, cy);
    let currentColor = this.points[(idx + 1) % this.MAX_POINTS].color;
    
    this.ctx.beginPath();
    this.ctx.strokeStyle = currentColor;
    this.ctx.moveTo(prevProj.x, prevProj.y);
    
    for (let i = 1; i < this.count; i++) {
      idx = (idx + 1) % this.MAX_POINTS;
      p = this.points[idx];
      
      const proj = this.project(p.x, p.y, p.z, cx, cy);
      
      if (p.color !== currentColor) {
        this.ctx.stroke(); 
        this.ctx.beginPath();
        this.ctx.strokeStyle = p.color;
        this.ctx.moveTo(prevProj.x, prevProj.y); 
        currentColor = p.color;
      }
      
      this.ctx.lineTo(proj.x, proj.y);
      prevProj = proj;
    }
    this.ctx.stroke();
  }

  if (this.count > 0) {
    const lastIdx = (this.head - 1 + this.MAX_POINTS) % this.MAX_POINTS;
    const lastP = this.points[lastIdx];
    const lastProj = this.project(lastP.x, lastP.y, lastP.z, cx, cy);

    this.ctx.save();
    this.ctx.shadowColor = "rgba(255,255,255,0.9)";
    this.ctx.shadowBlur = 12;
    this.ctx.fillStyle = "#ffffff";
    this.ctx.beginPath();
    this.ctx.arc(lastProj.x, lastProj.y, 3, 0, Math.PI * 2);
    this.ctx.fill();
    this.ctx.restore();
  }
    requestAnimationFrame(() => this.animate());
  }
  
  getModifier() { return this.multiplier; }
  
  getCondition() {
    // Calculate scaledIntensity the same way updateWeather does
    // We need to get the current velocity - which is derived from the last step
    // Since we don't store velocity, we calculate based on the multiplier
    // multiplier = 0.5 + (scaledIntensity * 2.0), so scaledIntensity = (multiplier - 0.5) / 2.0
    const scaledIntensity = (this.multiplier - 0.5) / 2.0;
    if (scaledIntensity < 0.17) return 'calm';
    if (scaledIntensity < 0.37) return 'windy';
    return 'storm';
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 5: THEME MANAGER                                                   */
/* -------------------------------------------------------------------------- */
class ThemeManager {
  constructor() {
    this.pickers = {};
    const ids = ['p-bg','p-card-bg','p-card-border','p-text','p-muted',
                 'p-ascent','p-steady','p-poise','p-ruin','p-summit'];
                 
    ids.forEach(id => {
      const el = document.getElementById(id);
      if(el) {
        this.pickers[el.dataset.var] = el;
        el.addEventListener('input', (e) => this.updateSingleColor(e.target.dataset.var, e.target.value));
      }
    });

    document.getElementById('btn-random-oklch').onclick = () => this.generateRandom();
    document.getElementById('btn-theme-export').onclick = () => this.exportTheme();
    document.getElementById('btn-theme-import').onclick = () => document.getElementById('file-theme-import').click();
    document.getElementById('file-theme-import').onchange = (e) => this.importTheme(e);
    
    // Saved Palettes Bindings
    this.savedPalettes = JSON.parse(localStorage.getItem('sisyphus_saved_palettes') || '{}');
    this.updateSavedList();
    
    document.getElementById('btn-save-palette').onclick = () => this.saveCurrentPalette();
    document.getElementById('btn-delete-palette').onclick = () => this.deleteSelectedPalette();
    document.getElementById('saved-palettes-list').onchange = (e) => this.loadSavedPalette(e.target.value);
  }

  updateSingleColor(variable, value) {
    document.documentElement.style.setProperty(variable, value);
    document.getElementById('theme-select').value = 'custom';
    if(window.game && window.game.chaos) {
      window.game.chaos.setPalette(this.getCurrentPalette());
    }
  }

  getCurrentPalette() {
    const p = {};
    Object.keys(this.pickers).forEach(k => {
      p[k] = getComputedStyle(document.documentElement).getPropertyValue(k).trim();
    });
    p['--bg-image'] = getComputedStyle(document.documentElement).getPropertyValue('--bg-image').trim();
    return p;
  }
  
  // FIX APPLIED: Added externalChaos argument to handle initialization timing
  syncFromRoot(externalChaos) {
      setTimeout(() => {
        const p = this.getCurrentPalette();
        Object.keys(p).forEach(k => {
            if(this.pickers[k]) {
                let val = p[k];
                if(val.startsWith('rgb')) {
                    const rgb = val.match(/\d+/g).map(Number);
                    this.pickers[k].value = ColorMath.rgbToHex(rgb[0], rgb[1], rgb[2]);
                } else if (val.startsWith('#')) {
                    this.pickers[k].value = val;
                }
            }
        });
        
        // Use passed instance OR global instance
        const chaos = externalChaos || (window.game && window.game.chaos);
        if(chaos) {
            chaos.setPalette(p);
            chaos.clearTrail();
        }
    }, 50);
  }

  generateRandom() {
    const mode = document.getElementById('gen-mode').value;
    const palette = ColorMath.generatePalette(mode);
    this.applyPalette(palette);
    document.getElementById('theme-select').value = 'custom';
  }

  // FIX APPLIED: Added externalChaos argument
  applyPalette(palette, externalChaos) {
    const root = document.documentElement;
    Object.entries(palette).forEach(([key, val]) => {
      root.style.setProperty(key, val);
      if(this.pickers[key]) this.pickers[key].value = val; 
    });
    
    const chaos = externalChaos || (window.game && window.game.chaos);
    if(chaos) {
      chaos.setPalette(palette);
      chaos.clearTrail();
    }
  }
  
  // Custom Palette Logic
  saveCurrentPalette() {
      const name = document.getElementById('save-palette-name').value.trim();
      if(!name) { alert("Please enter a name for the palette."); return; }
      
      const palette = this.getCurrentPalette();
      this.savedPalettes[name] = palette;
      localStorage.setItem('sisyphus_saved_palettes', JSON.stringify(this.savedPalettes));
      this.updateSavedList();
      document.getElementById('saved-palettes-list').value = name;
      alert(`Palette "${name}" saved.`);
  }
  
  updateSavedList() {
      const select = document.getElementById('saved-palettes-list');
      select.innerHTML = '<option value="">-- Load Saved --</option>';
      Object.keys(this.savedPalettes).forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
      });
  }
  
  loadSavedPalette(name) {
      if(!name || !this.savedPalettes[name]) return;
      this.applyPalette(this.savedPalettes[name]);
      document.getElementById('save-palette-name').value = name;
      document.getElementById('theme-select').value = 'custom';
  }
  
  deleteSelectedPalette() {
      const select = document.getElementById('saved-palettes-list');
      const name = select.value;
      if(!name) return;
      if(confirm(`Delete saved palette "${name}"?`)) {
          delete this.savedPalettes[name];
          localStorage.setItem('sisyphus_saved_palettes', JSON.stringify(this.savedPalettes));
          this.updateSavedList();
          document.getElementById('save-palette-name').value = "";
      }
  }

  exportTheme() {
    const palette = this.getCurrentPalette();
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(palette));
    const dlAnchorElem = document.createElement('a');
    dlAnchorElem.setAttribute("href", dataStr);
    dlAnchorElem.setAttribute("download", "sisyphus_theme.json");
    dlAnchorElem.click();
  }

  importTheme(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const palette = JSON.parse(event.target.result);
        this.applyPalette(palette);
        document.getElementById('theme-select').value = 'custom';
        alert("Theme loaded successfully.");
      } catch(err) {
        alert("Invalid theme file.");
      }
    };
    reader.readAsText(file);
    e.target.value = ''; 
  }
}


/* -------------------------------------------------------------------------- */
/* MODULE 6: GAME CONTROLLER                                                 */
/* -------------------------------------------------------------------------- */
class GameController {
  constructor() {
    this.model = new SisyphusModel();
    this.ui = new SisyphusUI(this.model);
    this.chaos = new ChaosEngine();
    this.themeManager = new ThemeManager();
    
    this.autoTimerId = null;
    this.bgTimer = new BackgroundTimer(); 
    this.renderReq = null;
    this.isAuto = false;
    this.controlsLocked = false;
    this.grids = null;
    this.announcer = new AriaAnnouncer();
    this.perfMonitor = new PerformanceMonitor();
    this.slotMode = 'load'; 

    setInterval(() => {
      if (this.ui) {
        const elapsed = Math.max(0, Date.now() - this.model.startTime);
        const el = document.getElementById('run-time');
        if (el) el.textContent = this.ui._formatDuration(elapsed);
      }
    }, 1000);
    
    this.bindEvents();
    this.bindKeyboard();
    this.load(); 
    
    const savedTheme = localStorage.getItem('sisyphus_theme') || 'default';
    if (savedTheme === 'custom') {
        const customColors = JSON.parse(localStorage.getItem('sisyphus_custom_colors') || '{}');
        // FIX APPLIED: Pass this.chaos explicitly
        this.themeManager.applyPalette(customColors, this.chaos);
    } else {
        this.setTheme(savedTheme);
    }

    this.recalcExpectations();
    this.ui.render(this.grids, true); 
    this.updateSlotUI();
    this.updateSimModeUI();
    this.syncWeatherParams();
    
    if (!localStorage.getItem('sisyphus_welcome_seen')) {
      document.getElementById('welcome-modal').classList.add('show');
    }
  }

  bindEvents() {
    const $ = id => document.getElementById(id);
    $('roll1_big').onclick = () => this.stepManually();
    $('rollN').onclick = () => {
      if (!this.isSimMode()) return;
      const n = +$('nRolls').value || 20;
      for(let i=0; i<n; i++) { if(this.model.step() === 'top') break; }
      this.ui.render(this.grids); this.save();
    };
    $('rollNCycles').onclick = () => {
      if (!this.isSimMode()) return;
      const target = this.model.cycleId + (+$('nRolls').value || 1);
      let safety = 0;
      while(this.model.cycleId < target && safety++ < 2000000) { if(this.model.step() === 'top') break; }
      this.ui.render(this.grids); this.save();
    };
    $('auto').onclick = () => {
      if (!this.isSimMode()) return;
      this.toggleAuto();
    };
    $('apply').onclick = () => {
      if (!this.isSimMode()) return;
      this.applyParams();
    };
    $('resetState').onclick = () => this.reset();
    $('setStateBtn').onclick = () => {
      if (!this.isSimMode()) return;
      this.model.setState(+$('set-k').value||1, +$('set-l').value||0);
      this.model.state.isSimulation = true;
      this.updateSimModeUI();
      this.ui.render(this.grids);
    }
    
    $('btn-summit-reset').onclick = () => {
      document.getElementById('summit-modal').classList.remove('show');
      this.reset();
    };
    $('btn-summit-close').onclick = () => {
      document.getElementById('summit-modal').classList.remove('show');
    };
    
    document.querySelectorAll('.slot-mode-btn').forEach(b => b.addEventListener('click', (e) => this.setSlotMode(e.target.dataset.mode)));
    document.querySelectorAll('.slot-btn').forEach(b => b.addEventListener('click', (e) => this.handleSlotAction(e.currentTarget.dataset.slot)));
    
    $('btn-export').onclick = () => this.exportSlot();
    $('btn-import').onclick = () => $('file-import').click();
    $('file-import').onchange = (e) => {
      if(e.target.files.length > 0) this.importToSlot(e.target.files[0]);
      e.target.value = ''; 
    };

    $('theme-select').onchange = (e) => this.setTheme(e.target.value);
    
    // Simulation mode toggle
    $('chk-sim-mode').onchange = (e) => {
      if (e.target.checked) {
        if (confirm('Enabling simulation mode will mark this run. Continue?')) {
          this.model.state.isSimulation = true;
          this.updateSimModeUI();
          this.save();
        } else {
          e.target.checked = false;
        }
      } else {
        // Cannot disable once enabled for this run
        e.target.checked = true;
        this.announcer.announce('Simulation mode cannot be disabled for this run');
      }
    };
  }
  
  isSimMode() {
    return document.getElementById('chk-sim-mode').checked;
  }
  
  updateSimModeUI() {
    const isSimulation = this.model.state.isSimulation;
    const checkbox = document.getElementById('chk-sim-mode');
    const badge = document.getElementById('sim-mode-badge');
    
    // Update checkbox state
    checkbox.checked = isSimulation;
    
    // Show/hide badge
    badge.style.display = isSimulation ? 'block' : 'none';
    
    // Enable/disable sim-only controls
    const simControls = ['auto', 'rollN', 'rollNCycles', 'setStateBtn', 'set-k', 'set-l', 'apply'];
    simControls.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.disabled = !isSimulation;
    });
  }

  setTheme(name) {
      if(name === 'custom') return; 

      const theme = THEMES[name] || THEMES.default;
      const root = document.documentElement;
      Object.entries(theme).forEach(([key, val]) => {
        root.style.setProperty(key, val);
      });
      localStorage.setItem('sisyphus_theme', name);
      
      const sel = document.getElementById('theme-select');
      if(sel) sel.value = name;
      
      // FIX APPLIED: Pass this.chaos explicitly
      this.themeManager.syncFromRoot(this.chaos);
  }
  
  saveCustomTheme() {
      const custom = this.themeManager.getCurrentPalette();
      localStorage.setItem('sisyphus_theme', 'custom');
      localStorage.setItem('sisyphus_custom_colors', JSON.stringify(custom));
  }

  setSlotMode(mode) {
    this.slotMode = mode;
    const container = document.getElementById('slot-container');
    const desc = document.getElementById('slot-mode-desc');
    document.querySelectorAll('.slot-mode-btn').forEach(b => {
      if(b.dataset.mode === mode) b.classList.add('active'); else b.classList.remove('active');
    });
    container.classList.remove('mode-save', 'mode-load');
    container.classList.add('mode-' + mode);
    desc.textContent = mode === 'save' ? "Click a slot to SAVE current run." : "Click a slot to LOAD a saved game.";
  }

  handleSlotAction(slotId) {
    const key = `sisyphus_slot_${slotId}`;
    if (this.slotMode === 'save') {
      if (localStorage.getItem(key) && !confirm(`Overwrite Slot ${slotId}?`)) return;
      this.saveToSlot(slotId);
    } else {
      if (!localStorage.getItem(key)) return;
      if ((this.model.state.step > 0 || this.model.cycleId > 1) && !confirm(`Load Slot ${slotId}? Current unsaved progress will be lost.`)) return;
      this.loadFromSlot(slotId);
    }
  }

  saveToSlot(id) {
    localStorage.setItem(`sisyphus_slot_${id}`, JSON.stringify(this.serialize()));
    this.updateSlotUI();
    this.announcer.announce(`Saved to Slot ${id}`);
  }

loadFromSlot(id) {
    // 1. Invalidate any pending rolls so their .then() blocks don't fire
    this.currentRollId = (this.currentRollId || 0) + 1; 
    
    // 2. Clear any active "Waiting..." timers from lockControls
    if (this.lockTimer) {
        this.bgTimer.clear(this.lockTimer);
        this.lockTimer = null;
    }
    this.controlsLocked = false;

    // 3. Force Button Reset (in case we reset mid-roll)
    const btn = document.getElementById('roll1_big');
    const mainSpan = document.getElementById('btn-roll-main');
    if (btn) {
        btn.disabled = false;
        btn.className = 'btn big';
    }
    if (mainSpan) mainSpan.textContent = "ROLL";   
    const raw = localStorage.getItem(`sisyphus_slot_${id}`);
    if (raw) {
      this.deserialize(JSON.parse(raw));
      this.announcer.announce(`Loaded Slot ${id}`);
      this.syncUIParams();
      this.recalcExpectations();
      this.ui.render(this.grids, true);
      this.updateSimModeUI();
      
      this.chaos.reset(); 
      this.ui.resetMarker(); // <--- ADD THIS LINE
      
      const lblM = document.getElementById('lbl-M-goal');
      if(lblM) lblM.textContent = this.model.params.M;
    }
  }
  
  exportSlot() {
    const slot = prompt("Export which slot?\n0 = Current Run\n1-5 = Saved Slot");
    if (slot === null) return;
    const slotNum = parseInt(slot, 10);
    
    let data = null;
    let filename = "";

    if (slotNum === 0) {
        data = this.serialize();
        filename = `sisyphus-ruin-current-${new Date().toISOString().slice(0,10)}.json`;
    } else if (slotNum >= 1 && slotNum <= 5) {
        const raw = localStorage.getItem(`sisyphus_slot_${slotNum}`);
        if (!raw) { alert(`Slot ${slotNum} is empty.`); return; }
        data = JSON.parse(raw);
        filename = `sisyphus-ruin-slot-${slotNum}.json`;
    } else {
        alert("Invalid selection.");
        return;
    }

    const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
    this.announcer.announce("Export complete");
  }

  importToSlot(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const json = JSON.parse(e.target.result);
            const state = json.main || json;
            
            const slot = prompt("Import data into which slot?\n0 = Overwrite Current Run (Play Immediately)\n1-5 = Save to Slot");
            if (slot === null) return;
            const slotNum = parseInt(slot, 10);

            if (slotNum === 0) {
                 if ((this.model.state.step > 0) && !confirm("Overwrite current run with imported file?")) return;
                 this.deserialize(state);
                 this.postLoadUpdate();
                 alert("File imported and loaded.");
            } else if (slotNum >= 1 && slotNum <= 5) {
                if(localStorage.getItem(`sisyphus_slot_${slotNum}`) && !confirm(`Overwrite Slot ${slotNum}?`)) return;
                localStorage.setItem(`sisyphus_slot_${slotNum}`, JSON.stringify(state));
                this.updateSlotUI();
                alert(`File saved to Slot ${slotNum}. Switch to Load Mode to play it.`);
            } else {
                alert("Invalid selection.");
            }

        } catch(err) {
            console.error(err);
            alert("Error parsing save file. It may be corrupt or from an incompatible version.");
        }
    };
    reader.readAsText(file);
  }

postLoadUpdate() {
      this.syncUIParams();
      this.recalcExpectations();
      this.ui.render(this.grids, true);
      this.updateSlotUI();
      this.updateSimModeUI();
      
      this.chaos.reset();
      this.ui.resetMarker(); // <--- ADD THIS LINE
      
      const lblM = document.getElementById('lbl-M-goal');
      if(lblM) lblM.textContent = this.model.params.M;
  }
  
  syncUIParams() {
      Object.keys(this.model.params).forEach(k => { 
          const el = document.getElementById(k); 
          if(el) el.value = this.model.params[k]; 
      });
      this.syncWeatherParams();
  }

  updateSlotUI() {
    for(let i=1; i<=5; i++) {
      const btn = document.querySelector(`.slot-btn[data-slot="${i}"]`);
      const raw = localStorage.getItem(`sisyphus_slot_${i}`);
      const infoDiv = btn.querySelector('.slot-info');
      if (raw) {
        btn.classList.add('has-data'); btn.classList.remove('empty');
        try {
          const d = JSON.parse(raw);
          infoDiv.textContent = `k:${d.state.k} ℓ:${d.state.l}\nSteps:${d.state.step}`;
        } catch(e) { infoDiv.textContent = "Error"; }
      } else {
        btn.classList.remove('has-data'); btn.classList.add('empty'); infoDiv.textContent = "Empty";
      }
    }
  }
  
  bindKeyboard() {
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      const modal = document.getElementById('help-modal');
      switch(e.key) {
        case ' ': case 'Enter': e.preventDefault(); if (!modal.classList.contains('show')) this.stepManually(); break;
        case 'r': case 'R': if (!e.ctrlKey) { e.preventDefault(); this.reset(); } break;
        case 'a': case 'A': e.preventDefault(); this.toggleAuto(); break;
        case '?': e.preventDefault(); modal.classList.toggle('show'); break;
        case 'Escape': if (modal.classList.contains('show')) { e.preventDefault(); modal.classList.remove('show'); } break;
      }
    });
  }

  getDynamicDelay() {
    const base = SisyphusMath.getDelay(this.model.state.k, this.model.state.l, this.model.params);
    return base === 0 ? 0 : base * this.chaos.getModifier();
  }

  stepManually() {
    if (this.controlsLocked) return;
    if(this.isAuto) this.toggleAuto();

    this.currentRollId = (this.currentRollId || 0) + 1;
         const thisRollId = this.currentRollId;
    
    const btn = document.getElementById('roll1_big');
    const mainSpan = document.getElementById('btn-roll-main'); 
    
    const weatherCondition = this.chaos.getCondition();
    const dilationValue = this.chaos.getModifier();
    this.model.recordWeatherOnPress(weatherCondition, dilationValue);
    

    btn.disabled = true;
    if(mainSpan) mainSpan.textContent = "PUSHING THE BOULDER...";


    this.chaos.setFrozen(true);

    const prevK = this.model.state.k;
    const prevL = this.model.state.l;

    const res = this.model.step();
    const rng = this.model.lastRoll.rng;
    

    this.ui.visualizeRoll(rng, 3000, res).then(() => {
	if (this.currentRollId !== thisRollId) return;
        this.handleStepResult(res); 
        this.save();
    
        const delay = this.getDynamicDelay();
    
        if (res !== 'top' && delay > 50) {
          this.ui.render(this.grids, true, true, false); 
          
          this.ui.animateChange(prevK, prevL, this.model.state.k, this.model.state.l, delay, this.model.params);
          this.lockControls(delay, res);
        } else {
           // No delay: Update everything immediately
           this.ui.render(this.grids);
           if(res !== 'top') {
               btn.disabled = false;
               if(mainSpan) mainSpan.textContent = "ROLL";
               this.chaos.setFrozen(false);
           } else {
               this.chaos.setFrozen(false);
           }
        }
    });
  }

lockControls(duration, outcome) {
    this.controlsLocked = true;
    const btn = document.getElementById('roll1_big');
    const mainSpan = document.getElementById('btn-roll-main');
    
    // 1. Update UI to Locked State
    btn.disabled = true;
    btn.className = `btn big outcome-${outcome}`; 
    this.chaos.setFrozen(true);
    
    // 2. Determine verb (Waiting, Ascending, etc.)
    let verb = 'WAITING';
    const lr = this.model.lastRoll;
    const L = this.model.params.L;

    if (outcome === 'win') {
        verb = 'ASCENDING';
    } else if (outcome === 'loss') {
        if (lr.k0 === 1 && lr.l0 === 0) verb = 'THE STONE WAITS';
        else verb = 'THE STONE FALLS';
    } else if (outcome === 'neu') {
        if (lr.l0 >= L) verb = 'KEEPING FOOTING';
        else verb = 'BUILDING POISE';
    }

    const endTime = Date.now() + duration;
    
    // 3. START THE TIMER (The Important Change)
    // We save the reference to 'this.lockTimer' so reset() can access it.
    this.lockTimer = this.bgTimer.setInterval(() => {
      const remaining = endTime - Date.now();
      
      if (remaining <= 0) {
        // TIME IS UP: Clean up manually
        this.bgTimer.clear(this.lockTimer);
        this.lockTimer = null; // Clear the reference
        
        this.controlsLocked = false;
        btn.disabled = false;
        btn.className = 'btn big';
        mainSpan.textContent = "ROLL";
        
        this.chaos.setFrozen(false);
        this.ui.render(this.grids); 
      } else {
        // TICK: Update text
        mainSpan.textContent = `${verb} · ${(Math.max(0, remaining)/1000).toFixed(1)}s`;
      }
    }, 50);
  }

  toggleAuto() {
    if (!this.isSimMode()) return;
    const btn = document.getElementById('auto');
    if (this.isAuto) {
      if (this.autoTimerId) { this.bgTimer.clear(this.autoTimerId); this.autoTimerId = null; }
      if (this.renderReq) { cancelAnimationFrame(this.renderReq); this.renderReq = null; }
      this.isAuto = false; btn.textContent = 'Auto Play';
      this.ui.render(this.grids, true);
    } else {
      this.isAuto = true; btn.textContent = 'Stop';
      let frameCount = 0;
      const renderLoop = () => {
        if(!this.isAuto) return;
        frameCount++;
        this.ui.render(this.grids, frameCount % 60 === 0);
        this.perfMonitor.tick();
        this.renderReq = requestAnimationFrame(renderLoop);
      };
      renderLoop();

      const logicLoop = () => {
        if (!this.isAuto) return;
        if (this.model.state.topHit) { this.toggleAuto(); return; }

        const res = this.model.step();
        this.handleStepResult(res);
        if (res === 'top') { this.toggleAuto(); this.ui.render(this.grids, true); return; }

        const useDelay = document.getElementById('use-delay').checked;
        let delay = useDelay ? (this.getDynamicDelay() || 50) : (+document.getElementById('speed').value || 100);
        if (!useDelay && delay < 20) for(let i=0; i<9; i++) if(!this.model.state.topHit) this.model.step();

        this.autoTimerId = this.bgTimer.setTimeout(logicLoop, delay);
      };
      logicLoop();
    }
  }

  handleStepResult(res) {
    if (res === 'top') { 
      this.announcer.announce("Congratulations! Summit reached!"); 
      this.showSummitModal(); 
    }
    else if (res === 'win') this.announcer.announce(`Ascent! Now at Height ${this.model.state.k}`);
    else if (res === 'loss') this.announcer.announce("Ruin. Reset to Height 1");
    else if (res === 'neu') this.announcer.announce("Steady. Poise increased");
    if(res && res !== 'top') this.ui.log(`step ${this.model.state.step}: ${this.model.lastRoll.outcome.toUpperCase()}`);
  }

  showSummitModal() {
    const modal = document.getElementById('summit-modal');
    const elapsed = Math.max(0, Date.now() - this.model.startTime);
    
    document.getElementById('summit-duration').textContent = this.ui._formatDuration(elapsed);
    document.getElementById('summit-steps').textContent = this.model.state.step;
    document.getElementById('summit-cycles').textContent = this.model.cycleId;
    
    modal.classList.add('show');
  }

  applyParams(shouldReset = true) {
    const p = this.model.params;
    ['M','L','w_min','w_max','beta','rho','gamma','c_min','c_max','alpha','g_n','s_w','max_delay','chaos_dt','chaos_intensity'].forEach(k => {
      const el = document.getElementById(k); if(el) p[k] = +el.value;
    });

    const lblM = document.getElementById('lbl-M-goal');
    if(lblM) lblM.textContent = p.M;

    SisyphusMath.clearCache();
    this.syncWeatherParams();
    
    const chk = document.getElementById('chk-reset-on-apply');
    if (chk) {
        shouldReset = chk.checked;
    }
    
    if (shouldReset) {
        this.reset();
    } else {
        this.model.state.k = Math.min(this.model.state.k, this.model.params.M);
        this.model.state.l = Math.min(this.model.state.l, this.model.params.L);
        this.recalcExpectations();
        this.ui.render(this.grids, true);
        this.save();
        this.announcer.announce("Parameters applied (State kept)");
    }
  }
  
  syncWeatherParams() {
      if(this.chaos) this.chaos.setParams(this.model.params.chaos_dt, this.model.params.chaos_intensity);
  }

  reset() {
 // 1. Invalidate any pending rolls so their .then() blocks don't fire
    this.currentRollId = (this.currentRollId || 0) + 1; 
    
    // 2. Clear any active "Waiting..." timers from lockControls
    if (this.lockTimer) {
        this.bgTimer.clear(this.lockTimer);
        this.lockTimer = null;
    }
    this.controlsLocked = false;

    // 3. Force Button Reset (in case we reset mid-roll)
    const btn = document.getElementById('roll1_big');
    const mainSpan = document.getElementById('btn-roll-main');
    if (btn) {
        btn.disabled = false;
        btn.className = 'btn big';
    }
    if (mainSpan) mainSpan.textContent = "ROLL";   
    this.model.reset();
    this.chaos.reset();
    this.ui.resetMarker(); 
    this.recalcExpectations();
    this.ui.render(this.grids, true);
    this.updateSimModeUI();
    this.save();
    this.announcer.announce("Game reset");
  }

  recalcExpectations() {
    this.grids = SisyphusMath.solveExpectations(this.model.params);
    this.ui.updateExpectations(this.grids);
  }

   serialize() {
    return {
      params: this.model.params, state: this.model.state, stats: this.model.stats,
      historyK: this.model.historyK, cycleSummaries: this.model.cycleSummaries,
      distributions: this.model.distributions, allCycles: this.model.allCycles,
      lastRoll: this.model.lastRoll, cycleId: this.model.cycleId,
      currentCycle: this.model.currentCycle, startTime: this.model.startTime
    };
  }

deserialize(data) {
  Object.assign(this.model.params, data.params);
  Object.assign(this.model.state, data.state);
  Object.assign(this.model.stats, data.stats);

  // Backward compatibility: add isSimulation if missing
  if (this.model.state.isSimulation === undefined) {
    this.model.state.isSimulation = false;
  }

  if (data.historyK) this.model.historyK = data.historyK;
  if (data.cycleSummaries) this.model.cycleSummaries = data.cycleSummaries;

  if (data.distributions) {
    this.model.distributions = data.distributions;

    // Ensure weatherOnPress exists
    if (!this.model.distributions.weatherOnPress) {
      this.model.distributions.weatherOnPress = { calm: 0, windy: 0, storm: 0 };
    }

    // Normalize dilationOnPress to histogram form
    const d = this.model.distributions;
    if (!d.dilationOnPress) {
      d.dilationOnPress = { freq: {}, total: 0 };
    } else if (Array.isArray(d.dilationOnPress)) {
      // Old format: array of raw dilation values
      const hist = { freq: {}, total: 0 };
      d.dilationOnPress.forEach(val => {
        const bucketVal = Math.round(val * 10000) / 10000;
        const key = bucketVal.toFixed(4);
        if (!hist.freq[key]) hist.freq[key] = 0;
        hist.freq[key]++;
        hist.total++;
      });
      d.dilationOnPress = hist;
    } else if (!d.dilationOnPress.freq) {
      // If somehow an object but missing freq/total, normalize it
      d.dilationOnPress = { freq: {}, total: 0 };
    }
  }

  // Normalize allCycles to histogram form
  if (data.allCycles) {
    if (Array.isArray(data.allCycles)) {
      const hist = { freq: {}, total: 0 };
      data.allCycles.forEach(len => {
        if (!hist.freq[len]) hist.freq[len] = 0;
        hist.freq[len]++;
        hist.total++;
      });
      this.model.allCycles = hist;
    } else if (data.allCycles.freq) {
      this.model.allCycles = data.allCycles;
      if (!this.model.allCycles.total) {
        this.model.allCycles.total = Object.values(this.model.allCycles.freq)
          .reduce((sum, c) => sum + c, 0);
      }
    } else {
      // Fallback: reset
      this.model.allCycles = { freq: {}, total: 0 };
    }
  }

  if (data.lastRoll) this.model.lastRoll = data.lastRoll;
  if (data.cycleId) this.model.cycleId = data.cycleId;
  if (data.currentCycle) this.model.currentCycle = data.currentCycle;
  if (data.startTime) this.model.startTime = data.startTime;
  else this.model.startTime = Date.now();
}


 save() {
    localStorage.setItem('sisyphus_v9_delay', JSON.stringify(this.serialize()));
    // Persist custom theme if that's active
    if (document.getElementById('theme-select').value === 'custom') {
        this.saveCustomTheme();
    }
  }

load() {
    try {
      const raw = localStorage.getItem('sisyphus_v9_delay') || localStorage.getItem('sisyphus_v8_optimized'); 
      if(raw) {
        this.deserialize(JSON.parse(raw));
        this.syncUIParams();
        const lblM = document.getElementById('lbl-M-goal');
        if(lblM) lblM.textContent = this.model.params.M;
      }
    } catch(e) { console.warn("Load failed", e); }
  }
}

document.addEventListener('DOMContentLoaded', () => { window.game = new GameController(); });

</script>
</body>
</html>
