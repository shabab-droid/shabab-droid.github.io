<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sisyphus' Ruin v3.1</title>
<style>
  :root{
    --bg:#080014; --text:#fef8ff; --muted:#cdaeff;
    --accent:#ff9e2c; --accent-2:#ff00b8; --accent-3:#00b7ff; --accent-4:#ff4efc;
    --danger:#ff3333; --success:#00ff9d;
  }

  body{
    margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    min-height: 100vh; background-color:#050010;
    background-image:
      radial-gradient(900px 700px at 50% -200px, rgba(255,0,200,.15), transparent 70%),
      radial-gradient(900px 700px at 50% 120%, rgba(0,200,255,.12), transparent 70%),
      linear-gradient(180deg,#0b0014 0%, #050010 100%);
    background-repeat:no-repeat; background-size:cover;
  }
  
  .app{max-width:1100px;margin:0 auto;padding:12px}
  h1{
    text-align:center; font-size:clamp(22px,3vw,30px); margin:14px 0 12px; letter-spacing:.5px;
    background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));
    -webkit-background-clip:text; background-clip:text; color:transparent;
  }
  .grid{display:grid;grid-template-columns:1fr 360px;gap:12px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .card{background:rgba(12, 0, 32, 0.6); backdrop-filter:blur(4px); padding:14px; border-radius:8px; border:1px solid rgba(255,255,255,0.05);}
  
  .card h2 { font-size: 18px; margin: 0 0 8px; opacity: 0.9; }

  .btn{
    appearance:none; background:#1c0130; border:none; color:var(--text); border-radius:6px;
    padding:10px 14px; cursor:pointer; font-weight:600; letter-spacing:.3px;
    transition:background .15s ease,transform .1s ease; box-shadow:inset 0 0 0 1px rgba(255,255,255,.1);
  }
  .btn:hover{background:#2d0048}
  .btn:active{transform:scale(.97)}
  .btn:focus{outline:2px solid var(--accent);outline-offset:2px}
  
  .btn:disabled {
    opacity: 0.9; cursor: not-allowed; background: #2a2a2a !important;
    color: #aaa !important; transform: none !important; box-shadow: none !important;
  }
  
  .checkbox-wrapper {
    display: flex; align-items: center; gap: 8px; padding: 0 8px; width: auto; 
    height: 38px; cursor: pointer; user-select: none; opacity: 0.85; transition: opacity 0.2s;
  }
  .checkbox-wrapper:hover { opacity: 1; }
  .checkbox-wrapper input[type="checkbox"] {
    appearance: none; width: 16px; height: 16px; background: #140026;
    border: 1px solid rgba(255,255,255,0.3); border-radius: 3px; cursor: pointer;
    display: grid; place-content: center; margin: 0;
  }
  .checkbox-wrapper input[type="checkbox"]::before {
    content: ""; width: 8px; height: 8px; background: var(--accent);
    transform: scale(0); transition: 0.1s transform; border-radius: 1px;
  }
  .checkbox-wrapper input[type="checkbox"]:checked::before { transform: scale(1); }
  .checkbox-wrapper input[type="checkbox"]:checked { border-color: var(--accent); }
  .checkbox-wrapper label { cursor: pointer; color: var(--text); width: auto; font-size: 13px; font-weight: 500; }

  .docked-control {
    position: sticky; top: 0; z-index: 1000;
    background: rgba(5, 0, 16, 0.85); backdrop-filter: blur(8px);
    margin: -12px -12px 12px -12px; padding: 12px;
    border-bottom: 1px solid rgba(255, 166, 0, 0.15);
    display: flex; justify-content: center;
  }

  .btn.big{
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    width:100%; padding:12px; margin-bottom:0; 
    background: linear-gradient(90deg, var(--accent), var(--accent-3), #ff2400); 
    color:#120026; font-weight:800; max-width: 600px; min-height: 64px; 
    line-height: 1.2; transition: background 0.3s ease; border: none;
    text-shadow: 0 0 10px rgba(255,255,255,0.2);
  }
  .btn.big:hover{opacity: 0.9;}
  
  .btn.big.outcome-win:disabled { background: var(--accent) !important; color: #120026 !important; opacity: 1 !important; }
  .btn.big.outcome-neu:disabled { background: var(--accent-3) !important; color: #120026 !important; opacity: 1 !important; }
  .btn.big.outcome-loss:disabled { background: #ff2400 !important; color: #ffffff !important; opacity: 1 !important; }
  
  .btn-main-text { font-size: 20px; text-transform: uppercase; }

  label{width:120px;font-size:12px;color:var(--muted)}
  
  input[type="number"],select{
    background:#140026; color:var(--text); border:none; border-radius:4px;
    padding:6px 8px; width: 54px; box-shadow:inset 0 0 0 1px rgba(255,255,255,.1);
  }
  select#speed { width: auto; }
  input#nRolls { width: 60px; }

  .desc{font-size:11px;opacity:.6;color:var(--muted);margin:-2px 0 8px; display:block; line-height:1.3;}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .bar{
    height:10px; background:rgba(255,255,255,.06); border-radius:8px;
    overflow:hidden; margin:3px 0; border:1px solid rgba(255,166,0,.12);
  }
  .bar>div{height:100%}
  .bar .win{background:var(--accent)}
  .bar .neu{background:var(--accent-3)}
  .bar .loss{background:#ff2400}

  .kpos-track,.lpos-track{
    height:6px; background:rgba(255,255,255,.06); border:1px solid rgba(255,166,0,.12);
    border-radius:6px; overflow:hidden;
  }
  .kpos-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-4))}
  .lpos-fill{height:100%;background:linear-gradient(90deg,var(--accent-3),var(--accent-2))}
  
  .tiny{font-size:11px;opacity:.65;color:var(--muted)}
  .mono{font-family:monospace;}
  .small{font-size:12px;}

  .recent.win #recent-outcome{color:#ffd54a; text-shadow:0 0 6px rgba(255,213,74,.65),0 0 18px rgba(255,180,0,.4);}
  .recent.neu #recent-outcome{color:var(--accent-3); text-shadow:0 0 6px rgba(0,183,255,.65),0 0 18px rgba(0,183,255,.4);}
  .recent.loss #recent-outcome{color:#ff4d4d; text-shadow:0 0 6px rgba(255,77,77,.65),0 0 18px rgba(255,40,40,.4);}
  
  .cycle-entry {
    font-family: monospace; font-size: 11px; border-radius: 4px; 
    border-left: 3px solid rgba(255,255,255,.12); padding: 4px 6px; 
    margin-bottom: 4px; background: rgba(12,0,32,0.6); 
    white-space: pre-wrap; word-break: break-word;
    display: flex; flex-direction: column; gap: 1px;
  }
  .cycle-entry.loss { border-color: rgba(255,90,90,.8); }
  .cycle-entry.top { border-color: rgba(255,210,90,.9); background: rgba(30,20,0,0.4); }
  .cycle-entry.active { border-color: rgba(255,255,255,0.7); background: rgba(255,255,255,0.05); }

  .cycle-entry-top-row { display: flex; justify-content: space-between; align-items: baseline; font-weight: 600; opacity: 0.9; line-height: 1.2; }
  .cycle-id { color: var(--accent-3); margin-right: 6px; }
  .cycle-meta { font-weight: 400; opacity: 0.65; font-size: 10px; }
  .cycle-entry-path { opacity: 0.75; font-size: 10px; line-height: 1.1; letter-spacing: 1px; margin-top: 1px; }

  .stats-grid {
    display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-top: 6px;
    background: rgba(255,255,255,0.03); padding: 6px; border-radius: 6px;
  }
  .stat-box { display: flex; flex-direction: column; align-items: center; }
  .stat-label { font-size: 10px; opacity: 0.5; text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-val { font-family: monospace; font-size: 13px; font-weight: 600; color: var(--accent-3); }

  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  .perf-indicator { position: fixed; bottom: 10px; right: 10px; background: rgba(0,0,0,0.8); padding: 4px 8px; border-radius: 4px; font-size: 10px; font-family: monospace; opacity: 0.5; pointer-events: none; }

  /* Modals */
  .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); backdrop-filter: blur(2px); z-index: 2000; align-items: center; justify-content: center; }
  .modal.show { display: flex; }
  .modal-content { background: rgba(20,0,38,0.95); border: 2px solid var(--accent); padding: 24px; border-radius: 10px; max-width: 450px; width: 90%; box-shadow: 0 0 40px rgba(0,0,0,0.8); position: relative; }
  .modal h3 { margin-top: 0; color: var(--accent); font-size: 20px; letter-spacing: 0.5px; }
  .modal kbd { background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 3px; font-family: monospace; border: 1px solid rgba(255,255,255,0.2); }
  
  .welcome-list { margin: 12px 0; padding-left: 0; list-style: none; }
  .welcome-list li { margin-bottom: 12px; line-height: 1.5; font-size: 14px; opacity: 0.9; }
  .welcome-list strong { color: var(--accent-3); }

  .weather-status { font-weight: 800; letter-spacing: 0.5px; }
  .weather-good { color: var(--accent); text-shadow: 0 0 5px rgba(255,158,44,0.4); }
  .weather-ok { color: var(--accent-3); text-shadow: 0 0 5px rgba(0,183,255,0.4); }
  .weather-bad { color: #ff3333; text-shadow: 0 0 5px rgba(255,51,51,0.4); }

  #weather-card { position: relative; overflow: hidden; min-height: 250px; display: flex; flex-direction: column; justify-content: space-between; }
  #weather-content { position: relative; z-index: 2; }
  #chaosCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; opacity: 0.4; pointer-events: none; }

  .save-slots-container { margin: 12px 0; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; border: 1px solid rgba(255,255,255,0.05); }
  .slot-mode-switch { display: flex; gap: 4px; margin-bottom: 8px; }
  .slot-mode-btn { flex: 1; font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; padding: 6px; border: 1px solid transparent; opacity: 0.5; transition: all 0.2s ease; }
  .slot-mode-btn.active { opacity: 1; font-weight: 800; }
  .mode-save .slot-mode-btn[data-mode="save"] { background: var(--accent); color: #120026; box-shadow: 0 0 8px var(--accent); }
  .mode-load .slot-mode-btn[data-mode="load"] { background: var(--accent-3); color: #120026; box-shadow: 0 0 8px var(--accent-3); }

  .slot-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; }
  .slot-btn { background: #1c0130; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; padding: 6px 4px; font-family: monospace; font-size: 10px; color: var(--muted); cursor: pointer; transition: all 0.2s ease; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 50px; text-align: center; }
  .slot-btn:hover { background: #2d0048; border-color: rgba(255,255,255,0.3); }
  .slot-btn.has-data { border-color: rgba(255,255,255,0.3); color: var(--text); background: linear-gradient(180deg, #1c0130, #22023a); }
  .slot-btn.empty { opacity: 0.6; font-style: italic; }
  .mode-save .slot-btn:hover { border-color: var(--accent); color: var(--accent); }
  .mode-load .slot-btn:hover { border-color: var(--accent-3); color: var(--accent-3); }
  .slot-label { font-weight: 800; font-size: 12px; margin-bottom: 2px; }
  .slot-info { font-size: 9px; line-height: 1.1; opacity: 0.8; }

  /* Accordion Styling */
  details summary { cursor: pointer; padding: 4px 0; user-select: none; outline: none; }
  details summary:hover h3 { color: var(--accent); }
  details > summary { list-style: none; }
  details > summary::-webkit-details-marker { display: none; }
  details > summary::before { content: '▶'; display: inline-block; margin-right: 6px; font-size: 10px; color: var(--accent); transition: transform 0.2s; }
  details[open] > summary::before { transform: rotate(90deg); }
</style>
<!-- Favicon (SVG, modern browsers) -->
<link rel="icon" type="image/svg+xml" href="/sisyphus-icon.svg">

<!-- Fallback PNG (optional but recommended) -->
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">

<!-- iOS / mobile home-screen icon -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">

</head>
<body>

<div role="status" aria-live="polite" aria-atomic="true" class="sr-only" id="aria-announcer"></div>

<div class="modal" id="help-modal" role="dialog" aria-labelledby="help-title">
  <div class="modal-content">
    <h3 id="help-title">Keyboard Shortcuts</h3>
    <dl>
      <dt><kbd>Space</kbd> or <kbd>Enter</kbd></dt>
      <dd>Roll once</dd>
      <dt><kbd>A</kbd></dt>
      <dd>Toggle auto-play</dd>
      <dt><kbd>R</kbd></dt>
      <dd>Reset game</dd>
      <dt><kbd>?</kbd></dt>
      <dd>Show/hide this help</dd>
      <dt><kbd>Esc</kbd></dt>
      <dd>Close this help</dd>
    </dl>
    <button class="btn" onclick="document.getElementById('help-modal').classList.remove('show')">Close</button>
  </div>
</div>

<div class="modal" id="welcome-modal" role="dialog" aria-labelledby="welcome-title">
  <div class="modal-content">
    <h3 id="welcome-title">Welcome to Sisyphus' Ruin</h3>
    <div class="tiny" style="margin-bottom:16px; opacity:0.7; font-style:italic">The struggle itself towards the heights is enough to fill a man's heart.</div>
    <ul class="welcome-list">
      <li><strong>1. Roll</strong> to push the stone.</li>
      <li><strong>2. Watch</strong> the outcome: <strong>Ascent</strong> gains height and <strong>Ruin</strong> returns you to the bottom. <strong>Steady</strong> builds your poise, raising the chance of ascent and reducing the chance of ruin.</li>
      <li><strong>3. Endure:</strong> The atmosphere will distort, delaying or speeding your next move.</li>
    </ul>
    <button class="btn" style="width:100%" onclick="document.getElementById('welcome-modal').classList.remove('show'); localStorage.setItem('sisyphus_welcome_seen', 'true');">Begin</button>
  </div>
</div>

<div class="perf-indicator" id="perf-indicator"></div>

<template id="tpl-cycle-entry">
  <div class="cycle-entry">
    <div class="cycle-entry-top-row">
      <span class="cycle-main-text"></span>
      <span class="cycle-meta"></span>
    </div>
    <div class="cycle-entry-path"></div>
  </div>
</template>

<div class="app">
  <h1>Sisyphus' Ruin</h1>

  <div class="docked-control">
    <button class="btn big" id="roll1_big" aria-label="Roll the dice once" aria-keyshortcuts="Space Enter">
      <span class="btn-main-text" id="btn-roll-main">ROLL</span>
    </button>
  </div>

  <div class="grid">
    <div>
      <div class="card recent" id="recent-card" role="region" aria-label="Recent roll result">
        <div style="display:flex;flex-direction:column;gap:2px">
          <div id="recent-outcome" style="font-weight:900;letter-spacing:1px;font-size:clamp(20px,3.2vw,32px)">No rolls yet</div>
        </div>
        
        <div class="recent-bars" style="margin-top:8px;">
          <div class="bar" style="display:flex; height:14px; overflow:hidden; margin-bottom:4px" role="progressbar">
            <div id="rbar-win" class="win" style="width:0%"></div>
            <div id="rbar-neu" class="neu" style="width:0%"></div>
            <div id="rbar-loss" class="loss" style="width:0%"></div>
          </div>
          <div class="row" style="justify-content:space-between; font-size:11px; opacity:0.8">
            <div>Ascent: <span class="mono" id="rpct-win">0.0%</span></div>
            <div>Steady: <span class="mono" id="rpct-neu">0.0%</span></div>
            <div>Ruin: <span class="mono" id="rpct-loss">0.0%</span></div>
          </div>
        </div>

        <div class="kpos" style="margin-top:8px">
          <div class="kpos-track"><div id="kpos-fill" class="kpos-fill" style="width:0%"></div></div>
          <div class="small" style="display:flex; justify-content:space-between">
            <span>Height</span>
            <span id="kpos-text" class="mono">1 / 20</span>
          </div>
        </div>
        <div class="lpos" style="margin-top:4px">
          <div class="lpos-track"><div id="lpos-fill" class="lpos-fill" style="width:0%"></div></div>
          <div class="small" style="display:flex; justify-content:space-between">
            <span>Poise</span>
            <span id="lpos-text" class="mono">0 / 20</span>
          </div>
        </div>
      </div>

      <div class="card" id="weather-card">
        <canvas id="chaosCanvas"></canvas>
        <h2 style="position: relative; z-index: 2;">Atmosphere</h2>
        <div id="weather-content">
          <div style="display:flex; justify-content:space-between; align-items:center">
            <div>
              <div class="tiny" style="margin-bottom:2px">CONDITION</div>
              <div id="weather-status-main" style="font-size:18px; font-weight:800; letter-spacing:1px">CALIBRATING</div>
            </div>
            <div style="text-align:right">
              <div class="tiny" style="margin-bottom:2px">TIME DILATION</div>
              <div id="weather-mod-val" class="mono" style="font-size:18px;">1.0x</div>
            </div>
          </div>
        </div>
      </div>

      <div class="card"><h2>Run Stats</h2>
        <div style="margin-bottom:6px; font-size:11px; opacity:0.8">steps: <span class="mono" id="run-steps">0</span></div>
        <div class="bar" style="display:flex; height:14px; overflow:hidden" role="progressbar" aria-label="Run Distribution">
          <div class="win" id="bar-win" style="width:0%"></div>
          <div class="neu" id="bar-neu" style="width:0%"></div>
          <div class="loss" id="bar-loss" style="width:0%"></div>
        </div>
        <div class="row" style="justify-content:space-between; font-size:11px; opacity:0.8">
          <div>Ascent: <span class="mono" id="c-win">0</span> (<span class="mono" id="r-win">0.0%</span>)</div>
          <div>Steady: <span class="mono" id="c-neu">0</span> (<span class="mono" id="r-neu">0.0%</span>)</div>
          <div>Ruin: <span class="mono" id="c-loss">0</span> (<span class="mono" id="r-loss">0.0%</span>)</div>
        </div>
        <div class="row tiny" style="margin-top:6px;justify-content:space-between">
          <div>run time: <span class="mono" id="run-time">0s</span></div>
          <div>Max Height: <span class="mono" id="max-k">1</span></div>
        </div>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:baseline">
          <h2>Cycle Summaries</h2>
        </div>
        <div class="tiny" style="border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:6px; margin-bottom:6px; line-height:1.4">
          A <b>Cycle</b> is one attempt to climb, ending in <b>Ruin</b> or <b>Summit</b>.<br>
          <span class="mono" style="opacity:0.8">(+)Ascent  (.)Steady  (X)Ruin</span>
        </div>
        <div id="cycle-box" class="tiny"></div>
      </div>
    </div>

    <div>
      
      <div class="card">
        <h2 style="margin:0 0 8px">The Burden</h2>
        <div class="tiny" style="line-height:1.5; opacity:0.9">
          The stone is bound for the summit (Height <span id="lbl-M-goal" style="font-weight:bold; color:var(--accent)">20</span>).
          <br><br>
          Each roll has one of three outcomes:
          <br>
          <ul style="padding-left: 16px; margin: 6px 0;">
              <li><strong>Steady:</strong> The stone holds fast. Poise accumulates.</li>
              <li><strong>Ascent:</strong> The stone rises. Poise is shattered by the effort.</li>
              <li><strong>Ruin:</strong> Gravity wins. Height resets.</li>
          </ul>
          <br>
          <strong>Poise</strong> dictates the favor of the odds. High Poise shields against Ruin and invites Ascent.
          <br><br>
          <strong>The Atmosphere:</strong><br>
          Time itself is subject to the chaos of the storm. <br>
          <strong>Turbulence</strong> dilates the delay between events, forcing long waits. <br>
          <strong>Calm</strong> allows for swift progression.<br>
          <br>
          <span style="opacity:0.7; font-style:italic">Note: The Atmosphere distorts the flow of time, but it does not alter the probability of the fall.</span>
        </div>
      </div>

      <div class="card" id="params-container">
        <details>
          <summary>
            <h3 style="display:inline-block; margin:0; font-size:14px; opacity:0.9">Advanced Parameters</h3>
            <div class="tiny" style="opacity:0.6; font-weight:400; margin-left: 4px; display:inline-block">(Click to expand)</div>
          </summary>
          
          <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
              <div class="row"><label for="M">M (Max Height)</label><input id="M" type="number" value="20"></div>
              <div class="desc">Max steps to win (k).</div>
              <div class="row"><label for="L">L (Max Poise)</label><input id="L" type="number" value="20"></div>
              <div class="desc">Poise scale (ℓ).</div>
              <div class="row"><label>w_min → w_max</label><input id="w_min" type="number" step="0.01" value="0.10"><input id="w_max" type="number" step="0.01" value="0.90"></div>
              <div class="desc">Win probability scaling.</div>
              <div class="row"><label for="beta">β (Height ramp)</label><input id="beta" type="number" step="0.1" value="1.5"></div>
              <div class="desc">β > 1 makes late ascent easier.</div>
              <div class="row"><label>ρ, γ (Poise boost)</label><input id="rho" type="number" step="0.05" value="0.6"><input id="gamma" type="number" step="0.1" value="1.5"></div>
              <div class="desc">Effect of Poise on win rate.</div>
              <div class="row"><label>c_min → c_max</label><input id="c_min" type="number" step="0.01" value="0.03"><input id="c_max" type="number" step="0.01" value="0.10"></div>
              <div class="desc">Loss probability range.</div>
              <div class="row"><label for="alpha">α (Loss decay)</label><input id="alpha" type="number" step="0.1" value="0.3"></div>
              <div class="desc">How fast Poise reduces loss chance.</div>
              <div class="row"><label>g_n, s_w</label><input id="g_n" type="number" value="1"><input id="s_w" type="number" value="20"></div>
              <div class="desc">Poise gain (Steady) vs spend (Ascent).</div>
              <div class="row"><label for="max_delay">Max Delay (s)</label><input id="max_delay" type="number" step="0.1" value="45.0"></div>
              <div class="desc">Base cooldown time.</div>
              
              <div class="row" style="margin-top:12px; border-top:1px solid rgba(255,255,255,0.1); padding-top:12px">
                  <button class="btn" id="apply">Apply & Reset</button>
                  <button class="btn" id="resetState" aria-keyshortcuts="R">Reset State</button>
              </div>
          </div>
        </details>
      </div>

      <div class="card">
        <details>
          <summary>
             <h2 style="display:inline-block; margin:0; font-size:14px; opacity:0.9">Play Controls and Saves</h2>
             <div class="tiny" style="opacity:0.6; font-weight:400; margin-left: 4px; display:inline-block">(Click to expand)</div>
          </summary>
          
          <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div class="row" style="align-items: center; gap: 6px;">
              <button class="btn" id="auto" aria-keyshortcuts="A" style="flex:1">Auto Play</button>
              <label class="checkbox-wrapper" for="use-delay">
                <input type="checkbox" id="use-delay">
                <span>Delay</span>
              </label>
              <select id="speed" aria-label="Auto-play speed">
                <option value="1000">Slow</option>
                <option value="100" selected>Normal</option>
                <option value="10">Fast (Turbo)</option>
              </select>
            </div>
            <div class="row" style="margin-top:8px">
              <input id="nRolls" type="number" value="20" aria-label="Number of rolls or cycles" style="width:60px">
              <button class="btn" id="rollN" style="flex:1">Roll N Steps</button>
              <button class="btn" id="rollNCycles" style="flex:1">Roll N Cycles</button>
            </div>
            <div class="row" style="margin-top:8px">
              <span class="tiny" style="min-width:110px">Set Height/Poise:</span>
              <input id="set-k" type="number" min="1" value="1" aria-label="Set k value">
              <input id="set-l" type="number" min="0" value="0" aria-label="Set l value">
              <button class="btn" id="setStateBtn">Set</button>
            </div>

            <div class="save-slots-container mode-load" id="slot-container" style="margin-top:12px">
               <div class="slot-mode-switch">
                 <button class="btn slot-mode-btn" data-mode="save">Save Mode</button>
                 <button class="btn slot-mode-btn active" data-mode="load">Load Mode</button>
               </div>
               <div class="slot-grid">
                 <button class="slot-btn empty" data-slot="1"><div class="slot-label">1</div><div class="slot-info">Empty</div></button>
                 <button class="slot-btn empty" data-slot="2"><div class="slot-label">2</div><div class="slot-info">Empty</div></button>
                 <button class="slot-btn empty" data-slot="3"><div class="slot-label">3</div><div class="slot-info">Empty</div></button>
                 <button class="slot-btn empty" data-slot="4"><div class="slot-label">4</div><div class="slot-info">Empty</div></button>
                 <button class="slot-btn empty" data-slot="5"><div class="slot-label">5</div><div class="slot-info">Empty</div></button>
               </div>
               <div class="desc" style="margin-top:6px; text-align:center;">
                 <span id="slot-mode-desc">Click to LOAD a saved game.</span>
               </div>
            </div>
          </div>
        </details>
      </div>

      <div class="card">
        <details>
          <summary>
            <h3 style="display:inline-block; margin:0; font-size:14px; opacity:0.8">Expectations</h3>
             <div class="tiny" style="opacity:0.6; font-weight:400; margin-left: 4px; display:inline-block">(Click to expand)</div>
          </summary>
          <div style="margin-top:6px">
            <div class="row tiny" style="flex-direction:column;align-items:flex-start;gap:2px">
              <div>Ascent rate (per roll): <span class="mono" id="exp-win-rate">—</span></div>
              <div>Ruin rate (per roll): <span class="mono" id="exp-loss-rate">—</span></div>
              <div>p(Ascent | !Steady): <span id="recent-p-cond" class="mono">—</span></div>
              <div>p(Summit | current): <span id="recent-p-top" class="mono">—</span></div>
              <div style="margin-top:4px">average cycle length: <span class="mono" id="exp-cycle-len">—</span> rolls</div>
              <div>E[first Summit]: <span class="mono" id="exp-time-top">—</span> rolls</div>
              <div>Optimal Ascents/Hour: <span class="mono" id="exp-wins-hour">—</span></div>
            </div>
          </div>
        </details>
      </div>

      <div class="card"><h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Distributions</h3>
        <div class="tiny" style="margin-top:6px">Time spent at Height:</div>
        <div id="hist-k" class="tiny" style="margin-top:2px;min-height:24px"></div>
        <div class="tiny" style="margin-top:6px">Time spent at Poise:</div>
        <div id="hist-l" class="tiny" style="margin-top:2px;min-height:24px"></div>
        <div class="tiny" style="margin-top:6px">Height / Poise Heatmap:</div>
        <div id="hist-kl" class="tiny" style="margin-top:2px;min-height:32px"></div>
        
        <div class="tiny" style="margin-top:12px; font-weight:600; color:var(--muted)">Cycle Lengths (Global N=<span id="global-n">0</span>)</div>
        <div class="stats-grid" id="global-stats">
          <div class="stat-box"><div class="stat-label">Min</div><div class="stat-val" id="gs-min">—</div></div>
          <div class="stat-box"><div class="stat-label">25%</div><div class="stat-val" id="gs-25">—</div></div>
          <div class="stat-box"><div class="stat-label">Med</div><div class="stat-val" id="gs-50">—</div></div>
          <div class="stat-box"><div class="stat-label">75%</div><div class="stat-val" id="gs-75">—</div></div>
          <div class="stat-box"><div class="stat-label">Max</div><div class="stat-val" id="gs-max">—</div></div>
        </div>

        <div class="tiny" style="margin-top:8px">Cycle lengths (last 40):</div>
        <div id="hist-cycle-len" class="tiny" style="margin-top:2px"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* -------------------------------------------------------------------------- */
/* MODULE 0: UTILITIES & HELPERS                                             */
/* -------------------------------------------------------------------------- */

class BackgroundTimer {
  constructor() {
    const blob = new Blob([`
      const timers = new Map();
      self.onmessage = function(e) {
        const { id, type, delay } = e.data;
        if (type === 'clear') {
          const t = timers.get(id);
          if (t) { clearTimeout(t); clearInterval(t); timers.delete(id); }
        } else if (type === 'setTimeout') {
          const t = setTimeout(() => { self.postMessage({ id, type: 'timeout' }); timers.delete(id); }, delay);
          timers.set(id, t);
        } else if (type === 'setInterval') {
          const t = setInterval(() => { self.postMessage({ id, type: 'interval' }); }, delay);
          timers.set(id, t);
        }
      };
    `], { type: 'application/javascript' });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.callbacks = new Map();
    this.nextId = 1;
    this.worker.onmessage = (e) => {
      const cb = this.callbacks.get(e.data.id);
      if (cb) cb();
    };
  }
  setTimeout(cb, d) {
    const id = this.nextId++; this.callbacks.set(id, cb);
    this.worker.postMessage({ id, type: 'setTimeout', delay: d });
    return id;
  }
  setInterval(cb, d) {
    const id = this.nextId++; this.callbacks.set(id, cb);
    this.worker.postMessage({ id, type: 'setInterval', delay: d });
    return id;
  }
  clear(id) {
    if (!id) return;
    this.worker.postMessage({ id, type: 'clear' });
    this.callbacks.delete(id);
  }
}

class ProbabilityCache {
  constructor(maxSize = 400) {
    this.cache = new Map();
    this.maxSize = maxSize;
    this.hits = 0; this.misses = 0;
  }
  makeKey(k, l, p) {
    return `${k},${l},${p.w_min},${p.w_max},${p.beta},${p.rho},${p.gamma},${p.c_min},${p.c_max},${p.alpha},${p.M},${p.L}`;
  }
  get(k, l, p) {
    const key = this.makeKey(k, l, p);
    const result = this.cache.get(key);
    if (result) { this.hits++; return result; }
    this.misses++; return null;
  }
  set(k, l, p, probs) {
    if (this.cache.size >= this.maxSize) this.cache.delete(this.cache.keys().next().value);
    this.cache.set(this.makeKey(k, l, p), probs);
    return probs;
  }
  clear() { this.cache.clear(); this.hits=0; this.misses=0; }
  getStats() { return { hitRate: this.hits / (this.hits + this.misses) || 0 }; }
}

class AriaAnnouncer {
  constructor() { this.element = document.getElementById('aria-announcer'); }
  announce(msg) {
    this.element.textContent = msg;
    setTimeout(() => { this.element.textContent = ''; }, 1000);
  }
}

class PerformanceMonitor {
  constructor() {
    this.frameCount = 0; this.lastTime = performance.now(); this.fps = 0;
    this.element = document.getElementById('perf-indicator');
  }
  tick() {
    this.frameCount++;
    const now = performance.now();
    const delta = now - this.lastTime;
    if (delta >= 1000) {
      this.fps = Math.round(this.frameCount * 1000 / delta);
      this.frameCount = 0; this.lastTime = now;
      this.update();
    }
  }
  update() {
    const cs = SisyphusMath.probCache.getStats();
    this.element.textContent = `FPS: ${this.fps} | Cache: ${(cs.hitRate * 100).toFixed(0)}%`;
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 1: SISYPHUS MATH                                                   */
/* -------------------------------------------------------------------------- */
class SisyphusMath {
  static EPSILON = 1e-10;
  static probCache = new ProbabilityCache();
  
  static computeProbs(k, l, p) {
    const cached = this.probCache.get(k, l, p);
    if (cached) return cached;
    
    k = Math.round(k); l = Math.round(l);
    const M = Math.max(1, p.M | 0);
    const L = Math.max(1, p.L | 0);
    const frac = M > 1 ? (k - 1) / (M - 1) : 1;
    
    const base = p.w_min + (p.w_max - p.w_min) * Math.pow(frac, p.beta);
    const ell = (1 - p.rho) + p.rho * Math.pow(l / L, p.gamma);
    
    let p_win = Math.min(1, Math.max(0, base * ell));
    let p_loss = p.c_min + (p.c_max - p.c_min) * Math.exp(-p.alpha * l);
    
    const sum = p_win + p_loss;
    if (sum > 1 + this.EPSILON) { p_win /= sum; p_loss /= sum; }
    else if (sum > 1) { const scale = 1/sum; p_win *= scale; p_loss *= scale; }
    
    let p_neu = Math.max(0, 1 - p_win - p_loss);
    const total = p_win + p_neu + p_loss;
    if (Math.abs(total - 1) > this.EPSILON) { p_win/=total; p_neu/=total; p_loss/=total; }
    
    const result = { p_win, p_neu, p_loss };
    this.probCache.set(k, l, p, result);
    return result;
  }

  static getDelay(k, l, p) {
    if (p.max_delay <= 0) return 0;
    const kRatio = Math.max(0, (k - 1) / (p.M - 1 || 1));
    const lRatio = Math.max(0, l / (p.L || 1));
    const reduction = (0.8 * kRatio) + (0.2 * lRatio);
    const ms = (p.max_delay * 1000) * Math.pow(1 - Math.min(1, reduction), 3);
    if (ms < 20) return 0;
    return Math.max(100, ms); 
  }
  
  static clearCache() { this.probCache.clear(); }

  static solveExpectations(p) {
    const M = Math.max(1, p.M | 0);
    const L = Math.max(0, p.L | 0);
    
    const createGrid = () => Array.from({length: M + 1}, () => new Float64Array(L + 1));
    const TopHit = createGrid();
    const CycleLen = createGrid();
    const WinCount = createGrid();
    const TimeLen = createGrid();
    
    const maxIter = 400, tol = 1e-6;
    const lossDelay = SisyphusMath.getDelay(1, 0, p) / 1000;
    const s_w = p.s_w;
    const g_n = p.g_n;

    for (let it = 0; it < maxIter; it++) {
      let maxDiff = 0;
      for (let k = 1; k <= M; k++) {
        for (let l = 0; l <= L; l++) {
          const {p_win, p_neu, p_loss} = SisyphusMath.computeProbs(k, l, p);
          
          const l_win = (l - s_w) < 0 ? 0 : (l - s_w);
          const l_neu = (l + g_n) > L ? L : (l + g_n);

          let valTop = 0, valCyc = 0, valWin = 0, valTime = 0;
          
          if (k === M) {
             valTop = p_win + p_neu * TopHit[M][l_neu];
             valCyc = 1 + p_neu * CycleLen[M][l_neu];
             valWin = p_win + p_neu * WinCount[M][l_neu];
             const delayNeu = SisyphusMath.getDelay(k, l_neu, p) / 1000;
             const stepCost = (p_neu * delayNeu) + (p_loss * lossDelay); 
             valTime = stepCost + p_neu * TimeLen[M][l_neu];
          } else {
             valTop = p_win * TopHit[k+1][l_win] + p_neu * TopHit[k][l_neu];
             valCyc = 1 + p_win * CycleLen[k+1][l_win] + p_neu * CycleLen[k][l_neu];
             valWin = p_win * (1 + WinCount[k+1][l_win]) + p_neu * WinCount[k][l_neu];
             const delayWin = SisyphusMath.getDelay(k+1, l_win, p) / 1000;
             const delayNeu = SisyphusMath.getDelay(k, l_neu, p) / 1000;
             const stepCost = (p_win * delayWin) + (p_neu * delayNeu) + (p_loss * lossDelay);
             valTime = stepCost + p_win * TimeLen[k+1][l_win] + p_neu * TimeLen[k][l_neu];
          }

          const diff = Math.abs(valTop - TopHit[k][l]);
          if(diff > maxDiff) maxDiff = diff;
          
          TopHit[k][l] = valTop;
          CycleLen[k][l] = valCyc;
          WinCount[k][l] = valWin;
          TimeLen[k][l] = valTime;
        }
      }
      if (maxDiff < tol) break;
    }
    return { TopHit, CycleLen, WinCount, TimeLen };
  }

  static getQuantiles(data) {
    if (!data || data.length === 0) return null;
    const sorted = [...data].sort((a, b) => a - b);
    const q = (p) => {
      const pos = (sorted.length - 1) * p;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base + 1] !== undefined) return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
      return sorted[base];
    };
    return { min: sorted[0], q25: q(0.25), med: q(0.50), q75: q(0.75), max: sorted[sorted.length - 1] };
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 2: GAME MODEL                                                      */
/* -------------------------------------------------------------------------- */
class SisyphusModel {
  constructor() {
    this.params = {
      M:20, L:20, w_min:0.10, w_max:0.90, beta:1.5, rho:0.6, gamma:1.5,
      c_min:0.03, c_max:0.10, alpha:0.3, g_n:1, s_w:20, max_delay: 45.0
    };
    this.reset();
  }

  reset() {
    this.state = { k:1, l:0, step:0, topHit:false, cycleSteps:0 };
    this.stats = { wins:0, neus:0, loss:0, maxK:1, longestCycle:0 };
    this.historyK = [];
    this.cycleId = 1;
    this.currentCycle = this._newCycle();
    this.cycleSummaries = []; 
    this.allCycles = []; 
    this.startTime = Date.now();
    const M = Math.max(1, this.params.M);
    const L = Math.max(0, this.params.L);
    this.distributions = { 
      k: Array(M+1).fill(0), l: Array(L+1).fill(0), 
      kl: Array.from({length: M+1}, () => Array(L+1).fill(0)),
      cycles: []
    };
    this.lastRoll = null; 
  }

  _newCycle() { return { id: this.cycleId, length:0, wins:0, neus:0, maxK:this.state.k, path:'' }; }

  step() {
    if (this.state.topHit) return null;
    const k0 = this.state.k, l0 = this.state.l;
    const probs = SisyphusMath.computeProbs(k0, l0, this.params);
    const r = Math.random();
    
    let outcome = 'loss';
    let k1 = 1, l1 = 0;

    if (r < probs.p_win) {
      if (k0 === this.params.M) { outcome = 'top'; k1 = k0; l1 = l0; this.state.topHit = true; } 
      else { outcome = 'win'; k1 = Math.min(this.params.M, k0 + 1); l1 = Math.max(0, l0 - this.params.s_w); }
    } else if (r < probs.p_win + probs.p_neu) {
      outcome = 'neu'; k1 = k0; l1 = Math.min(this.params.L, l0 + this.params.g_n);
    }

    this.state.k = k1; this.state.l = l1; this.state.step++; this.state.cycleSteps++;
    
    if (outcome === 'win' || outcome === 'top') this.stats.wins++;
    else if (outcome === 'neu') this.stats.neus++;
    else if (outcome === 'loss') this.stats.loss++;

    if (outcome === 'loss' || outcome === 'top') {
      if (this.state.cycleSteps > this.stats.longestCycle) this.stats.longestCycle = this.state.cycleSteps;
      if (outcome === 'loss') this.state.cycleSteps = 0;
    }

    this.stats.maxK = Math.max(this.stats.maxK, k1);
    this.historyK.push(k1);
    if (this.historyK.length > 200) this.historyK.shift();

    this._updateCycle(outcome, k1);
    this._updateDistributions(k1, l1);

    this.lastRoll = { outcome, k0, l0, k1, l1 };
    return outcome;
  }

  _updateDistributions(k, l) {
    const d = this.distributions;
    if (d.k[k] !== undefined) d.k[k]++;
    if (d.l[l] !== undefined) d.l[l]++;
    if (d.kl[k] && d.kl[k][l] !== undefined) d.kl[k][l]++;
  }

  _updateCycle(outcome, k1) {
    const sym = { win:'+', neu:'.', loss:'X', top:'★' }[outcome];
    if (sym) {
      this.currentCycle.length++;
      if (outcome === 'win') this.currentCycle.wins++;
      if (outcome === 'neu') this.currentCycle.neus++;
      this.currentCycle.maxK = Math.max(this.currentCycle.maxK, k1);
      this.currentCycle.path += sym;
    }
    if (outcome === 'loss' || outcome === 'top') {
      this.allCycles.push(this.currentCycle.length);
      this.distributions.cycles.push(this.currentCycle.length);
      if (this.distributions.cycles.length > 40) this.distributions.cycles.shift();
      const summary = { ...this.currentCycle, outcome };
      this.cycleSummaries.unshift(summary);
      if (this.cycleSummaries.length > 7) this.cycleSummaries.pop();
      this.cycleId++;
      this.currentCycle = this._newCycle();
    }
  }

  setState(k, l) {
    this.state.k = Math.max(1, Math.min(this.params.M, k));
    this.state.l = Math.max(0, Math.min(this.params.L, l));
    this.historyK.push(this.state.k);
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 3: UI MANAGER                                                      */
/* -------------------------------------------------------------------------- */
class SisyphusUI {
  constructor(model) {
    this.model = model;
    this.els = {};
    this.pendingUpdates = new Map();
    this.rafId = null;
    
    ['rbar-win','rbar-neu','rbar-loss','rpct-win','rpct-neu','rpct-loss',
     'kpos-fill','kpos-text','lpos-fill','lpos-text','recent-p-cond','recent-p-top',
     'recent-outcome','recent-kl','recent-card',
     'bar-win','bar-neu','bar-loss','c-win','c-neu','c-loss',
     'r-win','r-neu','r-loss','run-steps','run-time','max-k',
     'cycle-box','hist-k','hist-l','hist-kl','hist-cycle-len',
     'global-n','gs-min','gs-25','gs-50','gs-75','gs-max',
     'exp-win-rate', 'exp-loss-rate', 'exp-cycle-len', 'exp-time-top', 'exp-wins-hour',
     'btn-roll-main'
    ].forEach(id => this.els[id] = document.getElementById(id));
  }
  
  batchUpdate(elementId, property, value) {
    if (!this.pendingUpdates.has(elementId)) this.pendingUpdates.set(elementId, {});
    this.pendingUpdates.get(elementId)[property] = value;
    if (!this.rafId) this.rafId = requestAnimationFrame(() => this.flushUpdates());
  }
  
  flushUpdates() {
    this.pendingUpdates.forEach((updates, elementId) => {
      const el = this.els[elementId];
      if (!el) return;
      for (const [prop, value] of Object.entries(updates)) {
        if (prop === 'textContent') el.textContent = value;
        else if (prop === 'className') el.className = value;
        else if (prop.startsWith('style.')) el.style[prop.substring(6)] = value;
      }
    });
    this.pendingUpdates.clear();
    this.rafId = null;
  }

  log(msg) {
    // Log box removed from UI. Method kept empty to prevent breakage.
  }

  _formatDuration(ms) {
    const s = Math.floor(ms / 1000);
    if(s < 60) return `${s}s`;
    const m = Math.floor(s / 60);
    if(m < 60) return `${m}m ${s%60}s`;
    const h = Math.floor(m / 60);
    if(h < 24) return `${h}h ${m%60}m`;
    const d = Math.floor(h / 24);
    return `${d}d ${h%24}h`;
  }

  render(grids, full = true) {
    const m = this.model, s = m.state, st = m.stats;
    const lr = m.lastRoll || { outcome:null, k0:1, l0:0, k1:s.k, l1:s.l };
    const pct = x => (100 * Math.max(0, Math.min(1, x))).toFixed(1) + '%';
    const probs = SisyphusMath.computeProbs(lr.k1, lr.l1, m.params);
    
    this.batchUpdate('recent-outcome', 'textContent', lr.outcome ? (lr.outcome === 'neu' ? 'STEADY' : lr.outcome === 'loss' ? 'RUIN' : lr.outcome === 'top' ? 'SUMMIT' : 'ASCENT') : '—');
    this.batchUpdate('recent-card', 'className', 'card recent ' + (lr.outcome === 'top' ? 'win' : lr.outcome || ''));

    this.batchUpdate('rbar-win', 'style.width', pct(probs.p_win));
    this.batchUpdate('rbar-neu', 'style.width', pct(probs.p_neu));
    this.batchUpdate('rbar-loss', 'style.width', pct(probs.p_loss));
    this.batchUpdate('rpct-win', 'textContent', pct(probs.p_win));
    this.batchUpdate('rpct-neu', 'textContent', pct(probs.p_neu));
    this.batchUpdate('rpct-loss', 'textContent', pct(probs.p_loss));

    const p_cond = (probs.p_win + probs.p_loss > 0) ? probs.p_win / (probs.p_win + probs.p_loss) : 0;
    this.batchUpdate('recent-p-cond', 'textContent', (probs.p_win+probs.p_loss < 1e-9) ? '—' : pct(p_cond));

    let pTopText = '—';
    if (grids && grids.TopHit && grids.TopHit[lr.k1] && typeof grids.TopHit[lr.k1][lr.l1] === 'number') {
      const p = grids.TopHit[lr.k1][lr.l1];
      const odds = p > 0 ? 1/p : Infinity;
      if (p < 0.0001) pTopText = `1 in ${odds > 1e6 ? odds.toExponential(2) : Math.round(odds).toLocaleString()}`;
      else if (p <= 0.5) pTopText = `1 in ${Math.round(odds).toLocaleString()} (${(p*100).toFixed(2)}%)`;
      else pTopText = `${(p*100).toFixed(1)}%`;
    }
    this.batchUpdate('recent-p-top', 'textContent', pTopText);

    this.batchUpdate('kpos-fill', 'style.width', pct(lr.k1 / m.params.M));
    this.batchUpdate('kpos-text', 'textContent', `${lr.k1} / ${m.params.M}`);
    this.batchUpdate('lpos-fill', 'style.width', pct(lr.l1 / m.params.L));
    this.batchUpdate('lpos-text', 'textContent', `${lr.l1} / ${m.params.L}`);

    const tot = st.wins + st.neus + st.loss;
    this.batchUpdate('run-steps', 'textContent', s.step);
    this.batchUpdate('c-win', 'textContent', st.wins);
    this.batchUpdate('c-neu', 'textContent', st.neus);
    this.batchUpdate('c-loss', 'textContent', st.loss);
    this.batchUpdate('r-win', 'textContent', tot ? (100*st.wins/tot).toFixed(1)+'%' : '0%');
    this.batchUpdate('r-neu', 'textContent', tot ? (100*st.neus/tot).toFixed(1)+'%' : '0%');
    this.batchUpdate('r-loss', 'textContent', tot ? (100*st.loss/tot).toFixed(1)+'%' : '0%');
    
    this.batchUpdate('bar-win', 'style.width', tot ? (100*st.wins/tot)+'%' : '0%');
    this.batchUpdate('bar-neu', 'style.width', tot ? (100*st.neus/tot)+'%' : '0%');
    this.batchUpdate('bar-loss', 'style.width', tot ? (100*st.loss/tot)+'%' : '0%');
    
    this.batchUpdate('run-time', 'textContent', this._formatDuration(Math.max(0, Date.now() - m.startTime)));
    this.batchUpdate('max-k', 'textContent', st.maxK);
    
    this._renderCycles();
    if(full) { this._renderDistributions(); this._renderGlobalStats(); }
  }

  _renderCycles() {
    const box = this.els['cycle-box'];
    const tpl = document.getElementById('tpl-cycle-entry');
    const fragment = document.createDocumentFragment();

    // Render Current Active Cycle First
    const current = this.model.currentCycle;
    if (current) {
        const clone = tpl.content.cloneNode(true);
        const div = clone.querySelector('.cycle-entry');
        div.classList.add('active'); // Add active style
        clone.querySelector('.cycle-main-text').textContent = `C${current.id}: ACTIVE`;
        clone.querySelector('.cycle-meta').textContent = `L:${current.length} A:${current.wins}`;
        let wrapped = '';
        for(let i=0; i<(current.path||'').length; i+=32) wrapped += current.path.slice(i, i+32) + '\n';
        clone.querySelector('.cycle-entry-path').textContent = wrapped || '-';
        fragment.appendChild(clone);
    }

    // Render Past Cycles
    this.model.cycleSummaries.forEach(c => {
      const clone = tpl.content.cloneNode(true);
      const div = clone.querySelector('.cycle-entry');
      div.classList.add(c.outcome === 'top' ? 'top' : 'loss');
      const outText = c.outcome === 'top' ? 'SUMMIT' : 'RUIN';
      clone.querySelector('.cycle-main-text').textContent = `C${c.id}: ${outText}`;
      clone.querySelector('.cycle-meta').textContent = `L:${c.length} A:${c.wins}`;
      let wrapped = '';
      for(let i=0; i<(c.path||'').length; i+=32) wrapped += c.path.slice(i, i+32) + '\n';
      clone.querySelector('.cycle-entry-path').textContent = wrapped || '-';
      fragment.appendChild(clone);
    });
    box.innerHTML = ''; box.appendChild(fragment);
  }

  _renderGlobalStats() {
    const ac = this.model.allCycles;
    this.els['global-n'].textContent = ac.length;
    const stats = SisyphusMath.getQuantiles(ac);
    if (stats) {
      this.els['gs-min'].textContent = stats.min;
      this.els['gs-25'].textContent = stats.q25.toFixed(1).replace('.0','');
      this.els['gs-50'].textContent = stats.med.toFixed(1).replace('.0','');
      this.els['gs-75'].textContent = stats.q75.toFixed(1).replace('.0','');
      this.els['gs-max'].textContent = stats.max;
    } else {
      ['gs-min','gs-25','gs-50','gs-75','gs-max'].forEach(id => this.els[id].textContent = '—');
    }
  }

  _renderDistributions() {
    const dist = this.model.distributions;
    const renderBar = (hostId, data) => {
      const host = this.els[hostId]; host.innerHTML = '';
      if(!data.length || !data.some(x=>x)) { host.textContent='—'; return; }
      const max = Math.max(...data.filter(n=>n));
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;align-items:flex-end;gap:2px';
      for(let i=(hostId==='hist-l'?0:1); i<data.length; i++){
        const bar = document.createElement('div');
        bar.style.cssText = `width:3px;border-radius:2px;background:linear-gradient(180deg,var(--accent-3),var(--accent-2));`;
        bar.style.height = (6 + (max ? 24 * (data[i]||0) / max : 0)) + 'px';
        wrap.appendChild(bar);
      }
      host.appendChild(wrap);
    };
    renderBar('hist-k', dist.k); renderBar('hist-l', dist.l);

    const hostCl = this.els['hist-cycle-len']; hostCl.innerHTML = '';
    if(dist.cycles.length) {
      const maxCL = Math.max(...dist.cycles);
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;align-items:flex-end;gap:2px';
      dist.cycles.forEach(len => {
        const bar = document.createElement('div');
        bar.style.cssText = 'width:4px;border-radius:2px;background:linear-gradient(180deg,var(--accent-3),var(--accent-2));';
        bar.style.height = (8 + (maxCL ? 32 * len / maxCL : 0)) + 'px';
        wrap.appendChild(bar);
      });
      hostCl.appendChild(wrap);
    } else hostCl.textContent = '—';

    const hostHM = this.els['hist-kl']; hostHM.innerHTML = '';
    const klData = dist.kl;
    let maxC = 0; klData.forEach(row => row.forEach(c => { if(c > maxC) maxC = c; }));
    
    if(maxC > 0) {
      const M = this.model.params.M;
      const L = this.model.params.L;
      const grid = document.createElement('div');
      grid.style.display = 'grid'; grid.style.gridTemplateColumns = `repeat(${M}, minmax(4px, 1fr))`; grid.style.gap = '1px';
      const logMax = Math.log(1+maxC);
      for(let l=L; l>=0; l--) {
        for(let k=1; k<=M; k++) {
          const c = (klData[k] && klData[k][l]) || 0;
          const cell = document.createElement('div');
          const alpha = c > 0 ? (0.15 + 0.85 * (Math.log(1+c)/logMax)) : 0.05;
          cell.style.background = `rgba(0,183,255,${alpha.toFixed(3)})`;
          cell.style.aspectRatio = '1/1'; cell.title = `(${k},${l}): ${c}`;
          grid.appendChild(cell);
        }
      }
      hostHM.appendChild(grid);
    } else hostHM.textContent = '—';
  }

  updateExpectations(grids) {
    const { TopHit, CycleLen, WinCount, TimeLen } = grids;
    const pCycleTop = TopHit[1][0];
    const c = CycleLen[1][0];
    const w = WinCount[1][0];
    const timePerCycle = TimeLen[1][0];
    const fmt = x => (100*x).toFixed(3)+'%';
    const el = id => document.getElementById(id);
    
    if(c > 0) {
      el('exp-win-rate').textContent = fmt(w/c);
      el('exp-loss-rate').textContent = fmt((1-pCycleTop)/c);
      el('exp-cycle-len').textContent = c.toFixed(1);
      
      if (pCycleTop > 1e-15) { 
        const expected = c / pCycleTop;
        el('exp-time-top').textContent = expected > 1e9 ? expected.toExponential(2) : expected.toFixed(1);
        if (this.model.params.max_delay <= 0) el('exp-wins-hour').textContent = "--";
        else el('exp-wins-hour').textContent = timePerCycle > 0.0001 ? ((w / timePerCycle) * 3600).toFixed(2) : "--";
      } else {
        if (pCycleTop === 0) { el('exp-time-top').textContent = '∞ (prob ≈ 0)'; el('exp-wins-hour').textContent = '0.00'; }
        else {
           el('exp-time-top').textContent = (c/pCycleTop).toExponential(2);
           el('exp-wins-hour').textContent = timePerCycle > 0.0001 ? ((w / timePerCycle) * 3600).toFixed(2) : "--";
        }
      }
    }
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 4: CHAOS ENGINE (OPTIMIZED RING BUFFER)                            */
/* -------------------------------------------------------------------------- */
class ChaosEngine {
  constructor() {
    this.canvas = document.getElementById('chaosCanvas');
    this.ctx = this.canvas.getContext('2d');
    this.statusEl = document.getElementById('weather-status-main');
    this.modEl = document.getElementById('weather-mod-val');
    
    this.SIGMA = 10; this.RHO = 28; this.BETA = 8/3; this.DT = 0.0025; 
    
    // START ON THE WING: Initialize near the attractor's "eye"
    // Randomized slightly so every reload is unique, but immediate.
    this.x = 10 + (Math.random() - 0.5) * 2; 
    this.y = 10 + (Math.random() - 0.5) * 2; 
    this.z = 25 + (Math.random() - 0.5) * 2;

    this.MAX_POINTS = 5000;
    this.points = new Array(this.MAX_POINTS).fill(null);
    this.head = 0; // Where the next point goes
    this.count = 0; // How many valid points we have
    
    this.angle = 0; this.rotSpeed = 0.005; 
    this.scale = 9; this.fov = 300; this.yOffset = 20;     
    this.multiplier = 1.0; 

    this.resize();
    window.addEventListener('resize', () => this.resize());
    this.animate();
  }
  
  resize() {
    if (this.canvas.parentElement) {
       this.canvas.width = this.canvas.parentElement.clientWidth;
       this.canvas.height = this.canvas.parentElement.clientHeight;
    }
  }
  
  step() {
    const dx = (this.SIGMA * (this.y - this.x)) * this.DT;
    const dy = (this.x * (this.RHO - this.z) - this.y) * this.DT;
    const dz = (this.x * this.y - this.BETA * this.z) * this.DT;
    this.x += dx; this.y += dy; this.z += dz;
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
  }
  
  updateWeather(velocity) {
    let intensity = (velocity * 40) / 30; 
    if(intensity > 1) intensity = 1;
    this.multiplier = 0.5 + (intensity * 2.0);
    if (this.modEl) this.modEl.textContent = this.multiplier.toFixed(2) + "x";

    let statusText = "", statusClass = "", color = "";
    if(intensity < 0.25) { statusText = "CALM"; statusClass = "weather-good"; color = "#ff9e2c"; } 
    else if (intensity < 0.6) { statusText = "WINDY"; statusClass = "weather-ok"; color = "#00b7ff"; } 
    else { statusText = "STORM"; statusClass = "weather-bad"; color = "#ff3333"; }

    if (this.statusEl) {
      this.statusEl.textContent = statusText;
      this.statusEl.className = "weather-status " + statusClass;
    }
    if (this.modEl) this.modEl.className = "mono " + statusClass;
    return color;
  }
  
  project(x, y, z, cx, cy) {
    const cosA = Math.cos(this.angle);
    const sinA = Math.sin(this.angle);
    const rx = x * cosA - y * sinA; 
    const ry = x * sinA + y * cosA; 
    const depth = this.fov / (this.fov + ry + 60); 
    return { x: cx + rx * this.scale * depth, y: (cy + this.yOffset) + (-(z - 25)) * this.scale * depth };
  }
  
    reset() {
    this.points.fill(null);
    this.count = 0;
    this.head = 0;
    
    // RESET TO WING
    this.x = 10 + (Math.random() - 0.5) * 2; 
    this.y = 10 + (Math.random() - 0.5) * 2; 
    this.z = 25 + (Math.random() - 0.5) * 2;
  }


  animate() {
    if (this.canvas.width === 0) return requestAnimationFrame(() => this.animate());

    const velocity = this.step();
    const color = this.updateWeather(velocity);
    
    this.points[this.head] = { x: this.x, y: this.y, z: this.z, color: color };
    this.head = (this.head + 1) % this.MAX_POINTS;
    if (this.count < this.MAX_POINTS) this.count++;
    
    this.angle += this.rotSpeed;

    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    const cx = this.canvas.width / 2;
    const cy = this.canvas.height / 2;
    
    if (this.count > 1) {
      this.ctx.lineWidth = 1.5;
      
      let idx = (this.count < this.MAX_POINTS) ? 0 : this.head;
      
      let p = this.points[idx];
      let prevProj = this.project(p.x, p.y, p.z, cx, cy);
      let currentColor = this.points[(idx + 1) % this.MAX_POINTS].color;
      
      this.ctx.beginPath();
      this.ctx.strokeStyle = currentColor;
      this.ctx.moveTo(prevProj.x, prevProj.y);
      
      for (let i = 1; i < this.count; i++) {
        idx = (idx + 1) % this.MAX_POINTS;
        p = this.points[idx];
        
        const proj = this.project(p.x, p.y, p.z, cx, cy);
        
        if (p.color !== currentColor) {
          this.ctx.stroke(); 
          this.ctx.beginPath();
          this.ctx.strokeStyle = p.color;
          this.ctx.moveTo(prevProj.x, prevProj.y); 
          currentColor = p.color;
        }
        
        this.ctx.lineTo(proj.x, proj.y);
        prevProj = proj;
      }
      this.ctx.stroke();
    }
    requestAnimationFrame(() => this.animate());
  }
  
  getModifier() { return this.multiplier; }
}

/* -------------------------------------------------------------------------- */
/* MODULE 5: GAME CONTROLLER                                                 */
/* -------------------------------------------------------------------------- */
class GameController {
  constructor() {
    this.model = new SisyphusModel();
    this.ui = new SisyphusUI(this.model);
    this.chaos = new ChaosEngine();
    
    this.autoTimerId = null;
    this.bgTimer = new BackgroundTimer(); 
    this.renderReq = null;
    this.isAuto = false;
    this.controlsLocked = false;
    this.grids = null;
    this.announcer = new AriaAnnouncer();
    this.perfMonitor = new PerformanceMonitor();
    this.slotMode = 'load'; 

    setInterval(() => {
      if (this.ui) {
        const elapsed = Math.max(0, Date.now() - this.model.startTime);
        const el = document.getElementById('run-time');
        if (el) el.textContent = this.ui._formatDuration(elapsed);
      }
    }, 1000);
    
    this.bindEvents();
    this.bindKeyboard();
    this.load(); 
    this.recalcExpectations();
    this.ui.render(this.grids, true); 
    this.updateSlotUI();
    
    // First Ascent Modal check
    if (!localStorage.getItem('sisyphus_welcome_seen')) {
      document.getElementById('welcome-modal').classList.add('show');
    }
  }

  bindEvents() {
    const $ = id => document.getElementById(id);
    $('roll1_big').onclick = () => this.stepManually();
    $('rollN').onclick = () => {
      const n = +$('nRolls').value || 20;
      for(let i=0; i<n; i++) { if(this.model.step() === 'top') break; }
      this.ui.render(this.grids); this.save();
    };
    $('rollNCycles').onclick = () => {
      const target = this.model.cycleId + (+$('nRolls').value || 1);
      let safety = 0;
      while(this.model.cycleId < target && safety++ < 2000000) { if(this.model.step() === 'top') break; }
      this.ui.render(this.grids); this.save();
    };
    $('auto').onclick = () => this.toggleAuto();
    $('apply').onclick = () => this.applyParams();
    $('resetState').onclick = () => this.reset();
    $('setStateBtn').onclick = () => {
      this.model.setState(+$('set-k').value||1, +$('set-l').value||0);
      this.ui.render(this.grids);
    }
    
    document.querySelectorAll('.slot-mode-btn').forEach(b => b.addEventListener('click', (e) => this.setSlotMode(e.target.dataset.mode)));
    document.querySelectorAll('.slot-btn').forEach(b => b.addEventListener('click', (e) => this.handleSlotAction(e.currentTarget.dataset.slot)));
  }

  setSlotMode(mode) {
    this.slotMode = mode;
    const container = document.getElementById('slot-container');
    const desc = document.getElementById('slot-mode-desc');
    document.querySelectorAll('.slot-mode-btn').forEach(b => {
      if(b.dataset.mode === mode) b.classList.add('active'); else b.classList.remove('active');
    });
    container.classList.remove('mode-save', 'mode-load');
    container.classList.add('mode-' + mode);
    desc.textContent = mode === 'save' ? "Click a slot to SAVE current run." : "Click a slot to LOAD a saved game.";
  }

  handleSlotAction(slotId) {
    const key = `sisyphus_slot_${slotId}`;
    if (this.slotMode === 'save') {
      if (localStorage.getItem(key) && !confirm(`Overwrite Slot ${slotId}?`)) return;
      this.saveToSlot(slotId);
    } else {
      if (!localStorage.getItem(key)) return;
      if ((this.model.state.step > 0 || this.model.cycleId > 1) && !confirm(`Load Slot ${slotId}? Current unsaved progress will be lost.`)) return;
      this.loadFromSlot(slotId);
    }
  }

  saveToSlot(id) {
    localStorage.setItem(`sisyphus_slot_${id}`, JSON.stringify(this.serialize()));
    this.updateSlotUI();
    this.announcer.announce(`Saved to Slot ${id}`);
  }

  loadFromSlot(id) {
    const raw = localStorage.getItem(`sisyphus_slot_${id}`);
    if (raw) {
      this.deserialize(JSON.parse(raw));
      this.announcer.announce(`Loaded Slot ${id}`);
      Object.keys(this.model.params).forEach(k => { const el = document.getElementById(k); if(el) el.value = this.model.params[k]; });
      this.recalcExpectations();
      this.ui.render(this.grids, true);
      this.chaos.reset(); // Clear chaos trail on load
      
      // Ensure Goal text matches loaded params
      const lblM = document.getElementById('lbl-M-goal');
      if(lblM) lblM.textContent = this.model.params.M;
    }
  }

  updateSlotUI() {
    for(let i=1; i<=5; i++) {
      const btn = document.querySelector(`.slot-btn[data-slot="${i}"]`);
      const raw = localStorage.getItem(`sisyphus_slot_${i}`);
      const infoDiv = btn.querySelector('.slot-info');
      if (raw) {
        btn.classList.add('has-data'); btn.classList.remove('empty');
        try {
          const d = JSON.parse(raw);
          infoDiv.textContent = `k:${d.state.k} ℓ:${d.state.l}\nSteps:${d.state.step}`;
        } catch(e) { infoDiv.textContent = "Error"; }
      } else {
        btn.classList.remove('has-data'); btn.classList.add('empty'); infoDiv.textContent = "Empty";
      }
    }
  }
  
  bindKeyboard() {
    document.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
      const modal = document.getElementById('help-modal');
      switch(e.key) {
        case ' ': case 'Enter': e.preventDefault(); if (!modal.classList.contains('show')) this.stepManually(); break;
        case 'r': case 'R': if (!e.ctrlKey) { e.preventDefault(); this.reset(); } break;
        case 'a': case 'A': e.preventDefault(); this.toggleAuto(); break;
        case '?': e.preventDefault(); modal.classList.toggle('show'); break;
        case 'Escape': if (modal.classList.contains('show')) { e.preventDefault(); modal.classList.remove('show'); } break;
      }
    });
  }

  getDynamicDelay() {
    const base = SisyphusMath.getDelay(this.model.state.k, this.model.state.l, this.model.params);
    return base === 0 ? 0 : base * this.chaos.getModifier();
  }

  stepManually() {
    if (this.controlsLocked) return;
    if(this.isAuto) this.toggleAuto();
    
    const res = this.model.step();
    this.handleStepResult(res); 
    this.ui.render(this.grids);
    this.save();

    if (res !== 'top') {
      const delay = this.getDynamicDelay();
      if (delay > 0) this.lockControls(delay, res);
    }
  }

  lockControls(duration, outcome) {
    this.controlsLocked = true;
    const btn = document.getElementById('roll1_big');
    const mainSpan = document.getElementById('btn-roll-main');
    btn.disabled = true;
    btn.className = `btn big outcome-${outcome}`; 
    
    const verb = { win:'ASCENDING', loss:'THE STONE FALLS', neu:'BUILDING POISE' }[outcome] || 'WAITING';
    const endTime = Date.now() + duration;
    
    const timerId = this.bgTimer.setInterval(() => {
      const remaining = endTime - Date.now();
      if (remaining <= 0) {
        this.bgTimer.clear(timerId);
        this.controlsLocked = false;
        btn.disabled = false;
        btn.className = 'btn big';
        mainSpan.textContent = "ROLL";
      } else {
        mainSpan.textContent = `${verb} · ${(Math.max(0, remaining)/1000).toFixed(1)}s`;
      }
    }, 50);
  }

  toggleAuto() {
    const btn = document.getElementById('auto');
    if (this.isAuto) {
      if (this.autoTimerId) { this.bgTimer.clear(this.autoTimerId); this.autoTimerId = null; }
      if (this.renderReq) { cancelAnimationFrame(this.renderReq); this.renderReq = null; }
      this.isAuto = false; btn.textContent = 'Auto Play';
      this.ui.render(this.grids, true);
    } else {
      this.isAuto = true; btn.textContent = 'Stop';
      let frameCount = 0;
      const renderLoop = () => {
        if(!this.isAuto) return;
        frameCount++;
        this.ui.render(this.grids, frameCount % 60 === 0);
        this.perfMonitor.tick();
        this.renderReq = requestAnimationFrame(renderLoop);
      };
      renderLoop();

      const logicLoop = () => {
        if (!this.isAuto) return;
        if (this.model.state.topHit) { this.toggleAuto(); return; }

        const res = this.model.step();
        this.handleStepResult(res);
        if (res === 'top') { this.toggleAuto(); this.ui.render(this.grids, true); return; }

        const useDelay = document.getElementById('use-delay').checked;
        let delay = useDelay ? (this.getDynamicDelay() || 50) : (+document.getElementById('speed').value || 100);
        if (!useDelay && delay < 20) for(let i=0; i<9; i++) if(!this.model.state.topHit) this.model.step();

        this.autoTimerId = this.bgTimer.setTimeout(logicLoop, delay);
      };
      logicLoop();
    }
  }

  handleStepResult(res) {
    if (res === 'top') { this.announcer.announce("Congratulations! Summit reached!"); alert("Summit Reached!"); }
    else if (res === 'win') this.announcer.announce(`Ascent! Now at Height ${this.model.state.k}`);
    else if (res === 'loss') this.announcer.announce("Ruin. Reset to Height 1");
    else if (res === 'neu') this.announcer.announce("Steady. Poise increased");
    if(res && res !== 'top') this.ui.log(`step ${this.model.state.step}: ${this.model.lastRoll.outcome.toUpperCase()}`);
  }

  applyParams() {
    const p = this.model.params;
    ['M','L','w_min','w_max','beta','rho','gamma','c_min','c_max','alpha','g_n','s_w','max_delay'].forEach(k => {
      const el = document.getElementById(k); if(el) p[k] = +el.value;
    });

    // Update goal description
    const lblM = document.getElementById('lbl-M-goal');
    if(lblM) lblM.textContent = p.M;

    SisyphusMath.clearCache();
    this.reset(); 
  }

  reset() {
    this.model.reset();
    this.chaos.reset(); 
    this.recalcExpectations();
    this.ui.render(this.grids, true);
    // Log clear removed
    this.save();
    this.announcer.announce("Game reset");
  }

  recalcExpectations() {
    this.grids = SisyphusMath.solveExpectations(this.model.params);
    this.ui.updateExpectations(this.grids);
  }

  serialize() {
    return {
      params: this.model.params, state: this.model.state, stats: this.model.stats,
      historyK: this.model.historyK, cycleSummaries: this.model.cycleSummaries,
      distributions: this.model.distributions, allCycles: this.model.allCycles,
      lastRoll: this.model.lastRoll, cycleId: this.model.cycleId,
      currentCycle: this.model.currentCycle, startTime: this.model.startTime
    };
  }

  deserialize(data) {
    Object.assign(this.model.params, data.params); Object.assign(this.model.state, data.state);
    Object.assign(this.model.stats, data.stats);
    if(data.historyK) this.model.historyK = data.historyK;
    if(data.cycleSummaries) this.model.cycleSummaries = data.cycleSummaries;
    if(data.distributions) this.model.distributions = data.distributions;
    if(data.allCycles) this.model.allCycles = data.allCycles;
    if(data.lastRoll) this.model.lastRoll = data.lastRoll;
    if(data.cycleId) this.model.cycleId = data.cycleId;
    if(data.currentCycle) this.model.currentCycle = data.currentCycle;
    if(data.startTime) this.model.startTime = data.startTime;
    else this.model.startTime = Date.now();
  }

  save() {
    localStorage.setItem('sisyphus_v9_delay', JSON.stringify(this.serialize()));
  }

  load() {
    try {
      const raw = localStorage.getItem('sisyphus_v9_delay') || localStorage.getItem('sisyphus_v8_optimized'); 
      if(raw) {
        this.deserialize(JSON.parse(raw));
        Object.keys(this.model.params).forEach(k => { const el = document.getElementById(k); if(el) el.value = this.model.params[k]; });
        // Set goal text on load
        const lblM = document.getElementById('lbl-M-goal');
        if(lblM) lblM.textContent = this.model.params.M;
      }
    } catch(e) { console.warn("Load failed", e); }
  }
}

document.addEventListener('DOMContentLoaded', () => { window.game = new GameController(); });

</script>
</body>
</html>
