<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>D20 Catastrophe</title>
<style>
  :root{
    --bg: #0b0f1c;
    --panel: #10172a;
    --edge: #1b2a4a;
    --text: #e6f0ff;
    --muted: #9ab3ff;
    --neon-cyan: #00e5ff;
    --neon-pink: #ff3df0;
    --neon-green: #00ff9c;
    --neon-red: #ff3b3b;
    --neon-blue: #4da6ff;
    --neon-gold: #ffd166;
    --shadow: 0 0 20px rgba(0,229,255,0.25), 0 0 60px rgba(255,61,240,0.12);
    --radius: 18px;
  }

  html, body {
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(255,61,240,0.07), transparent 60%),
      radial-gradient(1200px 600px at 110% 110%, rgba(0,229,255,0.08), transparent 60%),
      var(--bg);
    color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    margin: 0;
    -webkit-text-size-adjust: 100%;
    overflow-x: hidden;
  }

  * { box-sizing: border-box; }

  .wrap {
    max-width: 1100px;
    margin: 12px auto 56px;
    padding: 12px;
    padding-left: max(12px, env(safe-area-inset-left));
    padding-right: max(12px, env(safe-area-inset-right));
  }

  header h1{
    margin: 0 0 6px 0;
    font-weight: 800;
    letter-spacing: .5px;
    text-shadow: 0 0 10px rgba(0,229,255,.4);
    font-size: clamp(20px, 5.5vw, 28px);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  header p {
    margin: 0 0 18px 0;
    color: var(--muted);
    font-size: clamp(.9rem, 3.6vw, .95rem);
  }

  /* D20 logo */
  .logo-d20{
    width: clamp(22px, 6.5vw, 28px);
    height: clamp(22px, 6.5vw, 28px);
    flex: 0 0 auto;
    filter: drop-shadow(0 0 6px rgba(0,229,255,.45)) drop-shadow(0 0 10px rgba(255,61,240,.25));
  }
  .logo-d20 .edge{ stroke: url(#g1); stroke-width: 2; fill: none; }
  .logo-d20 .face{ fill: rgba(0,229,255,.08); stroke: none; }
  .logo-d20 text{
    font: 900 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
    fill: #e6f0ff;
    letter-spacing: .5px;
  }

  .grid {
    display: grid;
    grid-template-columns: 1.1fr .9fr;
    gap: 16px;
  }
  @media (max-width: 840px){
    .grid { grid-template-columns: 1fr; }
  }

  .card {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)) , var(--panel);
    border: 1px solid var(--edge);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 14px;
  }

  .last-roll {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    align-items: center;
  }

  .roll-result {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 12px;
    align-items: center;
    padding: 14px;
    border-radius: 16px;
    border: 1px solid var(--edge);
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
  }

  @media (max-width: 480px){
    .roll-result{
      grid-template-columns: auto 1fr;
      grid-template-areas:
        "num label"
        "steps steps";
    }
    .roll-result .roll-number { grid-area: num; }
    .roll-result > div:nth-child(2) { grid-area: label; }
    .roll-result > div:nth-child(3) { grid-area: steps; justify-self: start; margin-top: 6px; }
  }

  .roll-number {
    font-size: clamp(40px, 20vw, 56px);
    font-weight: 900;
    line-height: 1;
    letter-spacing: 1px;
    min-width: 64px;
    text-align: center;
    filter: drop-shadow(0 0 18px rgba(255,255,255,0.04));
  }
  .roll-label {
    font-weight: 800;
    font-size: clamp(15px, 4.2vw, 18px);
    letter-spacing: .6px;
    text-transform: uppercase;
    opacity: .95;
  }
  .roll-sub {
    color: var(--muted);
    font-size: clamp(12px, 3.4vw, 13px);
  }

  .badge {
    font-weight: 700;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid var(--edge);
    background: rgba(255,255,255,0.03);
    font-size: 12px;
    letter-spacing: .4px;
  }

  .state-win    { color: var(--neon-green); text-shadow: 0 0 14px rgba(0,255,156,.4); }
  .state-loss   { color: var(--neon-red);   text-shadow: 0 0 14px rgba(255,59,59,.4); }
  .state-neutral{ color: var(--neon-blue);  text-shadow: 0 0 14px rgba(77,166,255,.35); }
  .state-top    { color: var(--neon-gold);  text-shadow: 0 0 14px rgba(255,209,102,.45); }

  @keyframes flashWin { 0%{box-shadow: 0 0 0 rgba(0,255,156,.0);} 35%{box-shadow: 0 0 28px rgba(0,255,156,.55);} 100%{box-shadow: 0 0 0 rgba(0,255,156,.0);} }
  @keyframes flashCat { 0%{box-shadow: 0 0 0 rgba(255,59,59,.0);} 35%{box-shadow: 0 0 34px rgba(255,59,59,.6);} 100%{box-shadow: 0 0 0 rgba(255,59,59,.0);} }
  .flash-win { animation: flashWin 420ms ease-out; }
  .flash-cat { animation: flashCat 520ms ease-out; }

  .stats-grid {
    display: grid;
    grid-template-columns: repeat(2,1fr);
    gap: 10px;
  }
  @media (max-width: 480px){
    .stats-grid { grid-template-columns: 1fr; }
  }
  .stat {
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid var(--edge);
    background: rgba(255,255,255,0.02);
  }
  .stat h3 {
    margin: 0 0 6px 0;
    font-size: 11px;
    font-weight: 800;
    letter-spacing: .6px;
    color: var(--muted);
    text-transform: uppercase;
  }
  .stat .value {
    font-weight: 900;
    font-size: clamp(18px, 6vw, 24px);
    letter-spacing: .5px;
  }
  .row {
    display: grid;
    grid-template-columns: repeat(2,1fr);
    gap: 8px;
    margin-top: 6px;
  }

  .canv-wrap {
    border: 1px solid var(--edge);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(0,229,255,0.07), rgba(255,61,240,0.06));
    padding: 8px;
  }
  .canv-title{
    font-size: 12px;
    letter-spacing: .4px;
    color: var(--muted);
    margin: 0 0 6px 2px;
    text-transform: uppercase;
    font-weight: 800;
  }
  canvas { width: 100%; height: 80px; display:block; border-radius: 8px; background: #0a1224; }
  .hist canvas { height: 120px; }

  .controls {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin-top: 6px;
  }
  @media (max-width: 520px){
    .controls { grid-template-columns: 1fr 1fr; }
  }
  button {
    appearance: none;
    border: 1px solid var(--edge);
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    color: var(--text);
    padding: 14px 12px;
    border-radius: 14px;
    font-weight: 800;
    letter-spacing: .5px;
    text-transform: uppercase;
    cursor: pointer;
    transition: transform .05s ease, box-shadow .2s ease, border-color .2s ease;
    box-shadow: 0 0 0 rgba(0,0,0,0);
    user-select: none;
    font-size: clamp(12px, 3.4vw, 14px);
  }
  button:hover { transform: translateY(-1px); border-color: var(--neon-cyan); box-shadow: 0 0 18px rgba(0,229,255,.25); }
  button:active { transform: translateY(0); }
  .btn-primary { border-color: var(--neon-cyan); box-shadow: 0 0 14px rgba(0,229,255,.25) inset; }
  .btn-danger  { border-color: var(--neon-red); }
  .btn-warn    { border-color: var(--neon-gold); }
  .btn-on      { box-shadow: 0 0 18px rgba(0,229,255,.4), inset 0 0 18px rgba(0,229,255,.18); }

  footer {
    margin-top: 18px;
    font-size: 12px;
    color: var(--muted);
    text-align: center;
    padding-bottom: max(8px, env(safe-area-inset-bottom));
  }
  code.small {
    color: var(--neon-cyan);
    background: rgba(0,229,255,0.08);
    padding: 1px 6px;
    border-radius: 8px;
    border: 1px solid rgba(0,229,255,0.22);
  }
  .save-link{
    display:inline-block;margin-top:6px;opacity:.8
  }
  .save-link a{ color: var(--neon-cyan); text-decoration: none; border-bottom: 1px dotted var(--neon-cyan); }
  .save-link a:hover{ opacity: .9; }

  /* NEW: Stats panel styles */
  .math-card .kv{
    display:grid; grid-template-columns: 1fr auto;
    gap:6px; align-items:center;
    font-size: clamp(12px,3.4vw,14px);
    padding:8px 10px; border:1px solid var(--edge); border-radius:10px;
    background: rgba(255,255,255,0.02); margin-bottom:8px;
  }
  .math-card .kv .label{ color: var(--muted); }
  .math-card .kv .value{ font-weight:800; letter-spacing:.3px; }
  .math-card small.note{ color: var(--muted); display:block; margin-top:4px; }
</style>
</head>
<body>
  <div class="wrap" id="app">
    <header>
      <h1>
        <!-- Neon D20 icon -->
        <svg class="logo-d20" viewBox="0 0 64 64" aria-hidden="true">
          <defs>
            <linearGradient id="g1" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0" stop-color="#00e5ff"/>
              <stop offset="1" stop-color="#ff3df0"/>
            </linearGradient>
          </defs>
          <polygon class="face" points="32,6 49,18 54,34 32,58 10,34 15,18"/>
          <path class="edge" d="M32 6 L49 18 L54 34 L32 58 L10 34 L15 18 Z"/>
          <path class="edge" d="M32 6 L32 22 M49 18 L37 26 M15 18 L27 26 M10 34 L22 34 M54 34 L42 34 M32 58 L32 44"/>
          <path class="edge" d="M27 26 L37 26 L42 34 L32 44 L22 34 Z"/>
          <text x="32" y="36" text-anchor="middle">20</text>
        </svg>
        D20 Catastrophe
      </h1>
      <p>Hit the threshold (≥ <span id="thresholdHdr">20</span>) to <span class="state-win">win</span> and expand the range — at the peak <code class="small">k = 19</code>, the next win triggers a <span class="state-top">TOP HIT</span> and you reset to <code class="small">k = 1</code>. Rolling <code class="small">1</code> is a <span class="state-loss">catastrophe</span> that also resets to <code class="small">k = 1</code>.</p>
    </header>

    <div class="grid">
      <section class="card last-roll">
        <div class="roll-result" id="rollCard" aria-live="polite" aria-atomic="true">
          <div class="roll-number" id="lastRoll">—</div>
          <div>
            <div class="roll-label" id="lastOutcome">Press Roll</div>
            <div class="roll-sub">
              k = <span id="kVal">1</span> · Win threshold: <span id="threshold">≥ 20</span>
            </div>
          </div>
          <div>
            <span class="badge">Steps: <span id="steps">0</span></span>
          </div>
        </div>

        <div class="canv-wrap">
          <div class="canv-title">Recent k</div>
          <canvas id="spark"></canvas>
        </div>

        <div class="controls">
          <button id="rollBtn" class="btn-primary" title="R / Space">Roll</button>
          <button id="autoBtn" title="A to toggle">Auto</button>
          <button id="stopBtn" class="btn-warn" title="S">Stop</button>
          <button id="resetBtn" class="btn-danger" title="X">Reset</button>
        </div>
      </section>

      <aside class="card">
        <div class="stats-grid">
          <div class="stat">
            <h3>Wins</h3>
            <div class="value state-win" id="wins">0</div>
            <div class="row">
              <div class="stat" style="margin:8px 0 0 0;">
                <h3>Top Hits</h3>
                <div class="value state-top" id="topHits">0</div>
              </div>
              <div class="stat" style="margin:8px 0 0 0;">
                <h3>Current k</h3>
                <div class="value" id="kValBig">1</div>
              </div>
            </div>
          </div>
          <div class="stat">
            <h3>Losses</h3>
            <div class="value state-loss" id="losses">0</div>
            <div class="row">
              <div class="stat" style="margin:8px 0 0 0;">
                <h3>Neutrals</h3>
                <div class="value state-neutral" id="neutrals">0</div>
              </div>
              <div class="stat" style="margin:8px 0 0 0;">
                <h3>Catastrophes</h3>
                <div class="value state-loss" id="cats">0</div>
              </div>
            </div>
          </div>
        </div>

        <div class="canv-wrap hist" style="margin-top:12px;">
          <div class="canv-title">Time at each k</div>
          <canvas id="hist"></canvas>
          <div class="save-link">
            <a href="#" id="clearSave">Clear saved state</a>
          </div>
        </div>

        <!-- NEW: Live Stats card -->
        <div class="card math-card" style="margin-top:12px;">
          <div class="canv-title">Live Stats</div>

          <div class="kv"><span class="label">Top hit before catastrophe</span><span class="value" id="statTopFirst">—</span></div>
          <div class="kv"><span class="label">Catastrophe before top hit</span><span class="value" id="statCatFirst">—</span></div>
          <div class="kv"><span class="label">Expected rolls to reset</span><span class="value" id="statERolls">—</span></div>
          <div class="kv"><span class="label">Expected wins before reset</span><span class="value" id="statEWins">—</span></div>
          <div class="kv"><span class="label">Long-run top-hit rate (per roll)</span><span class="value" id="statTopRate">—</span></div>
          <div class="kv"><span class="label">Long-run time at current k</span><span class="value" id="statFk">—</span></div>

          <small class="note">Formulas: \(P_{\text{top first}}=k/20\), \(E[\text{rolls to reset}]=20-k\), \(E[\text{wins}]=k(H_{19}-H_k+\tfrac1{20})\), \(f_k=\frac{20}{19k(k+1)}\).</small>
        </div>
      </aside>
    </div>

    <footer>
      Shortcuts: <code class="small">R</code>/<code class="small">Space</code> = Roll ·
      <code class="small">A</code> = Auto/Stop ·
      <code class="small">S</code> = Stop ·
      <code class="small">X</code> = Reset
    </footer>
  </div>

<script>
/* =========================
   D20 Catastrophe (with Save/Restore + Live Stats)
   ========================= */

/* ---------- Persistence ---------- */
const STORAGE_KEY = 'd20c_state_v1';

function saveState(){
  try{
    const payload = {
      k: state.k,
      steps: state.steps,
      wins: state.wins,
      losses: state.losses,
      neutrals: state.neutrals,
      catastrophes: state.catastrophes,
      topHits: state.topHits,
      lastRoll: state.lastRoll,
      lastOutcome: state.lastOutcome,
      recentK: state.recentK.slice(-200),
      histK: state.histK.slice(0, 20),
      savedAt: Date.now(),
      v: 1
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }catch(e){}
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;
    const data = JSON.parse(raw);
    if (!data || data.v !== 1) return false;

    const clampInt = (x, lo, hi, def=lo)=> Number.isFinite(x) ? Math.max(lo, Math.min(hi, Math.trunc(x))) : def;

    state.k = clampInt(data.k, 1, 19, 1);
    state.steps = clampInt(data.steps, 0, 1e9, 0);
    state.wins = clampInt(data.wins, 0, 1e9, 0);
    state.losses = clampInt(data.losses, 0, 1e9, 0);
    state.neutrals = clampInt(data.neutrals, 0, 1e9, 0);
    state.catastrophes = clampInt(data.catastrophes, 0, 1e9, 0);
    state.topHits = clampInt(data.topHits, 0, 1e9, 0);
    state.lastRoll = (typeof data.lastRoll === 'number' && data.lastRoll >= 1 && data.lastRoll <= 20) ? data.lastRoll : null;
    state.lastOutcome = (typeof data.lastOutcome === 'string') ? data.lastOutcome : '—';
    state.recentK = Array.isArray(data.recentK) ? data.recentK.map(v=>clampInt(v,1,19,1)).slice(-200) : [state.k];
    state.histK = Array.isArray(data.histK) && data.histK.length >= 20
      ? data.histK.slice(0,20).map(v=>clampInt(v,0,1e9,0))
      : Array(20).fill(0);

    return true;
  }catch(e){ return false; }
}

function clearSavedState(){
  try{ localStorage.removeItem(STORAGE_KEY); }catch(e){}
}

/* ---------- Game State ---------- */
const state = {
  k: 1, steps: 0,
  wins: 0, losses: 0, neutrals: 0, catastrophes: 0, topHits: 0,
  lastRoll: null, lastOutcome: '—',
  autoTimer: null,
  recentK: [], histK: Array(20).fill(0)
};

const els = {
  rollCard: document.getElementById('rollCard'),
  lastRoll: document.getElementById('lastRoll'),
  lastOutcome: document.getElementById('lastOutcome'),
  kVal: document.getElementById('kVal'),
  kValBig: document.getElementById('kValBig'),
  threshold: document.getElementById('threshold'),
  thresholdHdr: document.getElementById('thresholdHdr'),
  steps: document.getElementById('steps'),
  wins: document.getElementById('wins'),
  losses: document.getElementById('losses'),
  neutrals: document.getElementById('neutrals'),
  cats: document.getElementById('cats'),
  topHits: document.getElementById('topHits'),
  spark: document.getElementById('spark'),
  hist: document.getElementById('hist'),
  rollBtn: document.getElementById('rollBtn'),
  autoBtn: document.getElementById('autoBtn'),
  stopBtn: document.getElementById('stopBtn'),
  resetBtn: document.getElementById('resetBtn'),
  clearSave: document.getElementById('clearSave'),
  // NEW: live stats fields
  statTopFirst: document.getElementById('statTopFirst'),
  statCatFirst: document.getElementById('statCatFirst'),
  statERolls: document.getElementById('statERolls'),
  statEWins: document.getElementById('statEWins'),
  statTopRate: document.getElementById('statTopRate'),
  statFk: document.getElementById('statFk')
};

/* ---------- Audio (soft) ---------- */
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}
function beep(type='neutral'){
  try {
    ensureAudio();
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    let freq = 440, dur = 0.05, vol = 0.06;

    if (type === 'win')        { freq = 880;  dur = 0.07; vol = 0.07; }
    else if (type === 'cat')   { freq = 220;  dur = 0.09; vol = 0.08; }
    else if (type === 'top')   { freq = 1200; dur = 0.08; vol = 0.08; }

    o.type = 'triangle';
    o.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    o.connect(g).connect(audioCtx.destination);
    o.start(now);
    o.stop(now + dur + 0.02);
  } catch(e) { /* optional */ }
}

/* ---------- Core mechanics ---------- */
function rand20(){ return Math.floor(Math.random() * 20) + 1; }
function currentThreshold(k = state.k){ return 21 - k; }

function applyRoll(r){
  const thr = currentThreshold();
  let outcome = 'neutral';
  let flashClass = null;
  let sound = 'neutral';

  if (r === 1){
    state.catastrophes++;
    state.losses++;
    state.k = 1;
    outcome = 'cat';
    flashClass = 'flash-cat';
    sound = 'cat';
  } else if (r >= thr){
    state.wins++;
    if (state.k < 19){
      state.k++;
      outcome = 'win';
      flashClass = 'flash-win';
      sound = 'win';
    } else {
      state.topHits++;
      outcome = 'top';
      state.k = 1;
      flashClass = 'flash-win';
      sound = 'top';
    }
  } else {
    state.neutrals++;
    state.losses++;
    outcome = 'neutral';
  }

  state.steps++;
  state.lastRoll = r;
  state.lastOutcome = outcome;

  state.histK[state.k] = (state.histK[state.k] || 0) + 1;

  state.recentK.push(state.k);
  if (state.recentK.length > 200) state.recentK.shift();

  if (flashClass){
    els.rollCard.classList.remove('flash-win','flash-cat');
    void els.rollCard.offsetWidth;
    els.rollCard.classList.add(flashClass);
  }
  beep(sound);

  updateUI();
  saveState();
}

function roll(){ applyRoll(rand20()); }

/* ---------- Auto runner ---------- */
function startAuto(){
  if (state.autoTimer) return;
  els.autoBtn.classList.add('btn-on');
  state.autoTimer = setInterval(roll, 100);
}
function stopAuto(){
  if (!state.autoTimer) return;
  clearInterval(state.autoTimer);
  state.autoTimer = null;
  els.autoBtn.classList.remove('btn-on');
}
function toggleAuto(){ state.autoTimer ? stopAuto() : startAuto(); }

/* ---------- Reset ---------- */
function resetGame(){
  stopAuto();
  state.k = 1;
  state.steps = 0;
  state.wins = 0;
  state.losses = 0;
  state.neutrals = 0;
  state.catastrophes = 0;
  state.topHits = 0;
  state.lastRoll = null;
  state.lastOutcome = '—';
  state.recentK = [];
  state.histK = Array(20).fill(0);
  updateUI(true);
  saveState();
}

/* ---------- HiDPI Canvas helper ---------- */
function setupHiDPICanvas(c){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const cssW = Math.max(1, Math.floor(c.getBoundingClientRect().width));
  const cssH = Math.max(1, Math.floor(parseFloat(getComputedStyle(c).height)));
  c.width = Math.round(cssW * dpr);
  c.height = Math.round(cssH * dpr);
  const ctx = c.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { ctx, w: cssW, h: cssH };
}

/* ---------- Math helpers for Live Stats ---------- */
function harmonic(n){
  let s = 0;
  for (let i=1;i<=n;i++) s += 1/i;
  return s;
}
const H19 = harmonic(19);

function formatPct(x){ return (x*100).toFixed(2) + '%'; }
function formatNum(x){ return Number.isFinite(x) ? (+x.toFixed(3)).toString() : '—'; }

/* ---------- UI ---------- */
function updateUI(isReset=false){
  els.kVal.textContent = state.k;
  els.kValBig.textContent = state.k;
  const thr = currentThreshold();
  els.threshold.textContent = '≥ ' + thr;
  els.thresholdHdr.textContent = thr;
  els.steps.textContent = state.steps;
  els.wins.textContent = state.wins;
  els.losses.textContent = state.losses;
  els.neutrals.textContent = state.neutrals;
  els.cats.textContent = state.catastrophes;
  els.topHits.textContent = state.topHits;

  if (state.lastRoll == null){
    els.lastRoll.textContent = '—';
    els.lastOutcome.textContent = 'Ready';
    els.lastOutcome.className = 'roll-label';
  } else {
    els.lastRoll.textContent = state.lastRoll;
    const L = els.lastOutcome;
    L.className = 'roll-label';
    if (state.lastOutcome === 'win'){ L.textContent = 'WIN'; L.classList.add('state-win'); }
    else if (state.lastOutcome === 'top'){ L.textContent = 'TOP HIT → RESET'; L.classList.add('state-top'); }
    else if (state.lastOutcome === 'cat'){ L.textContent = 'CATASTROPHE → RESET'; L.classList.add('state-loss'); }
    else { L.textContent = 'NEUTRAL'; L.classList.add('state-neutral'); }
  }

  drawSparkline();
  drawHistogram();
  updateLiveStats(); // NEW
}

/* ---------- Live Stats updater ---------- */
function updateLiveStats(){
  const k = state.k;
  // Top before Cat, Cat before Top
  const pTopFirst = k/20;
  const pCatFirst = 1 - pTopFirst;

  // Expected rolls and wins
  const eRolls = 20 - k;
  const Hk = harmonic(k);
  const eWins = k * (H19 - Hk + 1/20);

  // Long-run per-roll top-hit rate (global)
  const longTopRate = 1/380;

  // Long-run time fraction at current k
  const f_k = (20/19) * (1/(k*(k+1)));

  els.statTopFirst.textContent = formatPct(pTopFirst);
  els.statCatFirst.textContent = formatPct(pCatFirst);
  els.statERolls.textContent = formatNum(eRolls);
  els.statEWins.textContent = formatNum(eWins);
  els.statTopRate.textContent = formatPct(longTopRate);
  els.statFk.textContent = formatPct(f_k);
}

/* ---------- Canvases ---------- */
function drawSparkline(){
  const c = els.spark;
  const { ctx, w, h } = setupHiDPICanvas(c);

  ctx.clearRect(0,0,w,h);

  ctx.globalAlpha = 0.10;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  for (let i=1;i<=19;i++){
    const y = mapKtoY(i, h);
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
  }
  ctx.globalAlpha = 1.0;

  const data = state.recentK;
  if (data.length < 2) return;

  ctx.lineWidth = 2;
  const grad = ctx.createLinearGradient(0,0,w,0);
  grad.addColorStop(0, '#00e5ff');
  grad.addColorStop(1, '#ff3df0');
  ctx.strokeStyle = grad;

  ctx.beginPath();
  const N = data.length;
  const xStep = w / (N - 1);
  for (let i=0;i<N;i++){
    const x = i * xStep;
    const y = mapKtoY(data[i], h);
    if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  ctx.globalAlpha = 0.12;
  ctx.lineTo(w, h); ctx.lineTo(0, h); ctx.closePath();
  ctx.fillStyle = grad; ctx.fill();
  ctx.globalAlpha = 1.0;

  function mapKtoY(k, hgt){
    const t = (k - 1) / (19 - 1);
    const pad = 8;
    return (hgt - pad) - t * (hgt - 2*pad);
  }
}

function drawHistogram(){
  const c = els.hist;
  const { ctx, w, h } = setupHiDPICanvas(c);

  ctx.clearRect(0,0,w,h);

  const counts = state.histK.slice(1, 20);
  const max = Math.max(1, ...counts);
  const n = counts.length;
  const gap = 4;
  const barW = (w - gap*(n+1)) / n;

  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, h-0.5); ctx.lineTo(w, h-0.5); ctx.stroke();

  for (let i=0;i<n;i++){
    const v = counts[i];
    const ratio = v / max;
    const barH = Math.max(2, Math.round(ratio * (h - 16)));
    const x = gap + i*(barW + gap);
    const y = h - barH;

    const grad = ctx.createLinearGradient(0, y, 0, y+barH);
    grad.addColorStop(0, '#00e5ff');
    grad.addColorStop(1, '#ff3df0');

    ctx.fillStyle = grad;
    ctx.fillRect(x, y, barW, barH);

    ctx.fillStyle = 'rgba(230,240,255,0.6)';
    ctx.font = '10px ui-sans-serif, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(String(i+1), x + barW/2, h - 2);
  }
}

/* ---------- Controls & Bindings ---------- */
function preventScroll(e){ if (e.code === 'Space') e.preventDefault(); }
function onKey(e){
  const k = e.key.toLowerCase();
  if (k === 'r' || e.code === 'Space'){ e.preventDefault(); roll(); }
  else if (k === 'a'){ toggleAuto(); }
  else if (k === 's'){ stopAuto(); }
  else if (k === 'x'){ resetGame(); }
}

function bindEvents(){
  els.rollBtn.addEventListener('click', roll);
  els.autoBtn.addEventListener('click', toggleAuto);
  els.stopBtn.addEventListener('click', stopAuto);
  els.resetBtn.addEventListener('click', resetGame);
  window.addEventListener('keydown', preventScroll, {passive:false});
  window.addEventListener('keydown', onKey);

  ['click','keydown','touchstart'].forEach(ev=>{
    window.addEventListener(ev, () => { try { ensureAudio(); } catch {} }, { once:true });
  });

  window.addEventListener('resize', () => { drawSparkline(); drawHistogram(); });

  els.clearSave.addEventListener('click', (e)=>{
    e.preventDefault();
    clearSavedState();
    alert('Saved state cleared. (Current session continues until you refresh.)');
  });

  window.addEventListener('beforeunload', saveState);
}

/* ---------- Init ---------- */
function init(){
  if (!loadState()){
    state.recentK = [state.k];
    state.histK = Array(20).fill(0);
  }
  updateUI(true);
  bindEvents();
  setTimeout(()=>{ drawSparkline(); drawHistogram(); }, 0);
}
init();
</script>
</body>
</html>
