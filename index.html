<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sisyphus' Ruin</title>
<style>
  :root{
    --bg:#080014; --text:#fef8ff; --muted:#cdaeff;
    --accent:#ff9e2c; --accent-2:#ff00b8; --accent-3:#00b7ff; --accent-4:#ff4efc;
  }
  body{
    margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; color:var(--text);
    min-height: 100vh; background-color:#050010;
    background-image:
      radial-gradient(900px 700px at 50% -200px, rgba(255,0,200,.15), transparent 70%),
      radial-gradient(900px 700px at 50% 120%, rgba(0,200,255,.12), transparent 70%),
      linear-gradient(180deg,#0b0014 0%, #050010 100%);
    background-repeat:no-repeat; background-size:cover;
  }
  .app{max-width:1100px;margin:0 auto;padding:12px}
  h1{
    text-align:center; font-size:clamp(22px,3vw,30px); margin:14px 0 12px; letter-spacing:.5px;
    background:linear-gradient(90deg,var(--accent),var(--accent-2),var(--accent-3));
    -webkit-background-clip:text; background-clip:text; color:transparent;
  }
  .grid{display:grid;grid-template-columns:1fr 360px;gap:12px}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
  .card{background:transparent;padding:14px;border:none}
  .btn{
    appearance:none; background:#1c0130; border:none; color:var(--text); border-radius:6px;
    padding:10px 14px; cursor:pointer; font-weight:600; letter-spacing:.3px;
    transition:background .15s ease,transform .1s ease; box-shadow:inset 0 0 0 1px rgba(255,255,255,.1);
  }
  .btn:hover{background:#2d0048}
  .btn:active{transform:scale(.97)}
  .btn:focus{outline:2px solid var(--accent);outline-offset:2px}
  
  /* DOCKED ROLL BUTTON STYLES */
  .docked-control {
    position: sticky;
    top: 0;
    z-index: 1000;
    background: rgba(5, 0, 16, 0.85);
    backdrop-filter: blur(8px);
    margin: -12px -12px 12px -12px;
    padding: 12px;
    border-bottom: 1px solid rgba(255, 166, 0, 0.15);
    display: flex;
    justify-content: center;
  }

  .btn.big{
    display:block; width:100%; font-size:20px; padding:16px;
    margin-bottom:0; 
    background:#ff9e2c; color:#120026; font-weight:700;
    max-width: 600px;
  }
  .btn.big:hover{background:#ffb64d}
  
  label{width:120px;font-size:12px;color:var(--muted)}
  
  input[type="number"],select{
    background:#140026; color:var(--text); border:none; border-radius:4px;
    padding:6px 8px; 
    width: 54px;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.1);
  }
  select#speed { width: auto; }
  input#nRolls { width: 60px; }

  .desc{font-size:11px;opacity:.6;color:var(--muted);margin:-2px 0 8px; display:block; line-height:1.3;}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .bar{
    height:10px; background:rgba(255,255,255,.06); border-radius:8px;
    overflow:hidden; margin:3px 0; border:1px solid rgba(255,166,0,.12);
  }
  .bar>div{height:100%}
  .bar .win{background:linear-gradient(90deg,#ffd94d,var(--accent))}
  .bar .neu{background:linear-gradient(90deg,var(--accent-3),var(--accent-2))}
  .bar .loss{background:linear-gradient(90deg,var(--accent-4),#ff2400)}
  .kpos-track,.lpos-track{
    height:6px; background:rgba(255,255,255,.06); border:1px solid rgba(255,166,0,.12);
    border-radius:6px; overflow:hidden;
  }
  .kpos-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-4))}
  .lpos-fill{height:100%;background:linear-gradient(90deg,var(--accent-3),var(--accent-2))}
  #log{
    height:160px; overflow:auto; background:rgba(18,0,38,.35); border:1px solid rgba(255,166,0,.12);
    border-radius:10px; padding:8px; font-family:monospace; font-size:12px;
    white-space:pre-wrap; overflow-wrap:break-word; word-break:break-word;
  }
  svg#spark{width:100%;height:60px}
  .tiny{font-size:11px;opacity:.65;color:var(--muted)}
  .mono{font-family:monospace;}
  .small{font-size:12px;}

  .recent.win #recent-outcome{color:#ffd54a; text-shadow:0 0 6px rgba(255,213,74,.65),0 0 18px rgba(255,180,0,.4);}
  .recent.neu #recent-outcome{color:#a98dff}
  .recent.loss #recent-outcome{color:#ff4d4d; text-shadow:0 0 6px rgba(255,77,77,.65),0 0 18px rgba(255,40,40,.4);}
  
  .cycle-entry {
    font-family: monospace; font-size: 11px; border-radius: 4px; 
    border-left: 3px solid rgba(255,255,255,.12); padding: 4px 6px; 
    margin-bottom: 4px; background: rgba(12,0,32,0.6); 
    white-space: pre-wrap; word-break: break-word;
    display: flex; flex-direction: column; gap: 1px;
  }
  .cycle-entry.loss { border-color: rgba(255,90,90,.8); }
  .cycle-entry.top { border-color: rgba(255,210,90,.9); background: rgba(30,20,0,0.4); }
  .cycle-entry-top-row { display: flex; justify-content: space-between; align-items: baseline; font-weight: 600; opacity: 0.9; line-height: 1.2; }
  .cycle-id { color: var(--accent-3); margin-right: 6px; }
  .cycle-meta { font-weight: 400; opacity: 0.65; font-size: 10px; }
  .cycle-entry-path { opacity: 0.75; font-size: 10px; line-height: 1.1; letter-spacing: 1px; margin-top: 1px; }

  .stats-grid {
    display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-top: 6px;
    background: rgba(255,255,255,0.03); padding: 6px; border-radius: 6px;
  }
  .stat-box { display: flex; flex-direction: column; align-items: center; }
  .stat-label { font-size: 10px; opacity: 0.5; text-transform: uppercase; letter-spacing: 0.5px; }
  .stat-val { font-family: monospace; font-size: 13px; font-weight: 600; color: var(--accent-3); }

  /* Accessibility improvements */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0,0,0,0);
    white-space: nowrap;
    border: 0;
  }

  /* Performance indicator */
  .perf-indicator {
    position: fixed;
    bottom: 10px;
    right: 10px;
    background: rgba(0,0,0,0.8);
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 10px;
    font-family: monospace;
    opacity: 0.5;
    pointer-events: none;
  }

  /* Help modal */
  .help-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(20,0,38,0.95);
    border: 2px solid var(--accent);
    padding: 20px;
    border-radius: 10px;
    z-index: 2000;
    max-width: 400px;
  }
  .help-modal.show { display: block; }
  .help-modal h3 { margin-top: 0; color: var(--accent); }
  .help-modal kbd {
    background: rgba(255,255,255,0.1);
    padding: 2px 6px;
    border-radius: 3px;
    font-family: monospace;
    border: 1px solid rgba(255,255,255,0.2);
  }
</style>
</head>
<body>

<!-- Screen reader announcements -->
<div role="status" aria-live="polite" aria-atomic="true" class="sr-only" id="aria-announcer"></div>

<!-- Help Modal -->
<div class="help-modal" id="help-modal" role="dialog" aria-labelledby="help-title">
  <h3 id="help-title">Keyboard Shortcuts</h3>
  <dl>
    <dt><kbd>Space</kbd> or <kbd>Enter</kbd></dt>
    <dd>Roll once</dd>
    <dt><kbd>A</kbd></dt>
    <dd>Toggle auto-play</dd>
    <dt><kbd>R</kbd></dt>
    <dd>Reset game</dd>
    <dt><kbd>?</kbd></dt>
    <dd>Show/hide this help</dd>
    <dt><kbd>Esc</kbd></dt>
    <dd>Close this help</dd>
  </dl>
  <button class="btn" onclick="document.getElementById('help-modal').classList.remove('show')">Close</button>
</div>

<!-- Performance indicator -->
<div class="perf-indicator" id="perf-indicator"></div>

<template id="tpl-cycle-entry">
  <div class="cycle-entry">
    <div class="cycle-entry-top-row">
      <span class="cycle-main-text"></span>
      <span class="cycle-meta"></span>
    </div>
    <div class="cycle-entry-path"></div>
  </div>
</template>

<div class="app">
  <h1>Sisyphus' Ruin</h1>

  <div class="docked-control">
    <button class="btn big" id="roll1_big" 
            aria-label="Roll the dice once" 
            aria-keyshortcuts="Space Enter">Roll</button>
  </div>

  <div class="grid">
    <div>
      <div class="card recent" id="recent-card" role="region" aria-label="Recent roll result">
        <div style="display:flex;flex-direction:column;gap:2px">
          <div id="recent-outcome" style="font-weight:900;letter-spacing:1px;font-size:clamp(20px,3.2vw,32px)">No rolls yet</div>
          <div class="tiny mono">(k,ℓ): <span id="recent-kl">(1,0)→(1,0)</span></div>
        </div>
        <div class="recent-bars" style="margin-top:8px;display:grid;gap:6px">
          <div class="row recent-bar"><span style="width:46px">win</span><div class="bar" style="flex:1"><div id="rbar-win" class="win" style="width:0%"></div></div><span id="rpct-win" class="small mono">0.0%</span></div>
          <div class="row recent-bar"><span style="width:46px">neutral</span><div class="bar" style="flex:1"><div id="rbar-neu" class="neu" style="width:0%"></div></div><span id="rpct-neu" class="small mono">0.0%</span></div>
          <div class="row recent-bar"><span style="width:46px">loss</span><div class="bar" style="flex:1"><div id="rbar-loss" class="loss" style="width:0%"></div></div><span id="rpct-loss" class="small mono">0.0%</span></div>
          <div class="kpos"><div class="kpos-track"><div id="kpos-fill" class="kpos-fill" style="width:0%"></div></div><div class="small">k-position: <span id="kpos-text">1 / 20</span></div></div>
          <div class="lpos" style="margin-top:4px"><div class="lpos-track"><div id="lpos-fill" class="lpos-fill" style="width:0%"></div></div><div class="small">ℓ-position: <span id="lpos-text">0 / 20</span></div></div>
          <div class="row tiny" style="margin-top:2px">p(win | !neutral): <span id="recent-p-cond" class="mono">—</span></div>
          <div class="row tiny" style="margin-top:0">p(top hit | current state): <span id="recent-p-top" class="mono">—</span></div>
        </div>
      </div>

      <div class="card"><h2 style="margin:0 0 8px">Sparkline</h2><svg id="spark" viewBox="0 0 300 60" preserveAspectRatio="none" role="img" aria-label="Progress history chart"></svg></div>

      <div class="card"><h2 style="margin:0 0 8px">Run Stats</h2>
        <div class="small" style="margin-bottom:6px">steps: <span class="mono" id="run-steps">0</span></div>
        <div class="bar" role="progressbar" aria-label="Win percentage"><div class="win" id="bar-win" style="width:0%"></div></div>
        <div class="bar" role="progressbar" aria-label="Neutral percentage"><div class="neu" id="bar-neu" style="width:0%"></div></div>
        <div class="bar" role="progressbar" aria-label="Loss percentage"><div class="loss" id="bar-loss" style="width:0%"></div></div>
        <div class="row" style="justify-content:space-between">
          <div>win: <span class="mono" id="c-win">0</span> (<span class="mono" id="r-win">0.0%</span>)</div>
          <div>neutral: <span class="mono" id="c-neu">0</span> (<span class="mono" id="r-neu">0.0%</span>)</div>
          <div>loss: <span class="mono" id="c-loss">0</span> (<span class="mono" id="r-loss">0.0%</span>)</div>
        </div>
        <div class="row tiny" style="margin-top:6px;justify-content:space-between">
          <div>longest cycle: <span class="mono" id="longest-cycle">0</span></div>
          <div>max k: <span class="mono" id="max-k">1</span></div>
        </div>
      </div>

      <div class="card"><div id="log" role="log" aria-label="Game log"></div></div>

      <div class="card"><h2 style="margin:0 0 8px">Cycle Summaries</h2><div id="cycle-box" class="tiny"></div></div>
    </div>

    <div>
      <div class="card"><h2 style="margin:0 0 8px">Play Controls</h2>
        <div class="row">
          <button class="btn" id="auto" aria-keyshortcuts="A" style="flex:1">Auto Play</button>
          <select id="speed" aria-label="Auto-play speed">
            <option value="1000">Slow</option>
            <option value="100" selected>Normal</option>
            <option value="10">Fast (Turbo)</option>
          </select>
        </div>
        <div class="row" style="margin-top:8px">
          <input id="nRolls" type="number" value="20" aria-label="Number of rolls or cycles" style="width:60px">
          <button class="btn" id="rollN" style="flex:1">Roll N Steps</button>
          <button class="btn" id="rollNCycles" style="flex:1">Roll N Cycles</button>
        </div>
        <div class="row" style="margin-top:8px">
          <span class="tiny" style="min-width:110px">Set state (k, ℓ):</span>
          <input id="set-k" type="number" min="1" value="1" aria-label="Set k value">
          <input id="set-l" type="number" min="0" value="0" aria-label="Set l value">
          <button class="btn" id="setStateBtn">Set</button>
        </div>
      </div>

      <div class="card"><h2 style="margin:0 0 8px">System</h2>
        <div class="tiny" style="line-height:1.45">
          This process tracks a state <strong>(k, ℓ)</strong> where k is progress up a ladder (1 → M) and ℓ is momentum (0 → L).<br>
          On each roll you get a <strong>win</strong> (k increases, ℓ drops), <strong>neutral</strong> (k stays, ℓ rises), or <strong>loss</strong> (reset to k=1, ℓ=0).<br>
          At k = M, a win becomes a <strong>Top Hit</strong>.
        </div>
      </div>

      <div class="card" id="params-container">
        <h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Parameters</h3>
        <div class="row"><label for="M">M (k levels)</label><input id="M" type="number" value="20"></div>
        <div class="desc">How many rungs in the ladder.</div>
        <div class="row"><label for="L">L (ℓ max)</label><input id="L" type="number" value="20"></div>
        <div class="desc">Momentum scale; ℓ ∈ [0, L].</div>
        <div class="row"><label>w_min → w_max</label><input id="w_min" type="number" step="0.01" value="0.10" aria-label="Minimum win probability"><input id="w_max" type="number" step="0.01" value="0.90" aria-label="Maximum win probability"></div>
        <div class="desc">Win rises from w_min at k=1 to w_max at k=M.</div>
        <div class="row"><label for="beta">β (k ramp)</label><input id="beta" type="number" step="0.1" value="1.5"></div>
        <div class="desc">β > 1 makes late k much easier.</div>
        <div class="row"><label>ρ, γ (ℓ boost)</label><input id="rho" type="number" step="0.05" value="0.6" aria-label="Rho parameter"><input id="gamma" type="number" step="0.1" value="1.5" aria-label="Gamma parameter"></div>
        <div class="desc">Higher ℓ → more win probability.</div>
        <div class="row"><label>c_min → c_max</label><input id="c_min" type="number" step="0.01" value="0.03" aria-label="Minimum catastrophe probability"><input id="c_max" type="number" step="0.01" value="0.10" aria-label="Maximum catastrophe probability"></div>
        <div class="desc">Loss floor/ceiling.</div>
        <div class="row"><label for="alpha">α (loss decay)</label><input id="alpha" type="number" step="0.1" value="0.3"></div>
        <div class="desc">Higher ℓ reduces loss via exp decay.</div>
        <div class="row"><label>g_n, s_w</label><input id="g_n" type="number" value="1" aria-label="Momentum gain"><input id="s_w" type="number" value="20" aria-label="Momentum spend"></div>
        <div class="desc">Momentum gain (neutral) vs spend (win).</div>
        <div class="row"><button class="btn" id="apply">Apply & Reset</button><button class="btn" id="resetState" aria-keyshortcuts="R">Reset State</button></div>
      </div>

      <div class="card"><h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Expectations</h3>
        <div class="row tiny" style="flex-direction:column;align-items:flex-start;gap:2px">
          <div>win rate (per roll): <span class="mono" id="exp-win-rate">—</span></div>
          <div>loss rate (per roll): <span class="mono" id="exp-loss-rate">—</span></div>
          <div>average cycle length: <span class="mono" id="exp-cycle-len">—</span> rolls</div>
          <div>E[first top hit]: <span class="mono" id="exp-time-top">—</span> rolls</div>
          <!-- Cache hit rate removed as requested -->
        </div>
      </div>

      <div class="card"><h3 style="margin:0 0 6px; font-size:14px; opacity:0.8">Distributions</h3>
        <div class="tiny" style="margin-top:6px">Time spent at k:</div>
        <div id="hist-k" class="tiny" style="margin-top:2px;min-height:24px"></div>
        <div class="tiny" style="margin-top:6px">Time spent at ℓ:</div>
        <div id="hist-l" class="tiny" style="margin-top:2px;min-height:24px"></div>
        <div class="tiny" style="margin-top:6px">Time spent at (k, ℓ) Heatmap:</div>
        <div id="hist-kl" class="tiny" style="margin-top:2px;min-height:32px"></div>
        
        <div class="tiny" style="margin-top:12px; font-weight:600; color:var(--muted)">Cycle Lengths (Global N=<span id="global-n">0</span>)</div>
        <div class="stats-grid" id="global-stats">
          <div class="stat-box"><div class="stat-label">Min</div><div class="stat-val" id="gs-min">—</div></div>
          <div class="stat-box"><div class="stat-label">25%</div><div class="stat-val" id="gs-25">—</div></div>
          <div class="stat-box"><div class="stat-label">Med</div><div class="stat-val" id="gs-50">—</div></div>
          <div class="stat-box"><div class="stat-label">75%</div><div class="stat-val" id="gs-75">—</div></div>
          <div class="stat-box"><div class="stat-label">Max</div><div class="stat-val" id="gs-max">—</div></div>
        </div>

        <div class="tiny" style="margin-top:8px">Cycle lengths (last 40):</div>
        <div id="hist-cycle-len" class="tiny" style="margin-top:2px"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* -------------------------------------------------------------------------- */
/* MODULE 0: UTILITIES & HELPERS                                             */
/* -------------------------------------------------------------------------- */

// Probability Cache for memoization
class ProbabilityCache {
  constructor(maxSize = 400) {
    this.cache = new Map();
    this.maxSize = maxSize;
    this.hits = 0;
    this.misses = 0;
  }
  
  makeKey(k, l, params) {
    return `${k},${l},${params.w_min},${params.w_max},${params.beta},${params.rho},${params.gamma},${params.c_min},${params.c_max},${params.alpha},${params.M},${params.L}`;
  }
  
  get(k, l, params) {
    const key = this.makeKey(k, l, params);
    const result = this.cache.get(key);
    if (result) {
      this.hits++;
      return result;
    }
    this.misses++;
    return null;
  }
  
  set(k, l, params, probs) {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    const key = this.makeKey(k, l, params);
    this.cache.set(key, probs);
    return probs;
  }
  
  clear() {
    this.cache.clear();
    this.hits = 0;
    this.misses = 0;
  }
  
  getStats() {
    return {
      size: this.cache.size,
      hits: this.hits,
      misses: this.misses,
      hitRate: this.hits / (this.hits + this.misses) || 0
    };
  }
}

// Aria Announcer for screen readers
class AriaAnnouncer {
  constructor() {
    this.element = document.getElementById('aria-announcer');
  }
  
  announce(message) {
    this.element.textContent = message;
    setTimeout(() => {
      this.element.textContent = '';
    }, 1000);
  }
}

// Performance Monitor
class PerformanceMonitor {
  constructor() {
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.fps = 0;
    this.element = document.getElementById('perf-indicator');
  }
  
  tick() {
    this.frameCount++;
    const now = performance.now();
    const delta = now - this.lastTime;
    
    if (delta >= 1000) {
      this.fps = Math.round(this.frameCount * 1000 / delta);
      this.frameCount = 0;
      this.lastTime = now;
      this.update();
    }
  }
  
  update() {
    const cacheStats = SisyphusMath.probCache.getStats();
    this.element.textContent = `FPS: ${this.fps} | Cache: ${(cacheStats.hitRate * 100).toFixed(0)}%`;
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 1: SISYPHUS MATH                                                   */
/* -------------------------------------------------------------------------- */
class SisyphusMath {
  static EPSILON = 1e-10;
  static probCache = new ProbabilityCache();
  
  static computeProbs(k, l, p) {
    // Check cache first
    const cached = this.probCache.get(k, l, p);
    if (cached) return cached;
    
    // Ensure integer bounds
    k = Math.round(k);
    l = Math.round(l);
    
    const clamp01 = x => Math.min(1, Math.max(0, x));
    const M = Math.max(1, p.M | 0);
    const L = Math.max(1, p.L | 0);
    
    const frac = M > 1 ? (k - 1) / (M - 1) : 1;
    const base = p.w_min + (p.w_max - p.w_min) * Math.pow(frac, p.beta);
    const ell = (1 - p.rho) + p.rho * Math.pow(l / L, p.gamma);
    
    let p_win = clamp01(base * ell);
    let p_loss = p.c_min + (p.c_max - p.c_min) * Math.exp(-p.alpha * l);
    
    // Handle normalization with epsilon
    const sum = p_win + p_loss;
    if (sum > 1 + this.EPSILON) {
      p_win /= sum;
      p_loss /= sum;
    } else if (sum > 1) {
      const scale = 1 / sum;
      p_win *= scale;
      p_loss *= scale;
    }
    
    // Ensure p_neu is non-negative
    let p_neu = Math.max(0, 1 - p_win - p_loss);
    
    // Final normalization
    const total = p_win + p_neu + p_loss;
    if (Math.abs(total - 1) > this.EPSILON) {
      p_win /= total;
      p_neu /= total;
      p_loss /= total;
    }
    
    const result = { 
      p_win: clamp01(p_win), 
      p_neu: clamp01(p_neu), 
      p_loss: clamp01(p_loss) 
    };
    
    // Cache the result
    this.probCache.set(k, l, p, result);
    
    return result;
  }
  
  static clearCache() {
    this.probCache.clear();
  }

  static solveExpectations(p) {
    const M = Math.max(1, p.M | 0);
    const L = Math.max(0, p.L | 0);
    
    const TopHit = Array.from({length: M + 1}, () => Array(L + 1).fill(0));
    const CycleLen = Array.from({length: M + 1}, () => Array(L + 1).fill(0));
    const WinCount = Array.from({length: M + 1}, () => Array(L + 1).fill(0));
    
    const maxIter = 400, tol = 1e-6;

    for (let it = 0; it < maxIter; it++) {
      let maxDiff = 0;
      for (let k = 1; k <= M; k++) {
        for (let l = 0; l <= L; l++) {
          const {p_win, p_neu} = SisyphusMath.computeProbs(k, l, p);
          
          const l_win = Math.max(0, l - p.s_w);
          const l_neu = Math.min(L, l + p.g_n);

          let valTop = 0;
          if (k === M) valTop = p_win * 1 + p_neu * TopHit[M][l_neu];
          else valTop = p_win * TopHit[k+1][l_win] + p_neu * TopHit[k][l_neu];
          
          let valCyc = 0;
          if (k === M) valCyc = 1 + p_neu * CycleLen[M][l_neu];
          else valCyc = 1 + p_win * CycleLen[k+1][l_win] + p_neu * CycleLen[k][l_neu];

          let valWin = 0;
          if (k === M) valWin = p_win * 1 + p_neu * WinCount[M][l_neu];
          else valWin = p_win * (1 + WinCount[k+1][l_win]) + p_neu * WinCount[k][l_neu];

          if(Math.abs(valTop - TopHit[k][l]) > maxDiff) maxDiff = Math.abs(valTop - TopHit[k][l]);
          TopHit[k][l] = valTop;
          CycleLen[k][l] = valCyc;
          WinCount[k][l] = valWin;
        }
      }
      if (maxDiff < tol) break;
    }
    return { TopHit, CycleLen, WinCount };
  }

  static getQuantiles(data) {
    if (!data || data.length === 0) return null;
    const sorted = [...data].sort((a, b) => a - b);
    const q = (p) => {
      const pos = (sorted.length - 1) * p;
      const base = Math.floor(pos);
      const rest = pos - base;
      if (sorted[base + 1] !== undefined) {
        return sorted[base] + rest * (sorted[base + 1] - sorted[base]);
      } else {
        return sorted[base];
      }
    };
    return {
      min: sorted[0],
      q25: q(0.25),
      med: q(0.50),
      q75: q(0.75),
      max: sorted[sorted.length - 1]
    };
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 2: GAME MODEL                                                      */
/* -------------------------------------------------------------------------- */
class SisyphusModel {
  constructor() {
    this.params = {
      M:20, L:20, w_min:0.10, w_max:0.90, beta:1.5, rho:0.6, gamma:1.5,
      c_min:0.03, c_max:0.10, alpha:0.3, g_n:1, s_w:20
    };
    this.reset();
  }

  reset() {
    this.state = { k:1, l:0, step:0, topHit:false, cycleSteps:0 };
    this.stats = { wins:0, neus:0, loss:0, maxK:1, longestCycle:0 };
    this.historyK = [];
    this.cycleId = 1;
    this.currentCycle = this._newCycle();
    this.cycleSummaries = []; 
    this.allCycles = []; 

    const M = Math.max(1, this.params.M);
    const L = Math.max(0, this.params.L);
    this.distributions = { 
      k: Array(M+1).fill(0), 
      l: Array(L+1).fill(0), 
      kl: Array.from({length: M+1}, () => Array(L+1).fill(0)),
      cycles: []
    };
    
    this.lastRoll = null; 
  }

  _newCycle() {
    return { id: this.cycleId, length:0, wins:0, neus:0, maxK:this.state.k, path:'' };
  }

  step() {
    if (this.state.topHit) return null;

    const k0 = this.state.k, l0 = this.state.l;
    const probs = SisyphusMath.computeProbs(k0, l0, this.params);
    const r = Math.random();
    
    let outcome = 'loss';
    let k1 = 1, l1 = 0;

    if (r < probs.p_win) {
      if (k0 === this.params.M) {
        outcome = 'top';
        k1 = k0; l1 = l0;
        this.state.topHit = true;
      } else {
        outcome = 'win';
        k1 = Math.min(this.params.M, k0 + 1);
        l1 = Math.max(0, l0 - this.params.s_w);
      }
    } else if (r < probs.p_win + probs.p_neu) {
      outcome = 'neu';
      k1 = k0;
      l1 = Math.min(this.params.L, l0 + this.params.g_n);
    }

    this.state.k = k1; 
    this.state.l = l1;
    this.state.step++;
    this.state.cycleSteps++;
    
    // Update stats
    if (outcome === 'win' || outcome === 'top') this.stats.wins++;
    else if (outcome === 'neu') this.stats.neus++;
    else if (outcome === 'loss') this.stats.loss++;

    if (outcome === 'loss' || outcome === 'top') {
      if (this.state.cycleSteps > this.stats.longestCycle) {
        this.stats.longestCycle = this.state.cycleSteps;
      }
      if (outcome === 'loss') this.state.cycleSteps = 0;
    }

    this.stats.maxK = Math.max(this.stats.maxK, k1);
    this.historyK.push(k1);
    if (this.historyK.length > 200) this.historyK.shift();

    this._updateCycle(outcome, k1);
    this._updateDistributions(k1, l1);

    this.lastRoll = { outcome, k0, l0, k1, l1 };
    return outcome;
  }

  _updateDistributions(k, l) {
    const d = this.distributions;
    if (d.k[k] !== undefined) d.k[k]++;
    if (d.l[l] !== undefined) d.l[l]++;
    if (d.kl[k] && d.kl[k][l] !== undefined) d.kl[k][l]++;
  }

  _updateCycle(outcome, k1) {
    const sym = { win:'+', neu:'.', loss:'X', top:'★' }[outcome];
    if (sym) {
      this.currentCycle.length++;
      if (outcome === 'win') this.currentCycle.wins++;
      if (outcome === 'neu') this.currentCycle.neus++;
      this.currentCycle.maxK = Math.max(this.currentCycle.maxK, k1);
      this.currentCycle.path += sym;
    }

    if (outcome === 'loss' || outcome === 'top') {
      this.allCycles.push(this.currentCycle.length);
      
      this.distributions.cycles.push(this.currentCycle.length);
      if (this.distributions.cycles.length > 40) this.distributions.cycles.shift();

      const summary = { ...this.currentCycle, outcome };
      this.cycleSummaries.unshift(summary);
      if (this.cycleSummaries.length > 7) this.cycleSummaries.pop();

      this.cycleId++;
      this.currentCycle = this._newCycle();
    }
  }

  setState(k, l) {
    this.state.k = Math.max(1, Math.min(this.params.M, k));
    this.state.l = Math.max(0, Math.min(this.params.L, l));
    this.historyK.push(this.state.k);
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 3: UI MANAGER                                                      */
/* -------------------------------------------------------------------------- */
class SisyphusUI {
  constructor(model) {
    this.model = model;
    this.els = {};
    this.pendingUpdates = new Map();
    this.rafId = null;
    
    ['rbar-win','rbar-neu','rbar-loss','rpct-win','rpct-neu','rpct-loss',
     'kpos-fill','kpos-text','lpos-fill','lpos-text','recent-p-cond','recent-p-top',
     'recent-outcome','recent-kl','recent-card',
     'bar-win','bar-neu','bar-loss','c-win','c-neu','c-loss',
     'r-win','r-neu','r-loss','run-steps','longest-cycle','max-k',
     'spark','log','cycle-box','hist-k','hist-l','hist-kl','hist-cycle-len',
     'global-n','gs-min','gs-25','gs-50','gs-75','gs-max',
     'exp-win-rate', 'exp-loss-rate', 'exp-cycle-len', 'exp-time-top'
    ].forEach(id => this.els[id] = document.getElementById(id));
  }
  
  // Batch update methods
  batchUpdate(elementId, property, value) {
    if (!this.pendingUpdates.has(elementId)) {
      this.pendingUpdates.set(elementId, {});
    }
    this.pendingUpdates.get(elementId)[property] = value;
    
    if (!this.rafId) {
      this.rafId = requestAnimationFrame(() => {
        this.flushUpdates();
      });
    }
  }
  
  flushUpdates() {
    this.pendingUpdates.forEach((updates, elementId) => {
      const el = this.els[elementId];
      if (!el) return;
      
      Object.entries(updates).forEach(([prop, value]) => {
        if (prop === 'textContent') {
          el.textContent = value;
        } else if (prop === 'className') {
          el.className = value;
        } else if (prop.startsWith('style.')) {
          const styleProp = prop.substring(6);
          el.style[styleProp] = value;
        }
      });
    });
    
    this.pendingUpdates.clear();
    this.rafId = null;
  }

  log(msg) {
    const div = document.createElement('div');
    div.textContent = msg;
    this.els.log.appendChild(div);
    this.els.log.scrollTop = this.els.log.scrollHeight;
  }

  render(grids, full = true) {
    const m = this.model;
    const s = m.state;
    const st = m.stats;
    const lr = m.lastRoll || { outcome:null, k0:1, l0:0, k1:s.k, l1:s.l };

    const pct = x => (100 * Math.max(0, Math.min(1, x))).toFixed(1) + '%';
    const probs = SisyphusMath.computeProbs(lr.k1, lr.l1, m.params);
    
    // Use batch updates for better performance
    this.batchUpdate('recent-outcome', 'textContent', 
      lr.outcome ? (lr.outcome === 'neu' ? 'NEUTRAL' : lr.outcome === 'top' ? 'TOP HIT' : lr.outcome.toUpperCase()) : '—');
    this.batchUpdate('recent-kl', 'textContent', `(${lr.k0},${lr.l0})→(${lr.k1},${lr.l1})`);
    this.batchUpdate('recent-card', 'className', 'card recent ' + (lr.outcome === 'top' ? 'win' : lr.outcome || ''));

    this.batchUpdate('rbar-win', 'style.width', pct(probs.p_win));
    this.batchUpdate('rbar-neu', 'style.width', pct(probs.p_neu));
    this.batchUpdate('rbar-loss', 'style.width', pct(probs.p_loss));
    this.batchUpdate('rpct-win', 'textContent', pct(probs.p_win));
    this.batchUpdate('rpct-neu', 'textContent', pct(probs.p_neu));
    this.batchUpdate('rpct-loss', 'textContent', pct(probs.p_loss));

    const p_cond = (probs.p_win + probs.p_loss > 0) ? probs.p_win / (probs.p_win + probs.p_loss) : 0;
    this.batchUpdate('recent-p-cond', 'textContent', (probs.p_win+probs.p_loss < 1e-9) ? '—' : pct(p_cond));

    // p(top hit | current state) Display Logic
    let pTopText = '—';
    if (grids && grids.TopHit && grids.TopHit[lr.k1] && typeof grids.TopHit[lr.k1][lr.l1] === 'number') {
      const p = grids.TopHit[lr.k1][lr.l1];
      const odds = p > 0 ? 1/p : Infinity;
      
      if (p < 0.0001) { // < 0.01%
        // Show only odds (1 in X), using scientific notation for very large odds
        const oddsStr = odds > 1e6 ? odds.toExponential(2) : Math.round(odds).toLocaleString();
        pTopText = `1 in ${oddsStr}`;
      } else if (p <= 0.5) { // 0.01% to 50%
        // Show both odds and probability
        const oddsStr = Math.round(odds).toLocaleString();
        pTopText = `1 in ${oddsStr} (${(p*100).toFixed(2)}%)`;
      } else { // > 50%
        // Show only probability
        pTopText = `${(p*100).toFixed(1)}%`;
      }
    }
    this.batchUpdate('recent-p-top', 'textContent', pTopText);

    this.batchUpdate('kpos-fill', 'style.width', pct(lr.k1 / m.params.M));
    this.batchUpdate('kpos-text', 'textContent', `${lr.k1} / ${m.params.M}`);
    this.batchUpdate('lpos-fill', 'style.width', pct(lr.l1 / m.params.L));
    this.batchUpdate('lpos-text', 'textContent', `${lr.l1} / ${m.params.L}`);

    // Stats
    const tot = st.wins + st.neus + st.loss;
    this.batchUpdate('run-steps', 'textContent', s.step);
    this.batchUpdate('c-win', 'textContent', st.wins);
    this.batchUpdate('c-neu', 'textContent', st.neus);
    this.batchUpdate('c-loss', 'textContent', st.loss);
    this.batchUpdate('r-win', 'textContent', tot ? (100*st.wins/tot).toFixed(1)+'%' : '0%');
    this.batchUpdate('r-neu', 'textContent', tot ? (100*st.neus/tot).toFixed(1)+'%' : '0%');
    this.batchUpdate('r-loss', 'textContent', tot ? (100*st.loss/tot).toFixed(1)+'%' : '0%');
    
    this.batchUpdate('bar-win', 'style.width', tot ? (100*st.wins/tot)+'%' : '0%');
    this.batchUpdate('bar-neu', 'style.width', tot ? (100*st.neus/tot)+'%' : '0%');
    this.batchUpdate('bar-loss', 'style.width', tot ? (100*st.loss/tot)+'%' : '0%');
    
    this.batchUpdate('longest-cycle', 'textContent', st.longestCycle);
    this.batchUpdate('max-k', 'textContent', st.maxK);
    
    this._drawSpark(m.historyK, m.params.M);
    this._renderCycles();

    if(full) {
      this._renderDistributions();
      this._renderGlobalStats();
    }
  }

  _drawSpark(data, M) {
    if (!data.length) return;
    const w = 300, h = 60;
    const y = k => h - 6 - (h - 12) * ((k - 1) / (M - 1 || 1));
    const stepX = data.length > 1 ? (w - 6) / (data.length - 1) : 0;
    let pts = '';
    for (let i = 0; i < data.length; i++) pts += `${3 + i * stepX},${y(data[i]).toFixed(1)} `;
    const stroke = '#ff9e2c';
    const overlay = `<rect x="0" y="0" width="${w}" height="${h}" fill="transparent" />`;
    this.els.spark.innerHTML = `<polyline fill="none" stroke="${stroke}" stroke-width="2" points="${pts.trim()}" />` + overlay;
  }

  _renderCycles() {
    const box = this.els['cycle-box'];
    const tpl = document.getElementById('tpl-cycle-entry');
    
    // Use DocumentFragment for better performance
    const fragment = document.createDocumentFragment();
    
    this.model.cycleSummaries.forEach(c => {
      const clone = tpl.content.cloneNode(true);
      const div = clone.querySelector('.cycle-entry');
      div.classList.add(c.outcome === 'top' ? 'top' : 'loss');
      
      const label = `C${c.id}: ${c.outcome === 'top' ? 'TOP' : 'LOSS'}`;
      clone.querySelector('.cycle-main-text').textContent = label;
      clone.querySelector('.cycle-meta').textContent = `L:${c.length} W:${c.wins}`;
      
      const chunk = 32;
      let wrapped = '';
      for(let i=0; i<(c.path||'').length; i+=chunk) {
        wrapped += c.path.slice(i, i+chunk) + '\n';
      }
      clone.querySelector('.cycle-entry-path').textContent = wrapped || '-';
      fragment.appendChild(clone);
    });
    
    box.innerHTML = '';
    box.appendChild(fragment);
  }

  _renderGlobalStats() {
    const ac = this.model.allCycles;
    this.els['global-n'].textContent = ac.length;
    
    const stats = SisyphusMath.getQuantiles(ac);
    if (stats) {
      this.els['gs-min'].textContent = stats.min;
      this.els['gs-25'].textContent = stats.q25.toFixed(1).replace('.0','');
      this.els['gs-50'].textContent = stats.med.toFixed(1).replace('.0','');
      this.els['gs-75'].textContent = stats.q75.toFixed(1).replace('.0','');
      this.els['gs-max'].textContent = stats.max;
    } else {
      ['gs-min','gs-25','gs-50','gs-75','gs-max'].forEach(id => this.els[id].textContent = '—');
    }
  }

  _renderDistributions() {
    const dist = this.model.distributions;
    const renderBar = (hostId, data, M) => {
      const host = this.els[hostId];
      host.innerHTML = '';
      if(!data.length || !data.some(x=>x)) { host.textContent='—'; return; }
      const max = Math.max(...data.filter(n=>n));
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;align-items:flex-end;gap:2px';
      for(let i=(hostId==='hist-l'?0:1); i<data.length; i++){
        const v = data[i] || 0;
        const bar = document.createElement('div');
        bar.style.cssText = `width:3px;border-radius:2px;background:linear-gradient(180deg,var(--accent-3),var(--accent-2));`;
        bar.style.height = (6 + (max ? 24 * v / max : 0)) + 'px';
        wrap.appendChild(bar);
      }
      host.appendChild(wrap);
    };
    renderBar('hist-k', dist.k, this.model.params.M);
    renderBar('hist-l', dist.l, this.model.params.L);

    const clSamples = dist.cycles;
    const hostCl = this.els['hist-cycle-len'];
    hostCl.innerHTML = '';
    if(clSamples.length) {
      const maxCL = Math.max(...clSamples);
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;align-items:flex-end;gap:2px';
      clSamples.forEach(len => {
        const bar = document.createElement('div');
        bar.style.cssText = 'width:4px;border-radius:2px;background:linear-gradient(180deg,var(--accent-3),var(--accent-2));';
        bar.style.height = (8 + (maxCL ? 32 * len / maxCL : 0)) + 'px';
        wrap.appendChild(bar);
      });
      hostCl.appendChild(wrap);
    } else {
      hostCl.textContent = '—';
    }

    const hostHM = this.els['hist-kl'];
    hostHM.innerHTML = '';
    const klData = dist.kl;
    let maxC = 0;
    klData.forEach(row => row.forEach(c => { if(c > maxC) maxC = c; }));
    
    if(maxC > 0) {
      const M = this.model.params.M;
      const L = this.model.params.L;
      const grid = document.createElement('div');
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = `repeat(${M}, minmax(4px, 1fr))`;
      grid.style.gap = '1px';
      const logMax = Math.log(1+maxC);
      
      for(let l=L; l>=0; l--) {
        for(let k=1; k<=M; k++) {
          const c = (klData[k] && klData[k][l]) || 0;
          const cell = document.createElement('div');
          const alpha = c > 0 ? (0.15 + 0.85 * (Math.log(1+c)/logMax)) : 0.05;
          cell.style.background = `rgba(0,183,255,${alpha.toFixed(3)})`;
          cell.style.aspectRatio = '1/1';
          cell.title = `(${k},${l}): ${c}`;
          grid.appendChild(cell);
        }
      }
      hostHM.appendChild(grid);
    } else {
      hostHM.textContent = '—';
    }
  }

  updateExpectations(grids) {
    const { TopHit, CycleLen, WinCount } = grids;
    const pCycleTop = TopHit[1][0];
    const c = CycleLen[1][0];
    const w = WinCount[1][0];
    const fmt = x => (100*x).toFixed(3)+'%';
    const el = id => document.getElementById(id);
    
    if(c > 0) {
      el('exp-win-rate').textContent = fmt(w/c);
      el('exp-loss-rate').textContent = fmt((1-pCycleTop)/c);
      el('exp-cycle-len').textContent = c.toFixed(1);
      
      // E[first top hit] Logic
      if (pCycleTop > 1e-15) { // Standard range
        const expected = c / pCycleTop;
        if (expected > 1e9) {
           el('exp-time-top').textContent = expected.toExponential(2);
        } else {
           el('exp-time-top').textContent = expected.toFixed(1);
        }
      } else {
        // If probability is extremely low (likely 0 due to underflow),
        // it's technically infinite, but let's display scientific notation 
        // if we can approximate it, or infinite if it's truly 0
        if (pCycleTop === 0) {
           el('exp-time-top').textContent = '∞ (prob ≈ 0)';
        } else {
           el('exp-time-top').textContent = (c/pCycleTop).toExponential(2);
        }
      }
    }
  }
}

/* -------------------------------------------------------------------------- */
/* MODULE 4: GAME CONTROLLER                                                 */
/* -------------------------------------------------------------------------- */
class GameController {
  constructor() {
    this.model = new SisyphusModel();
    this.ui = new SisyphusUI(this.model);
    this.timer = null;
    this.renderReq = null;
    this.isAuto = false;
    this.grids = null;
    this.announcer = new AriaAnnouncer();
    this.perfMonitor = new PerformanceMonitor();
    
    this.bindEvents();
    this.bindKeyboard();
    this.load(); 
    this.recalcExpectations();
    this.ui.render(this.grids, true); 
  }

  bindEvents() {
    const $ = id => document.getElementById(id);
    $('roll1_big').onclick = () => this.stepManually();
    $('rollN').onclick = () => {
      const n = +$('nRolls').value || 20;
      for(let i=0; i<n; i++) {
         const res = this.model.step();
         if (!res) break; // Stop if game finished (top hit)
         if (res === 'top') break; 
      }
      this.ui.render(this.grids);
      this.save();
    };
    
    // New "Roll N Cycles" button handler
    $('rollNCycles').onclick = () => {
      const n = +$('nRolls').value || 1;
      const targetCycle = this.model.cycleId + n;
      const maxSteps = 2000000; // Safety break to prevent hanging
      let steps = 0;

      // Loop until we reach the target cycle ID
      while(this.model.cycleId < targetCycle && steps < maxSteps) {
        const res = this.model.step();
        if (!res) break; // Game over state (top hit previously)
        if (res === 'top') break; // Stop immediately on top hit, regardless of cycle count
        steps++;
      }
      
      if (steps >= maxSteps) console.warn("Roll N Cycles: Safety limit reached");
      
      this.ui.render(this.grids);
      this.save();
    };

    $('auto').onclick = () => this.toggleAuto();
    $('apply').onclick = () => this.applyParams();
    $('resetState').onclick = () => this.reset();
    $('setStateBtn').onclick = () => {
      const k = +$('set-k').value || 1;
      const l = +$('set-l').value || 0;
      this.model.setState(k, l);
      this.ui.render(this.grids);
    }
  }
  
  bindKeyboard() {
    document.addEventListener('keydown', (e) => {
      // Ignore if user is typing in input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
        return;
      }
      
      const helpModal = document.getElementById('help-modal');
      
      switch(e.key) {
        case ' ':  // Space
        case 'Enter':
          e.preventDefault();
          if (!helpModal.classList.contains('show')) {
            this.stepManually();
          }
          break;
        case 'r':  // R for reset
        case 'R':
          if (e.ctrlKey || e.metaKey) return; // Don't interfere with browser refresh
          e.preventDefault();
          this.reset();
          break;
        case 'a':  // A for auto
        case 'A':
          e.preventDefault();
          this.toggleAuto();
          break;
        case '?':  // ? for help
          e.preventDefault();
          helpModal.classList.toggle('show');
          break;
        case 'Escape':
          if (helpModal.classList.contains('show')) {
            e.preventDefault();
            helpModal.classList.remove('show');
          }
          break;
      }
    });
  }

  stepManually() {
    if(this.isAuto) this.toggleAuto();
    const res = this.model.step();
    
    // Announce result to screen readers
    if (res === 'top') {
      this.announcer.announce("Congratulations! Top hit reached!");
      alert("Top Hit Reached!");
    } else if (res === 'win') {
      this.announcer.announce(`Win! Now at level ${this.model.state.k}`);
    } else if (res === 'loss') {
      this.announcer.announce("Loss. Reset to level 1");
    } else if (res === 'neu') {
      this.announcer.announce("Neutral. Momentum increased");
    }
    
    this.ui.render(this.grids);
    if(res && res !== 'top') this.ui.log(`step ${this.model.state.step}: ${this.model.lastRoll.outcome.toUpperCase()}`);
    this.save();
  }

  toggleAuto() {
    const btn = document.getElementById('auto');
    if (this.isAuto) {
      // STOPPING - Always clean up
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
      if (this.renderReq) {
        cancelAnimationFrame(this.renderReq);
        this.renderReq = null;
      }
      this.isAuto = false;
      btn.textContent = 'Auto Play';
      this.ui.render(this.grids, true); // Force FULL render on stop
    } else {
      // STARTING
      this.isAuto = true;
      btn.textContent = 'Stop';
      const speed = +document.getElementById('speed').value || 100;
      
      this.timer = setInterval(() => {
        // Check BEFORE and AFTER batch processing
        if(!this.isAuto || this.model.state.topHit) {
          this.toggleAuto();
          return;
        }
        
        const batch = speed < 20 ? 10 : 1; 
        for(let i = 0; i < batch; i++) {
          if(!this.model.state.topHit) {
            this.model.step();
          } else {
            // Stop immediately if top hit during batch
            this.toggleAuto();
            return;
          }
        }
      }, speed);

      let frameCount = 0;
      const loop = () => {
        if(!this.isAuto) return;
        frameCount++;
        const isFullRender = (frameCount % 60 === 0);
        this.ui.render(this.grids, isFullRender); 
        this.perfMonitor.tick();
        this.renderReq = requestAnimationFrame(loop);
      };
      loop();
    }
  }

  applyParams() {
    const p = this.model.params;
    ['M','L','w_min','w_max','beta','rho','gamma','c_min','c_max','alpha','g_n','s_w'].forEach(k => {
      const el = document.getElementById(k);
      if(el) p[k] = +el.value;
    });
    
    // Clear cache when parameters change
    SisyphusMath.clearCache();
    
    this.reset(); 
  }

  reset() {
    this.model.reset();
    this.recalcExpectations();
    this.ui.render(this.grids, true);
    this.ui.els.log.innerHTML = '';
    this.save();
    this.announcer.announce("Game reset");
  }

  recalcExpectations() {
    this.grids = SisyphusMath.solveExpectations(this.model.params);
    this.ui.updateExpectations(this.grids);
  }

  save() {
    const data = {
      params: this.model.params,
      state: this.model.state,
      stats: this.model.stats,
      historyK: this.model.historyK,
      cycleSummaries: this.model.cycleSummaries,
      distributions: this.model.distributions,
      allCycles: this.model.allCycles,
      lastRoll: this.model.lastRoll,
      cycleId: this.model.cycleId,
      currentCycle: this.model.currentCycle
    };
    localStorage.setItem('sisyphus_v8_optimized', JSON.stringify(data));
  }

  load() {
    try {
      const raw = localStorage.getItem('sisyphus_v8_optimized') || 
                  localStorage.getItem('sisyphus_v7_persist'); // Backwards compat
      if(raw) {
        const data = JSON.parse(raw);
        Object.assign(this.model.params, data.params);
        Object.assign(this.model.state, data.state);
        Object.assign(this.model.stats, data.stats);
        
        if(data.historyK) this.model.historyK = data.historyK;
        if(data.cycleSummaries) this.model.cycleSummaries = data.cycleSummaries;
        if(data.distributions) this.model.distributions = data.distributions;
        if(data.allCycles) this.model.allCycles = data.allCycles;
        if(data.lastRoll) this.model.lastRoll = data.lastRoll;
        if(data.cycleId) this.model.cycleId = data.cycleId;
        if(data.currentCycle) this.model.currentCycle = data.currentCycle;

        Object.keys(this.model.params).forEach(k => {
           const el = document.getElementById(k);
           if(el) el.value = this.model.params[k];
        });
      }
    } catch(e) {
      console.warn("Load failed", e);
    }
  }
}

document.addEventListener('DOMContentLoaded', () => {
  window.game = new GameController();
});

</script>
</body>
</html>
