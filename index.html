<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>D20 Catastrophe — No Reflection, No Momentum</title>
<style>
  :root{
    --bg: #0b0f1c;
    --panel: #10172a;
    --edge: #1b2a4a;
    --text: #e6f0ff;
    --muted: #9ab3ff;
    --neon-cyan: #00e5ff;
    --neon-pink: #ff3df0;
    --neon-green: #00ff9c;
    --neon-red: #ff3b3b;
    --neon-blue: #4da6ff;
    --neon-gold: #ffd166;
    --shadow: 0 0 20px rgba(0,229,255,0.25), 0 0 60px rgba(255,61,240,0.12);
    --radius: 18px;
  }

  html, body {
    background:
      radial-gradient(1200px 600px at 10% -10%, rgba(255,61,240,0.07), transparent 60%),
      radial-gradient(1200px 600px at 110% 110%, rgba(0,229,255,0.08), transparent 60%),
      var(--bg);
    color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
    margin: 0;
    -webkit-text-size-adjust: 100%;
    overflow-x: hidden; /* avoid tiny overflow on iOS */
  }

  * { box-sizing: border-box; }

  .wrap {
    max-width: 1100px;
    margin: 12px auto 56px;
    padding: 12px;
    padding-left: max(12px, env(safe-area-inset-left));
    padding-right: max(12px, env(safe-area-inset-right));
  }

  header h1{
    margin: 0 0 6px 0;
    font-weight: 800;
    letter-spacing: .5px;
    text-shadow: 0 0 10px rgba(0,229,255,.4);
    font-size: clamp(20px, 5.5vw, 28px);
    display: flex;
    align-items: center;
    gap: 10px;
  }
  header p {
    margin: 0 0 18px 0;
    color: var(--muted);
    font-size: clamp(.9rem, 3.6vw, .95rem);
  }

  /* D20 logo */
  .logo-d20{
    width: clamp(22px, 6.5vw, 28px);
    height: clamp(22px, 6.5vw, 28px);
    flex: 0 0 auto;
    filter: drop-shadow(0 0 6px rgba(0,229,255,.45)) drop-shadow(0 0 10px rgba(255,61,240,.25));
  }
  .logo-d20 .edge{ stroke: url(#g1); stroke-width: 2; fill: none; }
  .logo-d20 .face{ fill: rgba(0,229,255,.08); stroke: none; }
  .logo-d20 text{
    font: 900 12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
    fill: #e6f0ff;
    letter-spacing: .5px;
  }

  .grid {
    display: grid;
    grid-template-columns: 1.1fr .9fr;
    gap: 16px;
  }
  @media (max-width: 840px){
    .grid { grid-template-columns: 1fr; }
  }

  .card {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)) , var(--panel);
    border: 1px solid var(--edge);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 14px;
  }

  /* Last Roll panel */
  .last-roll {
    display: grid;
    grid-template-columns: 1fr;
    gap: 10px;
    align-items: center;
  }

  .roll-result {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 12px;
    align-items: center;
    padding: 14px;
    border-radius: 16px;
    border: 1px solid var(--edge);
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
  }

  /* Mobile reflow: number + label top, steps below */
  @media (max-width: 480px){
    .roll-result{
      grid-template-columns: auto 1fr;
      grid-template-areas:
        "num label"
        "steps steps";
    }
    .roll-result .roll-number { grid-area: num; }
    .roll-result > div:nth-child(2) { grid-area: label; }
    .roll-result > div:nth-child(3) { grid-area: steps; justify-self: start; margin-top: 6px; }
  }

  .roll-number {
    font-size: clamp(40px, 20vw, 56px);
    font-weight: 900;
    line-height: 1;
    letter-spacing: 1px;
    min-width: 64px;
    text-align: center;
    filter: drop-shadow(0 0 18px rgba(255,255,255,0.04));
  }
  .roll-label {
    font-weight: 800;
    font-size: clamp(15px, 4.2vw, 18px);
    letter-spacing: .6px;
    text-transform: uppercase;
    opacity: .95;
  }
  .roll-sub {
    color: var(--muted);
    font-size: clamp(12px, 3.4vw, 13px);
  }

  .badge {
    font-weight: 700;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid var(--edge);
    background: rgba(255,255,255,0.03);
    font-size: 12px;
    letter-spacing: .4px;
  }

  /* Color states */
  .state-win    { color: var(--neon-green); text-shadow: 0 0 14px rgba(0,255,156,.4); }
  .state-loss   { color: var(--neon-red);   text-shadow: 0 0 14px rgba(255,59,59,.4); }
  .state-neutral{ color: var(--neon-blue);  text-shadow: 0 0 14px rgba(77,166,255,.35); }
  .state-top    { color: var(--neon-gold);  text-shadow: 0 0 14px rgba(255,209,102,.45); }

  /* Flash effects */
  @keyframes flashWin { 0%{box-shadow: 0 0 0 rgba(0,255,156,.0);} 35%{box-shadow: 0 0 28px rgba(0,255,156,.55);} 100%{box-shadow: 0 0 0 rgba(0,255,156,.0);} }
  @keyframes flashCat { 0%{box-shadow: 0 0 0 rgba(255,59,59,.0);} 35%{box-shadow: 0 0 34px rgba(255,59,59,.6);} 100%{box-shadow: 0 0 0 rgba(255,59,59,.0);} }
  .flash-win { animation: flashWin 420ms ease-out; }
  .flash-cat { animation: flashCat 520ms ease-out; }

  .stats-grid {
    display: grid;
    grid-template-columns: repeat(2,1fr);
    gap: 10px;
  }
  @media (max-width: 480px){
    .stats-grid { grid-template-columns: 1fr; }
  }
  .stat {
    padding: 10px 12px;
    border-radius: 12px;
    border: 1px solid var(--edge);
    background: rgba(255,255,255,0.02);
  }
  .stat h3 {
    margin: 0 0 6px 0;
    font-size: 11px;
    font-weight: 800;
    letter-spacing: .6px;
    color: var(--muted);
    text-transform: uppercase;
  }
  .stat .value {
    font-weight: 900;
    font-size: clamp(18px, 6vw, 24px);
    letter-spacing: .5px;
  }
  .row {
    display: grid;
    grid-template-columns: repeat(2,1fr);
    gap: 8px;
    margin-top: 6px;
  }

  /* canvases */
  .canv-wrap {
    border: 1px solid var(--edge);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(0,229,255,0.07), rgba(255,61,240,0.06));
    padding: 8px;
  }
  .canv-title{
    font-size: 12px;
    letter-spacing: .4px;
    color: var(--muted);
    margin: 0 0 6px 2px;
    text-transform: uppercase;
    font-weight: 800;
  }
  canvas { width: 100%; height: 80px; display:block; border-radius: 8px; background: #0a1224; }

  .hist canvas { height: 120px; }

  /* Controls */
  .controls {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin-top: 6px;
  }
  @media (max-width: 520px){
    .controls { grid-template-columns: 1fr 1fr; }
  }
  button {
    appearance: none;
    border: 1px solid var(--edge);
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    color: var(--text);
    padding: 14px 12px;
    border-radius: 14px;
    font-weight: 800;
    letter-spacing: .5px;
    text-transform: uppercase;
    cursor: pointer;
    transition: transform .05s ease, box-shadow .2s ease, border-color .2s ease;
    box-shadow: 0 0 0 rgba(0,0,0,0);
    user-select: none;
    font-size: clamp(12px, 3.4vw, 14px);
  }
  button:hover { transform: translateY(-1px); border-color: var(--neon-cyan); box-shadow: 0 0 18px rgba(0,229,255,.25); }
  button:active { transform: translateY(0); }

  .btn-primary { border-color: var(--neon-cyan); box-shadow: 0 0 14px rgba(0,229,255,.25) inset; }
  .btn-danger  { border-color: var(--neon-red); }
  .btn-warn    { border-color: var(--neon-gold); }
  .btn-on      { box-shadow: 0 0 18px rgba(0,229,255,.4), inset 0 0 18px rgba(0,229,255,.18); }

  footer {
    margin-top: 18px;
    font-size: 12px;
    color: var(--muted);
    text-align: center;
    padding-bottom: max(8px, env(safe-area-inset-bottom));
  }
  code.small {
    color: var(--neon-cyan);
    background: rgba(0,229,255,0.08);
    padding: 1px 6px;
    border-radius: 8px;
    border: 1px solid rgba(0,229,255,0.22);
  }
</style>
</head>
<body>
  <div class="wrap" id="app">
    <header>
      <h1>
        <!-- Neon D20 icon (icosahedron) -->
        <svg class="logo-d20" viewBox="0 0 64 64" aria-hidden="true">
          <defs>
            <linearGradient id="g1" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0" stop-color="#00e5ff"/>
              <stop offset="1" stop-color="#ff3df0"/>
            </linearGradient>
          </defs>
          <!-- simplified icosahedron: top/bottom vertices + two pentagon rings + facet lines -->
          <polygon class="face" points="32,6 49,18 54,34 32,58 10,34 15,18"/>
          <path class="edge" d="M32 6 L49 18 L54 34 L32 58 L10 34 L15 18 Z"/>
          <!-- inner ring -->
          <path class="edge" d="M32 6 L32 22 M49 18 L37 26 M15 18 L27 26 M10 34 L22 34 M54 34 L42 34 M32 58 L32 44"/>
          <!-- cross facets -->
          <path class="edge" d="M27 26 L37 26 L42 34 L32 44 L22 34 Z"/>
          <!-- tiny D20 text -->
          <text x="32" y="36" text-anchor="middle">20</text>
        </svg>
        D20 Catastrophe
      </h1>
      <p>Hit the threshold (≥ <span id="thresholdHdr">20</span>) to <span class="state-win">win</span> and expand the range — at the peak (<code class="small">k = 19</code>), the next win triggers a <span class="state-top">TOP HIT</span> and you reset to <code class="small">k = 1</code>. Rolling <code class="small">1</code> is a <span class="state-loss">catastrophe</span> that also resets to <code class="small">k = 1</code>.</p>
    </header>

    <div class="grid">
      <!-- LEFT: Last roll, sparkline, controls -->
      <section class="card last-roll">
        <div class="roll-result" id="rollCard" aria-live="polite" aria-atomic="true">
          <div class="roll-number" id="lastRoll">—</div>
          <div>
            <div class="roll-label" id="lastOutcome">Press Roll</div>
            <div class="roll-sub">
              k = <span id="kVal">1</span> · Win threshold: <span id="threshold">≥ 20</span>
            </div>
          </div>
          <div>
            <span class="badge">Steps: <span id="steps">0</span></span>
          </div>
        </div>

        <div class="canv-wrap">
          <div class="canv-title">Recent k</div>
          <canvas id="spark" width="800" height="160"></canvas>
        </div>

        <div class="controls">
          <button id="rollBtn" class="btn-primary" title="R / Space">Roll</button>
          <button id="autoBtn" title="A to toggle">Auto</button>
          <button id="stopBtn" class="btn-warn" title="S">Stop</button>
          <button id="resetBtn" class="btn-danger" title="X">Reset</button>
        </div>
      </section>

      <!-- RIGHT: Stats + histogram -->
      <aside class="card">
        <div class="stats-grid">
          <div class="stat">
            <h3>Wins</h3>
            <div class="value state-win" id="wins">0</div>
            <div class="row">
              <div class="stat" style="margin:8px 0 0 0;">
                <h3>Top Hits</h3>
                <div class="value state-top" id="topHits">0</div>
              </div>
              <div class="stat" style="margin:8px 0 0 0;">
                <h3>Current k</h3>
                <div class="value" id="kValBig">1</div>
              </div>
            </div>
          </div>
          <div class="stat">
            <h3>Losses</h3>
            <div class="value state-loss" id="losses">0</div>
            <div class="row">
              <div class="stat" style="margin:8px 0 0 0;">
                <h3>Neutrals</h3>
                <div class="value state-neutral" id="neutrals">0</div>
              </div>
              <div class="stat" style="margin:8px 0 0 0;">
                <h3>Catastrophes</h3>
                <div class="value state-loss" id="cats">0</div>
              </div>
            </div>
          </div>
        </div>

        <div class="canv-wrap hist" style="margin-top:12px;">
          <div class="canv-title">Time at each k</div>
          <canvas id="hist" width="800" height="220" aria-label="Histogram of time at each k"></canvas>
        </div>
      </aside>
    </div>

    <footer>
      Shortcuts: <code class="small">R</code>/<code class="small">Space</code> = Roll ·
      <code class="small">A</code> = Auto/Stop ·
      <code class="small">S</code> = Stop ·
      <code class="small">X</code> = Reset
    </footer>
  </div>

<script>
/* =========================
   D20 Catastrophe (inline)
   ========================= */

const state = {
  k: 1,                   // winning span size (1..19)
  steps: 0,
  wins: 0,
  losses: 0,
  neutrals: 0,
  catastrophes: 0,
  topHits: 0,
  lastRoll: null,
  lastOutcome: '—',
  autoTimer: null,
  recentK: [],            // for sparkline
  histK: Array(20).fill(0) // time spent at each k (index 1..19 used)
};

const els = {
  rollCard: document.getElementById('rollCard'),
  lastRoll: document.getElementById('lastRoll'),
  lastOutcome: document.getElementById('lastOutcome'),
  kVal: document.getElementById('kVal'),
  kValBig: document.getElementById('kValBig'),
  threshold: document.getElementById('threshold'),
  thresholdHdr: document.getElementById('thresholdHdr'),
  steps: document.getElementById('steps'),
  wins: document.getElementById('wins'),
  losses: document.getElementById('losses'),
  neutrals: document.getElementById('neutrals'),
  cats: document.getElementById('cats'),
  topHits: document.getElementById('topHits'),
  spark: document.getElementById('spark'),
  hist: document.getElementById('hist'),
  rollBtn: document.getElementById('rollBtn'),
  autoBtn: document.getElementById('autoBtn'),
  stopBtn: document.getElementById('stopBtn'),
  resetBtn: document.getElementById('resetBtn')
};

/* ---------- Audio (soft, inline, generated) ---------- */
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
}
function beep(type='neutral'){
  try {
    ensureAudio();
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    let freq = 440, dur = 0.05, vol = 0.06;

    if (type === 'win')        { freq = 880; dur = 0.07; vol = 0.07; }
    else if (type === 'cat')   { freq = 220; dur = 0.09; vol = 0.08; }
    else if (type === 'top')   { freq = 1200; dur = 0.08; vol = 0.08; }
    else                       { freq = 440; dur = 0.05; vol = 0.06; }

    o.type = 'triangle';
    o.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(0, now);
    g.gain.linearRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    o.connect(g).connect(audioCtx.destination);
    o.start(now);
    o.stop(now + dur + 0.02);
  } catch(e) {
    // Audio can fail on very strict autoplay policies — it's optional.
  }
}

/* ---------- Core mechanics ---------- */
function rand20(){
  // Deterministic per roll (no momentum); independent draws.
  return Math.floor(Math.random() * 20) + 1;
}
function currentThreshold(k = state.k){
  // Win if roll >= 21 - k
  return 21 - k;
}
function applyRoll(r){
  const thr = currentThreshold();
  let outcome = 'neutral'; // 'win' | 'neutral' | 'loss' | 'cat' | 'top'
  let flashClass = null;
  let sound = 'neutral';

  if (r === 1){
    // catastrophe
    state.catastrophes++;
    state.losses++;
    state.k = 1;
    outcome = 'cat';
    flashClass = 'flash-cat';
    sound = 'cat';
  } else if (r >= thr){
    // win
    state.wins++;
    if (state.k < 19){
      state.k++;
      outcome = 'win';
      flashClass = 'flash-win';
      sound = 'win';
    } else {
      // at top: any win triggers "top hit" and reset to 1
      state.topHits++;
      outcome = 'top';
      state.k = 1;
      flashClass = 'flash-win';
      sound = 'top';
    }
  } else {
    // below threshold but not catastrophe
    state.neutrals++;
    state.losses++;
    outcome = 'neutral';
    sound = 'neutral';
  }

  state.steps++;
  state.lastRoll = r;
  state.lastOutcome = outcome;

  // Track time spent at resulting k (one tick per step)
  state.histK[state.k] = (state.histK[state.k] || 0) + 1;

  // Sparkline (cap length)
  state.recentK.push(state.k);
  if (state.recentK.length > 200) state.recentK.shift();

  // UI updates & effects
  if (flashClass){
    els.rollCard.classList.remove('flash-win','flash-cat');
    void els.rollCard.offsetWidth; // reflow to re-trigger
    els.rollCard.classList.add(flashClass);
  }
  beep(sound);
  updateUI();
}

function roll(){
  const r = rand20();
  applyRoll(r);
}

/* ---------- Auto runner ---------- */
function startAuto(){
  if (state.autoTimer) return;
  els.autoBtn.classList.add('btn-on');
  state.autoTimer = setInterval(roll, 100); // ~100ms
}
function stopAuto(){
  if (state.autoTimer){
    clearInterval(state.autoTimer);
    state.autoTimer = null;
  }
  els.autoBtn.classList.remove('btn-on');
}
function toggleAuto(){
  if (state.autoTimer) stopAuto(); else startAuto();
}

/* ---------- Reset ---------- */
function resetGame(){
  stopAuto();
  state.k = 1;
  state.steps = 0;
  state.wins = 0;
  state.losses = 0;
  state.neutrals = 0;
  state.catastrophes = 0;
  state.topHits = 0;
  state.lastRoll = null;
  state.lastOutcome = '—';
  state.recentK = [];
  state.histK = Array(20).fill(0);
  updateUI(true);
}

/* ---------- HiDPI Canvas helper ---------- */
function setupHiDPICanvas(c){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const cssW = Math.max(1, Math.floor(c.getBoundingClientRect().width));
  const cssH = Math.max(1, Math.floor(parseFloat(getComputedStyle(c).height)));
  // Resize drawing buffer to match CSS * DPR
  c.width = Math.round(cssW * dpr);
  c.height = Math.round(cssH * dpr);
  const ctx = c.getContext('2d');
  // Normalize coordinates to CSS pixels
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { ctx, w: cssW, h: cssH };
}

/* ---------- UI ---------- */
function updateUI(isReset=false){
  // Text fields
  els.kVal.textContent = state.k;
  els.kValBig.textContent = state.k;
  const thr = currentThreshold();
  els.threshold.textContent = '≥ ' + thr;
  els.thresholdHdr.textContent = thr;
  els.steps.textContent = state.steps;
  els.wins.textContent = state.wins;
  els.losses.textContent = state.losses;
  els.neutrals.textContent = state.neutrals;
  els.cats.textContent = state.catastrophes;
  els.topHits.textContent = state.topHits;

  // Last roll panel
  if (state.lastRoll == null){
    els.lastRoll.textContent = '—';
    els.lastOutcome.textContent = 'Ready';
    els.lastOutcome.className = 'roll-label';
  } else {
    els.lastRoll.textContent = state.lastRoll;
    const L = els.lastOutcome;
    L.className = 'roll-label';
    if (state.lastOutcome === 'win'){
      L.textContent = 'WIN';
      L.classList.add('state-win');
    } else if (state.lastOutcome === 'top'){
      L.textContent = 'TOP HIT → RESET';
      L.classList.add('state-top');
    } else if (state.lastOutcome === 'cat'){
      L.textContent = 'CATASTROPHE → RESET';
      L.classList.add('state-loss');
    } else if (state.lastOutcome === 'neutral'){
      L.textContent = 'NEUTRAL';
      L.classList.add('state-neutral');
    } else {
      L.textContent = state.lastOutcome.toUpperCase();
    }
  }

  // Draw sparkline and histogram (retina-aware)
  drawSparkline();
  drawHistogram();
}

/* ---------- Canvas: Sparkline (recent k) ---------- */
function drawSparkline(){
  const c = els.spark;
  const { ctx, w, h } = setupHiDPICanvas(c);

  ctx.clearRect(0,0,w,h);

  // subtle grid
  ctx.globalAlpha = 0.10;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  const levels = 19;
  for (let i=1;i<=levels;i++){
    const y = mapKtoY(i, h);
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(w, y);
    ctx.stroke();
  }
  ctx.globalAlpha = 1.0;

  const data = state.recentK;
  if (data.length < 2) return;

  // gradient line
  ctx.lineWidth = 2;
  const grad = ctx.createLinearGradient(0,0,w,0);
  grad.addColorStop(0, '#00e5ff');
  grad.addColorStop(1, '#ff3df0');
  ctx.strokeStyle = grad;

  ctx.beginPath();
  const N = data.length;
  const xStep = w / (N - 1);
  for (let i=0;i<N;i++){
    const x = i * xStep;
    const y = mapKtoY(data[i], h);
    if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();

  // fill glow
  ctx.globalAlpha = 0.12;
  ctx.lineTo(w, h);
  ctx.lineTo(0, h);
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.globalAlpha = 1.0;

  function mapKtoY(k, hgt){
    const minK = 1, maxK = 19;
    const t = (k - minK) / (maxK - minK);
    const pad = 8;
    return (hgt - pad) - t * (hgt - 2*pad);
  }
}

/* ---------- Canvas: Histogram (time at each k) ---------- */
function drawHistogram(){
  const c = els.hist;
  const { ctx, w, h } = setupHiDPICanvas(c);

  ctx.clearRect(0,0,w,h);

  const counts = state.histK.slice(1, 20); // k=1..19
  const max = Math.max(1, ...counts);
  const n = counts.length;
  const gap = 4;
  const barW = (w - gap*(n+1)) / n;

  // baseline
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, h-0.5);
  ctx.lineTo(w, h-0.5);
  ctx.stroke();

  // bars
  for (let i=0;i<n;i++){
    const v = counts[i];
    const ratio = v / max;
    const barH = Math.max(2, Math.round(ratio * (h - 16)));
    const x = gap + i*(barW + gap);
    const y = h - barH;

    const grad = ctx.createLinearGradient(0, y, 0, y+barH);
    grad.addColorStop(0, '#00e5ff');
    grad.addColorStop(1, '#ff3df0');

    ctx.fillStyle = grad;
    ctx.fillRect(x, y, barW, barH);

    // k labels (tiny)
    ctx.fillStyle = 'rgba(230,240,255,0.6)';
    ctx.font = '10px ui-sans-serif, system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(String(i+1), x + barW/2, h - 2);
  }
}

/* ---------- Controls & Keys ---------- */
function preventScroll(e){
  if (e.code === 'Space') { e.preventDefault(); }
}
function onKey(e){
  const k = e.key.toLowerCase();
  if (k === 'r' || e.code === 'Space'){
    e.preventDefault();
    roll();
  } else if (k === 'a'){
    toggleAuto();
  } else if (k === 's'){
    stopAuto();
  } else if (k === 'x'){
    resetGame();
  }
}

function bindEvents(){
  // Buttons
  els.rollBtn.addEventListener('click', () => roll());
  els.autoBtn.addEventListener('click', () => toggleAuto());
  els.stopBtn.addEventListener('click', () => stopAuto());
  els.resetBtn.addEventListener('click', () => resetGame());

  // Keyboard
  window.addEventListener('keydown', preventScroll, {passive:false});
  window.addEventListener('keydown', onKey);

  // Any gesture should resume audio if suspended
  ['click','keydown','touchstart'].forEach(ev=>{
    window.addEventListener(ev, () => { try { ensureAudio(); } catch {} }, { once:true });
  });

  // Make buttons feel responsive on mobile
  document.querySelectorAll('button').forEach(btn=>{
    btn.addEventListener('touchstart', ()=>btn.classList.add('btn-on'), {passive:true});
    btn.addEventListener('touchend', ()=>btn.classList.remove('btn-on'), {passive:true});
  });

  // Redraw canvases on resize/orientation
  window.addEventListener('resize', () => {
    drawSparkline();
    drawHistogram();
  });
}

/* ---------- Init ---------- */
function init(){
  // Seed sparkline with initial k
  state.recentK = [state.k];
  updateUI(true);
  bindEvents();
}
init();
</script>
</body>
</html>
